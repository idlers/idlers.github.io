<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>TS概述、搭建环境、常用类型 | 阿闲Blog</title><meta name="keywords" content="TypeScript"><meta name="author" content="null,axian-c@qq.com"><meta name="copyright"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="TS概述、搭建环境、常用类型"><meta name="application-name" content="TS概述、搭建环境、常用类型"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta name="description" content="Typescript 概述、搭建环境、常用类型一、TypeScript 介绍1.1 TypeScript 是什么 TypeScript（简称：TS）是 JavaScript 的超集（JS 有的 TS 都有）  TypeScript &#x3D; Type + JavaScript（在 JS 基础之上，为 JS 添加了类型支持）  TypeScript 是微软开发的开源编程语言，可以在任何运行 Ja">
<meta property="og:type" content="article">
<meta property="og:title" content="TS概述、搭建环境、常用类型">
<meta property="og:url" content="http://example.com/2023/06/20/TS%20%E6%A6%82%E8%BF%B0%E3%80%81%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83%E3%80%81%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%9E%8B/index.html">
<meta property="og:site_name" content="阿闲Blog">
<meta property="og:description" content="Typescript 概述、搭建环境、常用类型一、TypeScript 介绍1.1 TypeScript 是什么 TypeScript（简称：TS）是 JavaScript 的超集（JS 有的 TS 都有）  TypeScript &#x3D; Type + JavaScript（在 JS 基础之上，为 JS 添加了类型支持）  TypeScript 是微软开发的开源编程语言，可以在任何运行 Ja">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pic2.zhimg.com/v2-a6d23e37f009ab0337ec88401458962f_250x0.jpg?source=172ae18b">
<meta property="article:published_time" content="2023-06-20T12:56:00.277Z">
<meta property="article:modified_time" content="2023-06-20T12:58:58.724Z">
<meta property="article:tag" content="TypeScript">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic2.zhimg.com/v2-a6d23e37f009ab0337ec88401458962f_250x0.jpg?source=172ae18b"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="http://example.com/2023/06/20/TS%20%E6%A6%82%E8%BF%B0%E3%80%81%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83%E3%80%81%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%9E%8B/"><link rel="preconnect" href="//npm.elemecdn.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://npm.elemecdn.com/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/@fancyapps/ui@4.0.31/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  friends_vue_info: {"apiurl":null},
  navMusic: true,
  changeMainColorPost: undefined,
  algolia: undefined,
  localSearch: {"path":{"option":{"local_search":"https://npm.elemecdn.com/anzhiyu-blog@2.1.2/js/search/local-search.js"}},"preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"它已经","messageNext":"距离上次更新有几天了，文章的内容可能已经过时了。"},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#3b70fc","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://npm.elemecdn.com/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://npm.elemecdn.com/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'TS概述、搭建环境、常用类型',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-06-20 20:58:58'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 8 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css" /><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="web_box"><div id="web_container"><div id="menu-mask"></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/"><div class="title">阿闲Blog</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child" style="left:-79px;"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child" style="left:-79px;"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 阿闲</span></a><ul class="menus_item_child" style="left:-79px;"><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 影视聚</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child" style="left:-79px;"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于阿闲</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言闲话</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 闲人文章</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><div class="nav-button" id="darkmode_navswitch"><a class="darkmode_switchbutton" type="button" href="javascript:void(0);" title="浅色和深色模式转换" onclick="anzhiyu.switchDarkMode()"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke" style="font-size: 1.3rem"></i></a></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="article-meta tags"><a class="article-meta__tags" href="/tags/TypeScript/"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>TypeScript</span></a></span></div></div><h1 class="post-title">TS概述、搭建环境、常用类型</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-06-20T12:56:00.277Z" title="发表于 2023-06-20 20:56:00">2023-06-20</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-20T12:58:58.724Z" title="更新于 2023-06-20 20:58:58">2023-06-20</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">11.6k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>41分钟</span></span><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="TS概述、搭建环境、常用类型"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为河北"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>河北</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://pic2.zhimg.com/v2-a6d23e37f009ab0337ec88401458962f_250x0.jpg?source=172ae18b"></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Typescript-概述、搭建环境、常用类型"><a href="#Typescript-概述、搭建环境、常用类型" class="headerlink" title="Typescript 概述、搭建环境、常用类型"></a>Typescript 概述、搭建环境、常用类型</h1><h2 id="一、TypeScript-介绍"><a href="#一、TypeScript-介绍" class="headerlink" title="一、TypeScript 介绍"></a>一、TypeScript 介绍</h2><h3 id="1-1-TypeScript-是什么"><a href="#1-1-TypeScript-是什么" class="headerlink" title="1.1 TypeScript 是什么"></a>1.1 TypeScript 是什么</h3><ul>
<li><strong>TypeScript（简称：TS）是 JavaScript 的超集（JS 有的 TS 都有）</strong> </li>
<li><strong>TypeScript &#x3D; Type + JavaScript（在 JS 基础之上，为 JS 添加了类型支持）</strong> </li>
<li><strong>TypeScript 是微软开发的开源编程语言，可以在任何运行 JavaScript 的地方运行</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TypeScript代码:有明确的类型，即: number (数值类型)</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">age1</span>:number = <span class="number">18</span></span><br><span class="line"><span class="comment">// JavaScript 代码:无明确的类型</span></span><br><span class="line"><span class="keyword">let</span> age2 = <span class="number">18</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-TypeScript-为什么要为-JS-添加类型支持？"><a href="#1-2-TypeScript-为什么要为-JS-添加类型支持？" class="headerlink" title="1.2 TypeScript 为什么要为 JS 添加类型支持？"></a>1.2 TypeScript 为什么要为 JS 添加类型支持？</h3><p>背景：JS 的类型系统存在”先天缺陷”，JS 代码中绝大部分错误都是类型错误 (Uncaught TypeError)。<br>问题：增加了找 Bug、改 Bug 的时间，严重影响开发效率。<br>从编程语言的动静来区分，TypeScript 属于静态类型的编程语言，JS属于动态类型的编程语言。<br>静态类型：编译期做类型检查<br>动态类型：执行期做类型检查<br>代码编译和代码执行的顺序：1编译 2执行。<br>对于JS来说：需要等到代码真正去执行的时候才能发现错误（晚）。<br>对于TS来说：在代码编译的时候（代码执行前）就可以发现错误（早）。<br>并且，配合 VSCode 等开发工具，TS 可以提前到在编写代码的同时就发现代码中的错误，减少找 Bug、改 Bug 时间</p>
<h3 id="1-3-TypeScript-相比-JS-的优势"><a href="#1-3-TypeScript-相比-JS-的优势" class="headerlink" title="1.3 TypeScript 相比 JS 的优势"></a>1.3 TypeScript 相比 JS 的优势</h3><ol>
<li>更早（写代码的同时）发现错误，减少找 Bug、改 Bug 时间，提升开发效率。 </li>
<li>程序中任何位置的代码都有代码提示，随时随地的安全感，增强了开发体验。 </li>
<li>强大的类型系统提升了代码的可维护性，使得重构代码更加容易。 </li>
<li>支特最新的 ECMAScript 语法，优先体验最新的语法，让你走在前端技术的最前沿。 </li>
<li>TS 类型推断机制，不需要在代码中的每个地方都显示标注类型，让你在享受优势的同时，尽量降低了成本。</li>
</ol>
<p>除此之外，Vue3 源码使用 TS 重写、Angular 默认支持 TS、React 与 TS 完美配合，TypeScript 已成为大中型前端项目的首先编程语言。</p>
<h2 id="二、TypeScript-环境搭建"><a href="#二、TypeScript-环境搭建" class="headerlink" title="二、TypeScript 环境搭建"></a>二、TypeScript 环境搭建</h2><h3 id="2-1-安装编译-TS-的工具包"><a href="#2-1-安装编译-TS-的工具包" class="headerlink" title="2.1 安装编译 TS 的工具包"></a>2.1 安装编译 TS 的工具包</h3><p>Node.js 和浏览器，只认识TS代码，不认识TS代码，需要安装编译TS的工具包将TS代码转化为S代<br>码，然后才能运行。<br>安装命令：<code>npm i -g typescript</code><br>typescript包：用来编译 TS 代码的包，提供了 tsc 命令，实现了 TS -&gt; JS 的转化。<br>验证是否安装成功：tsc-v (查看 typescript 的版本)。</p>
<h3 id="2-2-编译并运行-TS-代码"><a href="#2-2-编译并运行-TS-代码" class="headerlink" title="2.2 编译并运行 TS 代码"></a>2.2 编译并运行 TS 代码</h3><ol>
<li>创建 hello.ts文件（注意：TS 文件的后缀名为 .ts) </li>
<li>将TS编译为JS:在终端中输入命令，<code>tsc hello.ts</code> (此时，在同级目录中会出现一个同名的 JS 文件) </li>
<li>执行 JS 代码：在终端中输入命令，<code>node hello.js</code></li>
</ol>
<blockquote>
<p>所有合法的 JS 代码都是 TS 代码，有 JS 基础只需要学习 TS 的类型即可<br>由 TS 编译生成的 JS 文件，代码中就没有类型信息了</p>
</blockquote>
<h3 id="2-3-简化运行-TS-的步骤"><a href="#2-3-简化运行-TS-的步骤" class="headerlink" title="2.3 简化运行 TS 的步骤"></a>2.3 简化运行 TS 的步骤</h3><p>每次修改代码后，都要重复执行两个命令，才能运行 TS 代码，太繁琐使用 ts-node 包，直接在 Node.js 中执行 TS 代码</p>
<p>安装命令：<code>npm i -g ts-code</code> (ts-node 包提供了 ts-node 命令)</p>
<p>使用方式：<code>ts-node hello.ts</code></p>
<p>ts-node 命令在内部偷偷的将 TS&gt;JS，然后，再运行 JS 代码</p>
<h2 id="三、TypeScript-常用类型"><a href="#三、TypeScript-常用类型" class="headerlink" title="三、TypeScript 常用类型"></a>三、TypeScript 常用类型</h2><p><strong>类型概述</strong></p>
<p>TypeScript 是 JS 的超集，TS 提供了 JS 的所有功能，并且额外的增加了：<strong>类型系统</strong>。</p>
<ul>
<li>所有的 JS 代码都是 TS 代码。</li>
<li>JS 类型（比如 number&#x2F;string 等），但是 JS 不会检查变量的类型是否发生变化。而 TS 会检查。</li>
</ul>
<p>TypeScript 类型系统的主要优势：可以显示标记出代码中的意外行为，从而降低了发生错误的可能性。</p>
<h3 id="3-1-类型注解"><a href="#3-1-类型注解" class="headerlink" title="3.1 类型注解"></a>3.1 类型注解</h3><p><strong>示例代码：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">age</span>: number = <span class="number">18</span></span><br></pre></td></tr></table></figure>

<p>代码中的 <code>：number</code> 就是类型注解<br>为变量添加类型约束。上述代码中，约定变量 age 的类型为 number (数值类型)<br>约定了什么类型，就只能给变量赋值该类型的值，否则，就会报错</p>
<h3 id="3-2-常用基础类型概述"><a href="#3-2-常用基础类型概述" class="headerlink" title="3.2 常用基础类型概述"></a>3.2 常用基础类型概述</h3><p>可以将 TS 中的常用基础类型细分为两类： JS 已有类型 和TS 新增类型</p>
<ol>
<li>JS 已有类型</li>
</ol>
<ul>
<li>原始类型：number&#x2F;string&#x2F;boolean&#x2F;null&#x2F;undefined&#x2F;symbol </li>
<li>对象类型：object（包括，数组、对象、函数等对象）</li>
</ul>
<ol start="2">
<li>TS 新增类型</li>
</ol>
<ul>
<li>联合类型、自定义类型（类型别名）、接口、元组、字面量类型、枚举、void、any 等</li>
</ul>
<h3 id="3-3-原始类型"><a href="#3-3-原始类型" class="headerlink" title="3.3 原始类型"></a>3.3 原始类型</h3><p>原始类型：number &#x2F;string &#x2F;boolean &#x2F;null &#x2F;undefined &#x2F;symbol</p>
<p>特点：简单。这些类型，可以按照  JS 中类型的名称来书写。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">age</span>: <span class="built_in">number</span> = <span class="number">18</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">pname</span>: <span class="built_in">string</span> = <span class="string">&#x27;张三&#x27;</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">flag</span>: <span class="built_in">boolean</span> = <span class="literal">true</span></span><br><span class="line"><span class="comment">// 等等...</span></span><br></pre></td></tr></table></figure>



<h3 id="3-4-数组类型"><a href="#3-4-数组类型" class="headerlink" title="3.4 数组类型"></a>3.4 数组类型</h3><p>对象类型：object（包括，数组、对象、函数等对象）</p>
<p>对象类型，在 TS 中更加细化，每个具体的对象都有自己的类型语法</p>
<p>数组类型的两种写法：（推荐使用 number[] 写法）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">numbers</span>: number[] = [ <span class="number">1</span> , <span class="number">2</span> , <span class="number">3</span> , <span class="number">4</span> , <span class="number">5</span> ]</span><br><span class="line"><span class="keyword">let</span> <span class="attr">strings</span>: <span class="title class_">Array</span>&lt;string&gt; = [<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;world&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>如果数组中既有 number 类型，又有 string 类型 ，那么可以使用 <strong>联合类型</strong> 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">list</span>: (number | string)[] = [ <span class="number">1</span> , <span class="string">&#x27;hello&#x27;</span>, <span class="number">2</span> , <span class="string">&#x27;world&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>“|” （竖线）在 TS 中叫做联合类型（由两个或多个其他类型组成的类型，表示可以是这些类型中的任意一种）</p>
<h3 id="3-5-类型别名"><a href="#3-5-类型别名" class="headerlink" title="3.5 类型别名"></a>3.5 类型别名</h3><p>类型别名（自定义类型），为任意类型起别名。</p>
<p>当同一类型（复杂）被多次使用时，可以通过类型别名，简化该类型的使用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 type 关键字来创建类型别名</span></span><br><span class="line"><span class="comment">// 类型别名可以是任意合法的变量名称</span></span><br><span class="line"><span class="comment">// 创建类型别名后，直接使用该类型别名作为变量的类型注解即可</span></span><br><span class="line">type customArray = (number | string)[]</span><br><span class="line"><span class="keyword">let</span> <span class="attr">arr1</span>: customArray = [ <span class="number">1</span> , <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="number">4</span> ]</span><br><span class="line"><span class="keyword">let</span> <span class="attr">arr2</span>: customArray = [ <span class="number">1</span> , <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="number">2</span> ]</span><br></pre></td></tr></table></figure>

<h3 id="3-6-函数类型"><a href="#3-6-函数类型" class="headerlink" title="3.6 函数类型"></a>3.6 函数类型</h3><p>函数的类型实际上指的是 <strong>函数参数</strong> 和 <strong>返回值</strong> 的类型</p>
<p>为函数指定类型的两种方式：</p>
<ol>
<li>单独指定参数、返回值的类型 </li>
<li>同时指定参数、返回值的类型</li>
</ol>
<h4 id="3-6-1-单独指定参数、返回值的类型"><a href="#3-6-1-单独指定参数、返回值的类型" class="headerlink" title="3.6.1 单独指定参数、返回值的类型"></a>3.6.1 单独指定参数、返回值的类型</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">num1: number, num2: number</span>): number &#123;</span><br><span class="line">	<span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="keyword">const</span> add = (<span class="attr">num1</span>: number, <span class="attr">num2</span>: number): <span class="function"><span class="params">number</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-6-2-同时指定参数、返回值的类型"><a href="#3-6-2-同时指定参数、返回值的类型" class="headerlink" title="3.6.2 同时指定参数、返回值的类型"></a>3.6.2 同时指定参数、返回值的类型</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">add</span>: <span class="function">(<span class="params">num1: number, num2: number</span>) =&gt;</span> number = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当函数作为表达式时，可以通过类似箭头函数形式的语法来为函数添加类型</p>
<blockquote>
<p>这种形式只适用于函数表达式</p>
</blockquote>
<p>如果函数没有返回值，那么，函数返回值类型为：void</p>
<h4 id="3-6-3-函数可选参数"><a href="#3-6-3-函数可选参数" class="headerlink" title="3.6.3 函数可选参数"></a>3.6.3 函数可选参数</h4><p>使用函数实现某个功能时，参数可以传也可以不传。这种情况下，在给函数参数指定类型时，需要用到<strong>可选参数</strong>。</p>
<p>比如，数组的 slice 方法，可以 slice(0) 也可以 slice(1) 还可以 slice(1,3)</p>
<p>在可传可不传的参数名称后面添加？（问号）</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mySlice</span>(<span class="params">start?: <span class="built_in">number</span>, end?: <span class="built_in">number</span></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;起始索引：&#x27;</span>, start, <span class="string">&#x27;结束索引：&#x27;</span>, end)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可选参数只能出现在参数列表的最后，也就是说可选参数后面不能再出现必选参数</p>
</blockquote>
<h3 id="3-7-对象类型"><a href="#3-7-对象类型" class="headerlink" title="3.7 对象类型"></a>3.7 对象类型</h3><p>JS中的对象是由属性和方法构成的，而TS中对象的类型就是在描述对象的结构（有什么类型的属性和方法)。对象类型的写法：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">person</span>: &#123; <span class="attr">name</span>: <span class="built_in">string</span>; <span class="attr">age</span>: <span class="built_in">number</span>; <span class="title function_">sayHi</span>(): <span class="built_in">void</span> &#125; = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;zs&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接使用{}来描述对象结构。属性采用<strong>属性名</strong>：<strong>类型</strong>的形式；方法采用<strong>方法名()<strong>：</strong>返回值类型</strong>的形式</p>
<p>如果方法有参数，就在方法名后面的小括号中指定参数类型（比如：<strong>greet ( name: string ) : void</strong>)</p>
<p>在一行代码中指定对象的多个属性类型时，使用；（分号）来分隔</p>
<p>如果一行代码只指定一个属性类型（通过换行来分隔多个属性类型），可以去掉；（分号）</p>
<p>方法的类型也可以使用箭头函数形式<strong>（比如：{ sayHi : () &#x3D;&gt; void })</strong></p>
<h4 id="3-7-1-可选属性"><a href="#3-7-1-可选属性" class="headerlink" title="3.7.1 可选属性"></a>3.7.1 可选属性</h4><p>对象的属性或方法，也可以是可选的，此时需要用到可选属性。<br>比如，我们在使用 axios({ … }) 时，如果发送 GET 请求，method 属性就可以省略。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myAxios</span>(<span class="params">config: &#123; url: <span class="built_in">string</span>; method?: <span class="built_in">string</span> &#125;</span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(config)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>可选属性</strong>的语法与函数可选参数的语法一致，都使用 ?（问号）来表示</p>
<h3 id="3-8-接口"><a href="#3-8-接口" class="headerlink" title="3.8 接口"></a>3.8 接口</h3><p>当一个对象类型被多次使用时，一般会使用接口(interface)来描述对象的类型，达到复用的目的。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 interface 关键字来声明接口</span></span><br><span class="line"><span class="comment">// 接口名称（比如，此处的 IPerson），可以是任意合法的变量名称</span></span><br><span class="line"><span class="comment">// 声明接口后，直接使用接口名称作为变量的类型</span></span><br><span class="line"><span class="comment">// 因为每一行只有一个属性类型，因此，属性类型后没有 ;（分号）</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IPerson</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">    <span class="title function_">sayHi</span>(): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">person</span>: <span class="title class_">IPerson</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;zhangsan&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">19</span> ,</span><br><span class="line">    <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>interface（接口）和 type（类型别名）的对比</strong></p>
<ul>
<li>相同点：都可以给对象指定类型</li>
<li>不同点 <ul>
<li>接口，只能为对象指定类型。</li>
<li>类型别名，不仅可以为对象指定类型，实际上可以为任意类型指定别名。</li>
</ul>
</li>
</ul>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IPerson</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">	<span class="title function_">sayHi</span>(): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 类型别名</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">IPerson</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">    <span class="title function_">sayHi</span>(): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">NumStr</span> = <span class="built_in">number</span> | <span class="built_in">string</span></span><br></pre></td></tr></table></figure>

<h5 id="接口继承"><a href="#接口继承" class="headerlink" title="接口继承"></a>接口继承</h5><p>比如，这两个接口都有X、y两个属性，重复写两次，比较繁琐，可以采用继承的方式来实现。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Point2D</span> &#123;</span><br><span class="line">    <span class="attr">X</span>: <span class="built_in">number</span></span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Point3D</span> &#123;</span><br><span class="line">    <span class="attr">X</span>: <span class="built_in">number</span></span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">number</span></span><br><span class="line">    <span class="attr">z</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 改造后</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Point2D</span> &#123; <span class="attr">x</span>: <span class="built_in">number</span>; <span class="attr">y</span>: <span class="built_in">number</span> &#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Point3D</span> <span class="keyword">extends</span> <span class="title class_">Point2D</span> &#123; <span class="attr">z</span>: <span class="built_in">number</span> &#125;</span><br></pre></td></tr></table></figure>

<p>使用 extends（继承）关键字实现了接口 Point3D 继承 Point2D<br>继承后，Point3D 就有了 Point2D 的所有属性和方法（此时，Point3D 同时有 x、y、z 三个属性）</p>
<h3 id="3-9-元组"><a href="#3-9-元组" class="headerlink" title="3.9 元组"></a>3.9 元组</h3><p>比如在地图中，使用经纬度坐标来标记位置信息。<br>可以使用数组来记录坐标，那么，该数组中只有两个元素，并且这两个元素都是数值类型</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">position</span>: <span class="built_in">number</span>[] = [<span class="number">39.5427</span>，<span class="number">116.2317</span> ]</span><br></pre></td></tr></table></figure>

<p>使用number)表示的不严谨，因为该类型的数组中可以出现任意多个数字，这时候可以采用<strong>元组(Tuple)</strong><br><strong>元组</strong>类型是另一种类型的数组，它<strong>确切地知道包含多少个元素，以及特定索引对应的类型</strong></p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 元组类型可以确切地标记出有多少个元素，以及每个元素的类型</span></span><br><span class="line"><span class="comment">// 该示例中，元素有两个元素，每个元素的类型都是 number</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">position</span>: [ <span class="built_in">number</span>, <span class="built_in">number</span>] = [ <span class="number">39.5427</span>，<span class="number">116.2317</span>]</span><br></pre></td></tr></table></figure>

<h3 id="3-10-类型推论"><a href="#3-10-类型推论" class="headerlink" title="3.10 类型推论"></a>3.10 类型推论</h3><p>在TS中，某些没有明确指出类型的地方，TS的<strong>类型推论机制会帮助提供类型。</strong><br>由于类型推论的存在，这些地方，类型注解可以省略不写！<br>发生类型推论的2种常见场景：</p>
<ol>
<li>声明变量并初始化时</li>
<li>决定函数返回值时</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/760851/1684217517870-adcbdaf8-61dc-4be0-a43b-755323af79e6.png#averageHue=%23fcfcfc&clientId=u9a070cde-6f07-4&from=paste&height=72&id=ubf97444a&originHeight=108&originWidth=310&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=2897&status=done&style=none&taskId=u81c53a9a-83be-4b68-ace8-a831514a9e6&title=&width=206.66666666666666" alt="image.png"></p>
<blockquote>
<p>鼠标移入变量名称age,TS自动推断出变量age为number类型</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/760851/1684217523133-142fedfd-6c63-4c54-8aba-5e37e53ad412.png#averageHue=%23fbfbfa&clientId=u9a070cde-6f07-4&from=paste&height=87&id=u2771941f&originHeight=130&originWidth=602&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=7867&status=done&style=none&taskId=uaa6d38cd-3ae5-4db7-808a-498405e22d9&title=&width=401.3333333333333" alt="image.png"><br>这两种情况下，类型注解可以省略不写<br>能省略类型注解的地方就省略(“偷懒”，充分利用TS类型推论的能力，提升开发效率)</p>
<blockquote>
<p>如果不知道类型，可以通过鼠标放在变量名称上，利用VSCode的提示来查看类型</p>
</blockquote>
<h3 id="3-11-类型断言"><a href="#3-11-类型断言" class="headerlink" title="3.11 类型断言"></a>3.11 类型断言</h3><p>有时候你会比TS更加明确一个值的类型，此时，可以使用类型断言来指定更具体的类型<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/760851/1684217572397-4435b314-974a-415f-ab35-c616f6f92b4a.png#averageHue=%23f9f8f7&clientId=u150173ce-c6a1-4&from=paste&height=56&id=u1e96dd04&originHeight=84&originWidth=469&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=5872&status=done&style=none&taskId=ue82d76ea-83dc-4e8d-bbcd-2ca0df5ece1&title=&width=312.6666666666667" alt="image.png"><br><strong>注意：</strong>getElementByld 方法返回值的类型是 HTMLElement，该类型只包含所有标签公共的属性或方法，不包含 a 标签特有的 href 等属性<br>因此，这个<strong>类型大宽泛（不具体）</strong>，无法操作 href 等 a 标签特有的属性或方法。<br>解决方式：这种情况下就需要使用<strong>类型断言</strong>指定更加具体的类型。<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/760851/1684217582560-8f8d9655-964b-4dc3-a809-28e2020efff2.png#averageHue=%23fcfbfb&clientId=u150173ce-c6a1-4&from=paste&height=72&id=u70e0f6b0&originHeight=108&originWidth=726&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=8133&status=done&style=none&taskId=u8040af66-2578-4b71-8f71-42a1f4ad2d4&title=&width=484" alt="image.png"><br>使用 as 关键字实现类型断言<br>关键字 as 后面的类型是一个更加具体的类型(HTMLAnchorElement 是 HTMLElement 的子类型)<br>通过类型断言，aLik 的类型变得更加具体，这样就可以访问 a 标签特有的属性或方法了<br><strong>第二种写法：</strong>使用 &lt;&gt; 语法<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/760851/1684217597880-580890e2-bd79-46f7-a339-422a6aeee5eb.png#averageHue=%23fbfbfa&clientId=u150173ce-c6a1-4&from=paste&height=67&id=uda22288e&originHeight=100&originWidth=659&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=8042&status=done&style=none&taskId=uaa2d6c4c-1d54-413b-b191-3336b996242&title=&width=439.3333333333333" alt="image.png"></p>
<blockquote>
<p>在浏览器控制台，通过 console..dir() 打印 DOM 元素，在属性列表的最后面，即可看到该元素的类型</p>
</blockquote>
<h3 id="3-12-字面量类型"><a href="#3-12-字面量类型" class="headerlink" title="3.12 字面量类型"></a>3.12 字面量类型</h3><p>例如：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str1 = <span class="string">&#x27;Hello TS&#x27;</span></span><br><span class="line"><span class="keyword">const</span> str2 = <span class="string">&#x27;Hello TS&#x27;</span></span><br></pre></td></tr></table></figure>
<p>通过TS类型推论机制，可以得到</p>
<ul>
<li>变量str1的类型为：string</li>
<li>常量str2的类型为：Hello TS</li>
</ul>
<p>str1是一个变量 (Iet)，它的值可以是任意字符串，所以类型为：string<br>str2是一个常量 (const)，它的值不能变化只能是 ‘Hello TS’ ，所以，它的类型为：’Hello TS’</p>
<blockquote>
<p>此处的Hello TS’,就是一个字面量类型。也就是说某个特定的字符串也可以作为TS中的类型<br>除字符串外，任意的S字面量（比如，对象、数字等）都可以作为类型使用</p>
</blockquote>
<p><strong>字面量类型配合联合类型一起使用</strong>，用来表示一组明确的可选值列表<br>比如：在贪吃蛇游戏中，游戏的方向的可选值只能是上、下、左、右中的任意一个</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">changeDirection</span>(<span class="params">direction: <span class="string">&#x27; up&#x27;</span> | <span class="string">&#x27; down&#x27;</span> | <span class="string">&#x27;left&#x27;</span> | <span class="string">&#x27; right&#x27;</span></span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(direction)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解释：参数direction的值只能是up&#x2F;down&#x2F;left&#x2F;.right中的任意一个。<br>优势：相比于string类型，使用字面量类型更加精确、严谨。</p>
<h3 id="3-13-枚举"><a href="#3-13-枚举" class="headerlink" title="3.13 枚举"></a>3.13 枚举</h3><p>枚举的功能类似于字面量类型+联合类型组合的功能，也可以表示一组明确的可选值。<br>枚举：定义一组命名常量。它描述一个值，该值可以是这些命名常量中的一个。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 enum 关键字定义枚举</span></span><br><span class="line"><span class="comment">// 约定枚举名称、枚举中的值以大写字母开头</span></span><br><span class="line"><span class="comment">// 枚举中的多个值之间通过 ,（逗号）分隔</span></span><br><span class="line"><span class="comment">// 定义好枚举后，直接使用枚举名称作为类型注解</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">    <span class="title class_">Up</span>,</span><br><span class="line">    <span class="title class_">Down</span>,</span><br><span class="line">    <span class="title class_">Left</span>,</span><br><span class="line">    <span class="title class_">Right</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">changeDirection</span>(<span class="params">direction: Direction</span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(direction)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：形参 direction 的类型为枚举 Direction，那么，实参的值就应该是枚举 Direction 成员的任意一个。<br>访问枚举成员：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">changeDirection</span>(<span class="params">direction: Direction</span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(direction)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 类似于 JS 中的对象，直接通过点（.）语法访问枚举的成员</span></span><br><span class="line"><span class="title function_">changeDirection</span>(<span class="title class_">Direction</span>.<span class="property">Up</span>)</span><br></pre></td></tr></table></figure>

<p>问题：我们把枚举成员作为了函数的实参，它的值是什么？<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/760851/1684217666549-1edcb26b-a4b4-4981-9a89-fba57e063061.png#averageHue=%23fcfbfa&clientId=u150173ce-c6a1-4&from=paste&height=98&id=ud51fb4a7&originHeight=147&originWidth=574&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=10965&status=done&style=none&taskId=u5daf275e-6289-4811-beb5-5f3d19f8d0a&title=&width=382.6666666666667" alt="image.png"><br>通过将鼠标移入 Direction.Up，可以看到枚举成员 Up的值为 0<br>枚举成员是有值的，默认为：从 0 开始自增的数值<br>枚举成员的值为数字的枚举，称为：<strong>数字枚举</strong><br>也可以给枚举中的成员初始化值，例如</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Down -&gt; 11、 Left -&gt; 12、 Right -&gt; 13</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">    <span class="title class_">Up</span> = <span class="number">10</span>,</span><br><span class="line">    <span class="title class_">Down</span>,</span><br><span class="line">    <span class="title class_">Left</span>,</span><br><span class="line">    <span class="title class_">Right</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">    <span class="title class_">Up</span> = <span class="number">10</span>,</span><br><span class="line">    <span class="title class_">Down</span> = <span class="number">20</span>,</span><br><span class="line">    <span class="title class_">Left</span> = <span class="number">30</span>,</span><br><span class="line">    <span class="title class_">Right</span> = <span class="number">40</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>字符串枚举</strong>：枚举成员的值是字符串</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">    <span class="title class_">Up</span> = <span class="string">&#x27;Up&#x27;</span>,</span><br><span class="line">    <span class="title class_">Down</span> = <span class="string">&#x27;Down&#x27;</span>,</span><br><span class="line">    <span class="title class_">Left</span> = <span class="string">&#x27;Left&#x27;</span>,</span><br><span class="line">    <span class="title class_">Right</span> = <span class="string">&#x27;Right&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>字符串枚举没有自增长行为，因此，字符串枚举的每个成员必须有初始值</p>
</blockquote>
<p>枚举是TS为数不多的非 JavaScript 类型级扩展（不仅仅是类型）的特性之一<br>因为：其他类型仅仅被当做类型，而枚举不仅用作类型，还提供值（枚举成员都是有值的）<br>也就是说，其他的类型会在编译为 JS 代码时自动移除。但是，枚举类型会被编译为 JS 代码！</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译前TS代码</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">    <span class="title class_">Up</span> = <span class="string">&#x27;Up&#x27;</span>,</span><br><span class="line">    <span class="title class_">Down</span> = <span class="string">&#x27;Down&#x27;</span>,</span><br><span class="line">    <span class="title class_">Left</span> = <span class="string">&#x27;Left&#x27;</span>,</span><br><span class="line">    <span class="title class_">Right</span> = <span class="string">&#x27;Right&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译后JS代码</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Direction</span>;</span><br><span class="line">(<span class="keyword">function</span> (<span class="params">Direction</span>) &#123;</span><br><span class="line">    <span class="title class_">Direction</span>[<span class="string">&quot;Up&quot;</span>] = <span class="string">&quot;Up&quot;</span>;</span><br><span class="line">    <span class="title class_">Direction</span>[<span class="string">&quot;Down&quot;</span>] = <span class="string">&quot;Down&quot;</span>;</span><br><span class="line">    <span class="title class_">Direction</span>[<span class="string">&quot;Left&quot;</span>] = <span class="string">&quot;Left&quot;</span>;</span><br><span class="line">    <span class="title class_">Direction</span>[<span class="string">&quot;Right&quot;</span>] = <span class="string">&quot;Right&quot;</span>;</span><br><span class="line">&#125;)(<span class="title class_">Direction</span> || (<span class="title class_">Direction</span> = &#123;&#125;));</span><br></pre></td></tr></table></figure>
<p>枚举与前面讲到的字面量类型+联合类型组合的功能类似，都用来表示一组明确的可选值列表<br>一般情况下，推荐使用字面量类型+联合类型组合的方式，因为相比枚举，这种方式更加直观、简洁、高效</p>
<h3 id="3-14-any-类型"><a href="#3-14-any-类型" class="headerlink" title="3.14 any 类型"></a>3.14 any 类型</h3><p>原则：不推荐使用 any ! 这会让 TypeScript 变为 “AnyScript” (失去TS类型保护的优势)。<br>因为当值的类型为 any 时，可以对该值进行任意操作，并且不会有代码提示。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">obj</span>: <span class="built_in">any</span> = &#123; <span class="attr">x</span>: <span class="number">0</span> &#125;</span><br><span class="line">obj.<span class="property">bar</span> = <span class="number">100</span></span><br><span class="line"><span class="title function_">obj</span>()</span><br><span class="line"><span class="keyword">const</span> <span class="attr">n</span>: <span class="built_in">number</span> = obj</span><br></pre></td></tr></table></figure>
<p>解释：以上操作都不会有任何类型错误提示，即使可能存在错误！	<br>尽可能的避免使用 any 类型，除非临时使用 any 来“”避免”书写很长、很复杂的类型！<br>其他隐式具有 any 类型的情况：</p>
<ol>
<li>声明变量不提供类型也不提供默认值</li>
<li>函数参数不加类型</li>
</ol>
<p>注意：因为不推荐使用ay,所以，这两种情况下都应该提供类型！</p>
<h3 id="3-15-typeof"><a href="#3-15-typeof" class="headerlink" title="3.15 typeof"></a>3.15 typeof</h3><p>众所周知，JS中提供了typeof操作符，用来在S中获取数据的类型。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="string">&#x27;hello world&#x27;</span>) <span class="comment">// 打印 string</span></span><br></pre></td></tr></table></figure>
<p>实际上，TS也提供了typeof操作符：可以在类型上下文中引用变量或属性的类型（类型查询）。<br>使用场景：根据已有变量的值，获取该值的类型，来简化类型书写。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">formatPoint</span>(<span class="params">point: &#123; x: <span class="built_in">number</span>; y: <span class="built_in">number</span> &#125;</span>) &#123;&#125;</span><br><span class="line"><span class="title function_">formatPoint</span>(p)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">formatPoint</span>(<span class="params">point: <span class="keyword">typeof</span> p</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>解释：</p>
<ol>
<li>使用 typeof 操作符来获取变量 p 的类型，结果与第一种（对象字面量形式的类型）相同。</li>
<li>typeof 出现在类型注解的位置（参数名称的冒号后面）所处的环境就在类型上下文（区别于 JS 代码)。</li>
<li>注意：typeof 只能用来查询变量或属性的类型，无法查询其他形式的类型（比如，函数调用的类型)</li>
</ol>
<h2 id="四、TypeScript高级类型"><a href="#四、TypeScript高级类型" class="headerlink" title="四、TypeScript高级类型"></a>四、TypeScript高级类型</h2><p><strong>概述</strong><br>TS中的高级类型有很多，重点学习以下高级类型：</p>
<ol>
<li>class类</li>
<li>类型兼容性</li>
<li>交叉类型</li>
<li>泛型和keyof</li>
<li>索引签名类型和索引查询类型</li>
<li>映射类型</li>
</ol>
<h3 id="4-1-class-类"><a href="#4-1-class-类" class="headerlink" title="4.1 class 类"></a>4.1 class 类</h3><p>TypeScript全面支持ES2015中引入的class关键字，并为其添加了类型注解和其他语法（比如，可见性修饰符等)<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/760851/1684217802850-36cf0124-c32a-4f03-ad52-9243d617b742.png#averageHue=%23fcfcfc&clientId=u150173ce-c6a1-4&from=paste&height=77&id=uac143007&originHeight=115&originWidth=356&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=4843&status=done&style=none&taskId=u412a6161-0106-4934-b40a-c21757efa46&title=&width=237.33333333333334" alt="image.png"><br>解释：<br>1.根据TS中的类型推论，可以知道Person类的实例对象p的类型是Person.。<br>2.TS中的class,不仅提供了class的语法功能，也作为一种类型存在。<br><strong>实例属性初始化：</strong></p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">    gender = <span class="string">&#x27;男&#x27;</span> <span class="comment">// gender: string = &#x27;男&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解释：</p>
<ol>
<li>声明成员age,类型为number(没有初始值)。</li>
<li>声明成员gender,并设置初始值，此时，可省略类型注解(TS类型推论为string类型)</li>
</ol>
<p><strong>构造函数：</strong></p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">    <span class="attr">gender</span>: <span class="built_in">string</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">age: <span class="built_in">number</span>, gender: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">gender</span> = gender</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解释：</p>
<ol>
<li>成员初始化（比如，age:number)后，才可以通过this.age来访问实例成员。</li>
<li>需要为构造函数指定类型注解，否则会被隐式推断为ay;构造函数不需要返回值类型。</li>
</ol>
<p><strong>实例方法：</strong></p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    x = <span class="number">10</span></span><br><span class="line">    y = <span class="number">10</span></span><br><span class="line">    </span><br><span class="line">    <span class="title function_">scale</span>(<span class="attr">n</span>: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">x</span> *= n</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">y</span> *= n</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解释</strong>：方法的类型注解（参数和返回值）与函数用法相同<br><strong>类继承</strong><br>类的继承有两种方式：extends(继承父类)和implements(实现接口)。<br>JS 中只有 <code>extends</code>，而 <code>implements</code> 是 TS 提供的。<br><strong>extends</strong></p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// extends 继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="title function_">move</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Move&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 extends 关键字实现继承</span></span><br><span class="line"><span class="comment">// 子类 Dog 继承父类 Animal，则 Dog 的实例对象 dog 就同时具有了父类 Animal 和 子类 Dog 的</span></span><br><span class="line">所有属性和方法。</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">    <span class="title function_">back</span>(<span class="params"></span>) &#123;</span><br><span class="line">    	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;旺旺旺&#x27;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> dog = <span class="keyword">new</span> <span class="title class_">Dog</span>()</span><br></pre></td></tr></table></figure>
<p><strong>implements</strong></p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Singable</span> &#123;</span><br><span class="line">	<span class="title function_">sing</span>(): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过 implements 关键字让 class 实现接口</span></span><br><span class="line"><span class="comment">// Person 类实现接口 Singable 意味着，Person 类中必须提供 Singable 接口中指定的所有方法和属性。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Singable</span> &#123;</span><br><span class="line">    <span class="title function_">sing</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;缓缓飘落的枫叶像思念&#x27;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>访问修饰符</strong><br>类成员可见性：可以使用 TS 来<strong>控制 class 的方法或属性对于 class 外的代码是否可见。</strong><br>可见性修饰符包括：</p>
<ol>
<li>public(公有的)</li>
<li>protected(受保护的)</li>
<li>private(私有的)</li>
</ol>
<p><strong>public</strong>：表示公有的、<strong>公开的，公有成员可以被任何地方访问</strong>，默认可见性</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="comment">// 在类属性或方法前面添加 public 关键字，来修饰该属性或方法是共有的</span></span><br><span class="line"><span class="comment">// 因为 public 是默认可见性，所以，可以直接省略</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">move</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Moving along!&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>protected</strong>：表示受保护的，仅对其声明所在类和子类中（非实例对象）可见</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>：表示私有的，只在当前类中可见，对实例对象以及子类也是不可见的<span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">move</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Moving along!&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在类属性或方法前面添加 protected 关键字，来修饰该属性或方法是受保护的</span></span><br><span class="line"><span class="comment">// 在子类的方法内部可以通过 this 来访问父类中受保护的成员，但是，对实例不可见！</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line"><span class="title function_">bark</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;叫~~~&#x27;</span>)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">move</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>private</strong>：表示私有的，只在当前类中可见，对实例对象以及子类也是不可见的</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">move</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Moving along!&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">walk</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">move</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在类属性或方法前面添加 private 关键字，来修饰该属性或方法是私有的</span></span><br><span class="line"><span class="comment">// 私有的属性或方法只在当前类中可见，对子类和实例对象也都是不可见的！</span></span><br></pre></td></tr></table></figure>
<p>除了可见性修饰符之外，还有一个常见修饰符就是：readonly (只读修饰符)<br>readonly：表示只读，用来防止在构造函数之外对属性进行赋值。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">age</span>: <span class="built_in">number</span> = <span class="number">18</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用 readonly 关键字修饰该属性是只读的，注意只能修饰属性不能修饰方法</span></span><br><span class="line"><span class="comment">// 注意：属性 age 后面的类型注解（比如，此处的 number）如果不加，则 age 的类型为 18 （字面量</span></span><br><span class="line">类型）</span><br><span class="line"><span class="comment">// 接口或者 &#123;&#125; 表示的对象类型，也可以使用 readonly</span></span><br></pre></td></tr></table></figure>
<h3 id="4-2-类型兼容性"><a href="#4-2-类型兼容性" class="headerlink" title="4.2 类型兼容性"></a>4.2 类型兼容性</h3><p>两种类型系统：</p>
<ol>
<li>Structural Type System (结构化类型系统)</li>
<li>Nominal Type System (标明类型系统)</li>
</ol>
<p>TS采用的是结构化类型系统，也叫做 duck typing (鸭子类型)，类型检查关注的是值所具有的形状<br>也就是说，在结构类型系统中，如果两个对象具有相同的形状，则认为它们属于同一类型</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">number</span></span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point2D</span> &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">number</span></span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">p</span>: <span class="title class_">Point</span> = <span class="keyword">new</span> <span class="title class_">Point2D</span>()</span><br><span class="line"><span class="comment">// Point 和 Point2D 是两个名称不同的类</span></span><br><span class="line"><span class="comment">// 变量 p 的类型被显示标注为 Point 类型，但是，它的值却是 Point2D 的实例，并且没有类型错误</span></span><br><span class="line"><span class="comment">// 因为 TS 是结构化类型系统，只检查 Point 和 Point2D 的结构是否相同（相同，都具有 x 和 y 两个属性，属性类型也相同）</span></span><br><span class="line"><span class="comment">// 但是，如果在 Nominal Type System 中（比如，C#、Java 等），它们是不同的类，类型无法兼容</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：在结构化类型系统中，如果两个对象具有相同的形状，则认为它们属于同一类型，这种说法并不准确</p>
</blockquote>
<p>更准确的说法：对于对象类型来说，y 的成员至少与 x 相同，则 x 兼容 y（成员多的可以赋值给少的）</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">number</span></span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point3D</span> &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">number</span></span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">number</span></span><br><span class="line">    <span class="attr">Z</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">p</span>: <span class="title class_">Point</span> = <span class="keyword">new</span> <span class="title class_">Point3D</span>()</span><br><span class="line"><span class="comment">// Point3D 的成员至少与 Point 相同，则 Point 兼容 Point3D</span></span><br><span class="line"><span class="comment">// 所以，成员多的 Point3D 可以赋值给成员少的 Point</span></span><br></pre></td></tr></table></figure>
<p>除了 class 之外，TS 中的其他类型也存在相互兼容的情况，包括： <strong>接口兼容性</strong> 、 <strong>函数兼容性</strong> 等接口兼容性<br><strong>接口之间的兼容性，类似于 class</strong> 。并且，class 和 interface 之间也可以兼容。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="attr">X</span>: <span class="built_in">number</span></span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Point2D</span> &#123;</span><br><span class="line">    <span class="attr">X</span>: <span class="built_in">number</span></span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">p1</span>: <span class="title class_">Point</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">p2</span>: <span class="title class_">Point2D</span> = p1</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Point3D</span> &#123;</span><br><span class="line">    <span class="attr">X</span>: <span class="built_in">number</span></span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">number</span></span><br><span class="line">    <span class="attr">z</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">p3</span>: <span class="title class_">Point3D</span></span><br><span class="line">p2 = p3</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point3D</span> &#123;</span><br><span class="line">    <span class="attr">X</span>: <span class="built_in">number</span></span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">number</span></span><br><span class="line">    <span class="attr">Z</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">p3</span>: <span class="title class_">Point2D</span> = <span class="keyword">new</span> <span class="title class_">Point3D</span>()</span><br></pre></td></tr></table></figure>

<p><strong>函数之间兼容性比较复杂</strong>，需要考虑：1、参数个数2、参数类型3、返回值类型<br><strong>参数个数</strong>，参数多的兼容参数少的（或者说，<strong>参数少的可以赋值给多的</strong>）</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="variable constant_">F1</span> = <span class="function">(<span class="params">a: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">void</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">F2</span> = <span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">void</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">f1</span>: <span class="variable constant_">F1</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">f2</span>: <span class="variable constant_">F2</span> = f1</span><br></pre></td></tr></table></figure>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">arr.<span class="title function_">forEach</span>(<span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line">arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参数少的可以赋值给参数多的，所以，f1 可以赋值给 f2<br>数组forEach方法的第一个参数是回调函数，该示例中类型为：(value: string, index: number, array: string [] ) &#x3D;&gt; void<br>在 JS 中省略用不到的函数参数实际上是很常见的，这样的使用方式，促成了TS中函数类型之间的兼容性<br>并目因为回调函数是有类型的，所以，TS会自动推导出参数item、index、array的类型</p>
</blockquote>
<p><strong>参数类型</strong>，相同位置的参数类型要相同（原始类型）或兼容（对象类型）</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="variable constant_">F1</span> = <span class="function">(<span class="params">a: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">string</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">F2</span> = <span class="function">(<span class="params">a: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">string</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">f1</span>: <span class="variable constant_">F1</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">f2</span>: <span class="variable constant_">F2</span> = f1</span><br></pre></td></tr></table></figure>
<p>解释：函数类型 F2 兼容函数类型 F1，因为 F1 和 F2 的第一个参数类型相同。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Point2D</span> &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">number</span></span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Point3D</span> &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">number</span></span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">number</span></span><br><span class="line">    <span class="attr">Z</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">F2</span> = <span class="function">(<span class="params">p: Point2D</span>) =&gt;</span> <span class="built_in">void</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">F3</span> = <span class="function">(<span class="params">p: Point3D</span>) =&gt;</span> <span class="built_in">void</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">f2</span>: <span class="variable constant_">F2</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">f3</span>: <span class="variable constant_">F3</span> = f2</span><br><span class="line">f2 = f3</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，此处与前面讲到的接口兼容性冲突<br>技巧：将对象拆开，把每个属性看做一个个参数，则，参数少的（f2）可以赋值给参数多的（f3）</p>
</blockquote>
<p><strong>返回值类型</strong> ，只关注返回值类型本身即可</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="variable constant_">F5</span> = <span class="function">() =&gt;</span> <span class="built_in">string</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">F6</span> = <span class="function">() =&gt;</span> <span class="built_in">string</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">f5</span>: <span class="variable constant_">F5</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">f6</span>: <span class="variable constant_">F6</span> = f5</span><br></pre></td></tr></table></figure>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="variable constant_">F7</span> = <span class="function">() =&gt;</span> &#123; <span class="attr">name</span>: <span class="built_in">string</span> &#125;</span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">F8</span> = <span class="function">() =&gt;</span> &#123; <span class="attr">name</span>: <span class="built_in">string</span>; <span class="attr">age</span>: <span class="built_in">number</span> &#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">f7</span>: <span class="variable constant_">F7</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">f8</span>: <span class="variable constant_">F8</span></span><br><span class="line">f7 = f8</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果返回值类型是原始类型，此时两个类型要相同，比如，左侧类型 F5 和 F6<br>如果返回值类型是对象类型，此时成员多的可以赋值给成员少的，比如，右侧类型 F7 和 F8</p>
</blockquote>
<h3 id="4-3-交叉类型"><a href="#4-3-交叉类型" class="headerlink" title="4.3 交叉类型"></a>4.3 交叉类型</h3><p>交叉类型（&amp;）：功能类似于接口继承（extends），用于组合多个类型为一个类型（常用于对象类型）。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">	<span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Contact</span> &#123;</span><br><span class="line">	<span class="attr">phone</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PersonDetail</span> = <span class="title class_">Person</span> &amp; <span class="title class_">Contact</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">obj</span>: <span class="title class_">PersonDetail</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;jack&#x27;</span>,</span><br><span class="line">    <span class="attr">phone</span>: <span class="string">&#x27;150......&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用交叉类型后，新的类型 PersonDetail 就同时具备了 Person 和 Contact 的所有属性类型</p>
</blockquote>
<p><strong>相当于</strong></p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">PersonDetail</span> = &#123; <span class="attr">name</span>: <span class="built_in">string</span>; <span class="attr">phone</span>: <span class="built_in">string</span> &#125;</span><br></pre></td></tr></table></figure>
<p>交叉类型（&amp;）和接口继承（extends）的对比<br>相同点：都可以实现对象类型的组合<br>不同点：两种方式实现类型组合时，对于同名属性之间，处理类型冲突的方式不同</p>
<h3 id="4-4-泛型"><a href="#4-4-泛型" class="headerlink" title="4.4 泛型"></a>4.4 泛型</h3><p>泛型是可以在保证类型安全前提下，让函数等与多种类型一起工作，从而实现复用，常用于：函数、接<br>口、class 中。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">id</span>(<span class="params">value: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需求：创建一个 id 函数，传入什么数据就返回该数据本身（也就是说，参数和返回值类型相同）。<br>比如，id(10) 调用以上函数就会直接返回 10 本身。但是，该函数只接收数值类型，无法用于其他类型。<br>为了能让函数能够接受任意类型，可以将参数类型修改为 any。但是，这样就失去了 TS 的类型保护，类<br>型不安全。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">id</span>(<span class="params">value: <span class="built_in">any</span></span>): <span class="built_in">any</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>泛型在保证类型安全（不丢失类型信息）的同时，可以让函数等与多种不同的类型一起工作，灵活可复<br>用。<br>实际上，在 C＃和 Java 等编程语言中，泛型都是用来实现可复用组件功能的主要工具之一。</p>
<p><strong>创建泛型函数</strong></p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> id&lt;<span class="title class_">Type</span>&gt;(<span class="attr">value</span>: <span class="title class_">Type</span>): <span class="title class_">Type</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在函数名称的后面添加 &lt;&gt;（尖括号），尖括号中添加类型变量，比如此处的 Type</span></span><br><span class="line"><span class="comment">// 类型变量 Type，是一种特殊类型的变量，它处理类型而不是值</span></span><br><span class="line"><span class="comment">// 该类型变量相当于一个类型容器，能够捕获用户提供的类型（具体是什么类型由用户调用该函数时指定）</span></span><br><span class="line"><span class="comment">// 因为 Type 是类型，因此可以将其作为函数参数和返回值的类型，表示参数和返回值具有相同的类型</span></span><br><span class="line"><span class="comment">// 类型变量 Type，可以是任意合法的变量名称</span></span><br></pre></td></tr></table></figure>

<p><strong>调用泛型函数</strong></p>
<p>同样，如果传入类型 string，函数 id 参数和返回值的类型就都是 string。<br>这样，通过泛型就做到了让 id 函数与多种不同的类型一起工作，实现了复用的同时保证了类型安全。</p>
<p><strong>简化调用泛型函数</strong></p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="title function_">id</span>(<span class="string">&#x27;200&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> str = <span class="title function_">id</span>(<span class="number">10</span>)</span><br><span class="line"><span class="comment">// 在调用泛型函数时，可以省略 &lt;类型&gt; 来简化泛型函数的调用</span></span><br><span class="line"><span class="comment">// 此时，TS 内部会采用一种叫做类型参数推断的机制，来根据传入的实参自动推断出类型变量 Type 的类型</span></span><br><span class="line"><span class="comment">// 比如，传入实参 10，TS 会自动推断出变量 num 的类型 number，并作为 Type 的类型</span></span><br></pre></td></tr></table></figure>

<p>推荐：使用这种简化的方式调用泛型函数，使代码更短，更易于阅读。</p>
<p>说明：当编译器无法推断类型或者推断的类型不准确时，就需要显式地传入类型参数。</p>
<p>泛型约束 ：默认情况下，泛型函数的类型变量 Type 可以代表多个类型，这导致无法访问任何属性。<br>比如，id(‘a’) 调用函数时获取参数的长度：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> id&lt;<span class="title class_">Type</span>&gt;(<span class="attr">value</span>: <span class="title class_">Type</span>): <span class="title class_">Type</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value.<span class="property">length</span>)</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Type 可以代表任意类型，无法保证一定存在 length 属性，比如 number 类型就没有 length。</span></span><br><span class="line"><span class="comment">// 需要为泛型添加约束来收缩类型（缩窄类型取值范围）</span></span><br></pre></td></tr></table></figure>

<p>添加泛型约束收缩类型，主要有以下两种方式：</p>
<ol>
<li><p>指定更加具体的类型</p>
</li>
<li><p>添加约束</p>
</li>
</ol>
<p><strong>指定更加具体的类型</strong></p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> id&lt;<span class="title class_">Type</span>&gt;(<span class="attr">value</span>: <span class="title class_">Type</span>[]): <span class="title class_">Type</span>[] &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value.<span class="property">length</span>)</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将类型修改为 Type[]（Type 类型的数组），因为只要是数组就一定存在 length 属性，因此就可以访问了</span></span><br></pre></td></tr></table></figure>

<p><strong>添加约束</strong></p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Ilength</span> &#123;</span><br><span class="line">    <span class="attr">length</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> id&lt;<span class="title class_">Type</span> <span class="keyword">extends</span> <span class="title class_">Ilength</span>&gt;(<span class="attr">value</span>: <span class="title class_">Type</span>): <span class="title class_">Type</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value.<span class="property">length</span>)</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建描述约束的接口 ILength，该接口要求提供 length 属性</span></span><br><span class="line"><span class="comment">// 通过 extends 关键字使用该接口，为泛型（类型变量）添加约束</span></span><br><span class="line"><span class="comment">// 该约束表示：传入的类型必须具有 length 属性</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>传入的实参（比如，数组）只要有 length 属性即可，这也符合前面讲到的接口的类型兼容性</p>
</blockquote>
<p>泛型的类型变量可以有多个，并且类型变量之间还可以约束（比如，第二个类型变量受第一个类型变量<br>约束）。</p>
<p>比如，创建一个函数来获取对象中属性的值</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> getProp&lt;<span class="title class_">Type</span>, <span class="title class_">Key</span> <span class="keyword">extends</span> keyof <span class="title class_">Type</span>&gt;(<span class="attr">obj</span>: <span class="title class_">Type</span>, <span class="attr">key</span>: <span class="title class_">Key</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> obj[key]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;jack&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;</span><br><span class="line"><span class="title function_">getProp</span>(person, <span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"><span class="comment">// 添加了第二个类型变量 Key，两个类型变量之间使用（,）逗号分隔</span></span><br><span class="line"><span class="comment">// keyof 关键字接收一个对象类型，生成其键名称（可能是字符串或数字）的联合类型</span></span><br><span class="line"><span class="comment">// 本示例中 keyof Type 实际上获取的是 person 对象所有键的联合类型，也就是：&#x27;name&#x27; | &#x27;age&#x27;</span></span><br><span class="line"><span class="comment">// 类型变量 Key 受 Type 约束，可以理解为：Key 只能是 Type 所有键中的任意一个，或者说只能访问</span></span><br><span class="line"><span class="comment">// 对象中存在的属性</span></span><br></pre></td></tr></table></figure>

<p><strong>泛型接口</strong>：接口也可以配合泛型来使用，以增加其灵活性，增强其复用性</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IdFunc</span>&lt;<span class="title class_">Type</span>&gt; &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="function">(<span class="params">value: Type</span>) =&gt;</span> <span class="title class_">Type</span></span><br><span class="line">    <span class="attr">ids</span>: <span class="function">() =&gt;</span> <span class="title class_">Type</span>[]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">obj</span>: <span class="title class_">IdFunc</span>&lt;<span class="built_in">number</span>&gt; = &#123;</span><br><span class="line">    <span class="title function_">id</span>(<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">ids</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在接口名称的后面添加 &lt;类型变量&gt;，那么，这个接口就变成了泛型接口</span></span><br><span class="line"><span class="comment">// 接口的类型变量，对接口中所有其他成员可见，也就是接口中所有成员都可以使用类型变量</span></span><br><span class="line"><span class="comment">// 使用泛型接口时，需要显式指定具体的类型（比如，此处的 IdFunc&lt;nunber&gt;）</span></span><br><span class="line"><span class="comment">// 此时，id 方法的参数和返回值类型都是 number；ids 方法的返回值类型是 number[]</span></span><br></pre></td></tr></table></figure>

<p>实际上，JS 中的数组在 TS 中就是一个泛型接口</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\18389\AppData\Roaming\Typora\typora-user-images\image-20230517142632837.png" alt="image-20230517142632837"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\18389\AppData\Roaming\Typora\typora-user-images\image-20230517142637698.png" alt="image-20230517142637698"></p>
<p>当我们在使用数组时，TS 会根据数组的不同类型，来自动将类型变量设置为相应的类型<br>可以通过 Ctrl + 鼠标左键（Mac：option + 鼠标左键）来查看具体的类型信息</p>
<p>泛型类：class 也可以配合泛型来使用。<br>泛型类与泛型接口类似。 泛型类使用（ &lt;&gt; ）括起泛型类型，跟在类名后面</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GenericNumber</span>&lt;<span class="title class_">Type</span>&gt; &#123;</span><br><span class="line">    <span class="attr">zeroValue</span>: <span class="title class_">Type</span></span><br><span class="line">    <span class="attr">add</span>: <span class="function">(<span class="params">x: Type, y: Type</span>) =&gt;</span> <span class="title class_">Type</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 此处的 add 方法，采用的是箭头函数形式的类型书写方式</span></span><br><span class="line"><span class="keyword">let</span> myGenericNumber = <span class="keyword">new</span> <span class="title class_">GenericNumber</span>&lt;<span class="built_in">number</span>&gt;()</span><br><span class="line">myGenericNumber.<span class="property">zeroValue</span> = <span class="number">0</span></span><br><span class="line">myGenericNumber.<span class="property">add</span> = <span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> stringNumeric = <span class="keyword">new</span> <span class="title class_">GenericNumber</span>&lt;<span class="built_in">string</span>&gt;()</span><br><span class="line">stringNumeric.<span class="property">zeroValue</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line">stringNumeric.<span class="property">add</span> = <span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringNumeric.<span class="title function_">add</span>(stringNumeric.<span class="property">zeroValue</span>, <span class="string">&#x27;test&#x27;</span>))</span><br><span class="line"><span class="comment">// GenericNumber可以指定 number 类型也可以使用字符串或其它更复杂的类型</span></span><br></pre></td></tr></table></figure>

<p><strong>泛型工具类型</strong>：TS 内置了一些常用的工具类型，来简化 TS 中的一些常见操作。<br>说明：它们都是基于泛型实现的（泛型适用于多种类型，更加通用），并且是内置的，可以直接在代码<br>中使用。<br>这些工具类型有很多，主要学习以下几个 ：</p>
<ul>
<li><code>Partial&lt;Type&gt;</code></li>
<li><code>Readonly&lt;Type&gt;</code></li>
</ul>
<p><code>Partial&lt;Type&gt;</code></p>
<p><code>Partial&lt;Type&gt;</code>用来构造（创建）一个类型，将 Type 的所有属性设置为可选</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Props</span> &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="built_in">string</span></span><br><span class="line">    <span class="attr">children</span>: <span class="built_in">number</span>[]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PartialProps</span> = <span class="title class_">Partial</span>&lt;<span class="title class_">Props</span>&gt;</span><br><span class="line"><span class="comment">// 构造出来的新类型 PartialProps 结构和 Props 相同，但所有属性都变为可选的</span></span><br></pre></td></tr></table></figure>

<p><code>Partial&lt;Type&gt;</code>用来构造一个类型，将 Type 的所有属性都设置为 readonly（只读）</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Props</span> &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="built_in">string</span></span><br><span class="line">    <span class="attr">children</span>: <span class="built_in">number</span>[]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ReadonlyProps</span> = <span class="title class_">Readonly</span>&lt;<span class="title class_">Props</span>&gt;</span><br><span class="line"><span class="comment">// 构造出来的新类型 ReadonlyProps 结构和 Props 相同，但所有属性都变为只读的</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">props</span>: <span class="title class_">ReadonlyProps</span> = &#123; <span class="attr">id</span>: <span class="string">&#x27;1&#x27;</span>, <span class="attr">children</span>: [] &#125;</span><br><span class="line">props.<span class="property">id</span> = <span class="string">&#x27;2&#x27;</span></span><br><span class="line"><span class="comment">// 当我们想重新给 id 属性赋值时，就会报错：无法分配到 &quot;id&quot; ，因为它是只读属性</span></span><br></pre></td></tr></table></figure>

<p><code>Pick&lt;Type, Keys&gt; </code>从 Type 中选择一组属性来构造新类型</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Props</span> &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="built_in">string</span></span><br><span class="line">    <span class="attr">title</span>: <span class="built_in">string</span></span><br><span class="line">    <span class="attr">children</span>: <span class="built_in">number</span>[]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PickProps</span> = <span class="title class_">Pick</span>&lt;<span class="title class_">Props</span>, <span class="string">&#x27;id&#x27;</span> | <span class="string">&#x27;title&#x27;</span>&gt;</span><br><span class="line"><span class="comment">// Pick 工具类型有两个类型变量：1 表示选择谁的属性 2 表示选择哪几个属性</span></span><br><span class="line"><span class="comment">// 其中第二个类型变量，如果只选择一个则只传入该属性名即可</span></span><br><span class="line"><span class="comment">// 第二个类型变量传入的属性只能是第一个类型变量中存在的属性</span></span><br><span class="line"><span class="comment">// 构造出来的新类型 PickProps，只有 id 和 title 两个属性类型</span></span><br></pre></td></tr></table></figure>

<p><code>Record&lt;Keys,Type&gt;</code> 构造一个对象类型，属性键为 Keys，属性类型为 Type</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">RecordObj</span> = <span class="title class_">Record</span>&lt;<span class="string">&#x27;a&#x27;</span> | <span class="string">&#x27;b&#x27;</span> | <span class="string">&#x27;c&#x27;</span>, <span class="built_in">string</span>[]&gt;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">obj</span>: <span class="title class_">RecordObj</span> = &#123;</span><br><span class="line">    <span class="attr">a</span>: [<span class="string">&#x27;1&#x27;</span>],</span><br><span class="line">    <span class="attr">b</span>: [<span class="string">&#x27;2&#x27;</span>],</span><br><span class="line">    <span class="attr">c</span>: [<span class="string">&#x27;3&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Record 工具类型有两个类型变量：1 表示对象有哪些属性 2 表示对象属性的类型</span></span><br><span class="line"> 构建的新对象类型 <span class="title class_">RecordObj</span> 表示：这个对象有三个属性分别为a/b/c，属性值的类型都是 <span class="built_in">string</span>[]</span><br></pre></td></tr></table></figure>

<h3 id="4-5-索引签名类型"><a href="#4-5-索引签名类型" class="headerlink" title="4.5 索引签名类型"></a>4.5 索引签名类型</h3><p>绝大多数情况下，我们都可以在使用对象前就确定对象的结构，并为对象添加准确的类型。<br>使用场景：<strong>当无法确定对象中有哪些属性</strong>（或者说对象中可以出现任意多个属性），此时，就用到索引<br>签名类型了。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">AnyObject</span> &#123;</span><br><span class="line">    [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">obj</span>: <span class="title class_">AnyObject</span> = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用 [key: string] 来约束该接口中允许出现的属性名称。表示只要是 string 类型的属性名称，都可以出现在对象中。</span></span><br><span class="line"><span class="comment">// 这样，对象 obj 中就可以出现任意多个属性（比如，a、b 等）。</span></span><br><span class="line"><span class="comment">// key 只是一个占位符，可以换成任意合法的变量名称。</span></span><br><span class="line"><span class="comment">// 隐藏的前置知识：JS 中对象（&#123;&#125;）的键是 string 类型的。</span></span><br></pre></td></tr></table></figure>

<p>在 JS 中数组是一类特殊的对象，特殊在数组的键（索引）是数值类型。<br>并且，数组也可以出现任意多个元素。所以，在数组对应的泛型接口中，也用到了索引签名类型。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MyArray</span>&lt;T&gt; &#123;</span><br><span class="line">    [<span class="attr">n</span>: <span class="built_in">number</span>]: T</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>: <span class="title class_">MyArray</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment">// MyArray 接口模拟原生的数组接口，并使用 [n: number] 来作为索引签名类型。</span></span><br><span class="line"><span class="comment">// 该索引签名类型表示：只要是 number 类型的键（索引）都可以出现在数组中，或者说数组中可以有任意多个元素。</span></span><br><span class="line"><span class="comment">// 同时也符合数组索引是 number 类型这一前提。</span></span><br></pre></td></tr></table></figure>

<h3 id="4-6-映射类型"><a href="#4-6-映射类型" class="headerlink" title="4.6 映射类型"></a>4.6 映射类型</h3><p>映射类型：基于旧类型创建新类型（对象类型），减少重复、提升开发效率。<br>比如，类型 PropKeys 有 x&#x2F;y&#x2F;z，另一个类型 Type1 中也有 x&#x2F;y&#x2F;z，并且 Type1 中 x&#x2F;y&#x2F;z 的类型相同：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">PorpKeys</span> = <span class="string">&#x27;x&#x27;</span> | <span class="string">&#x27;y&#x27;</span> | <span class="string">&#x27;x&#x27;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Type1</span> = &#123; <span class="attr">x</span>: <span class="built_in">number</span>; <span class="attr">y</span>: <span class="built_in">number</span>; <span class="attr">z</span>: <span class="built_in">number</span> &#125;</span><br></pre></td></tr></table></figure>

<p>这样书写没错，但 x&#x2F;y&#x2F;z 重复书写了两次。像这种情况，就可以使用映射类型来进行简化。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">PropKeys</span> = <span class="string">&#x27;x&#x27;</span> | <span class="string">&#x27;y&#x27;</span> | <span class="string">&#x27;z&#x27;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Type2</span> = &#123; [key <span class="keyword">in</span> <span class="title class_">PropKeys</span>]: <span class="built_in">number</span> &#125;</span><br><span class="line"><span class="comment">// 映射类型是基于索引签名类型的，所以，该语法类似于索引签名类型，也使用了 []。</span></span><br><span class="line"><span class="comment">// Key in PropKeys 表示 Key 可以是 PropKeys 联合类型中的任意一个，类似于 forin(let k in obj)。</span></span><br><span class="line"><span class="comment">// 使用映射类型创建的新对象类型 Type2 和类型 Type1 结构完全相同。</span></span><br><span class="line"><span class="comment">// 注意：映射类型只能在类型别名中使用，不能在接口中使用。</span></span><br></pre></td></tr></table></figure>

<p>映射类型除了根据联合类型创建新类型外，还可以根据对象类型来创建：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Props</span> = &#123; <span class="attr">a</span>: <span class="built_in">number</span>; <span class="attr">b</span>: <span class="built_in">string</span>; <span class="attr">c</span>: <span class="built_in">boolean</span> &#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Type3</span> = &#123; [key <span class="keyword">in</span> keyof <span class="title class_">Props</span>]: <span class="built_in">number</span> &#125;</span><br><span class="line"><span class="comment">// 首先，先执行 keyof Props 获取到对象类型 Props 中所有键的联合类型即，&#x27;a&#x27; | &#x27;b&#x27; | &#x27;c&#x27;</span></span><br><span class="line"><span class="comment">// 然后，Key in ... 就表示 Key 可以是 Props 中所有的键名称中的任意一个。</span></span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\18389\AppData\Roaming\Typora\typora-user-images\image-20230517143450179.png" alt="image-20230517143450179"></p>
<p>实际上，前面讲到的泛型工具类型（比如， Partial<Type> ）都是基于映射类型实现的。</p>
<p>比如， <code>Partial&lt;Type&gt;</code> 的实现：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Partial</span>&lt;T&gt; = &#123;</span><br><span class="line">    [P <span class="keyword">in</span> keyof T]?: T[P]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Props</span> = &#123; <span class="attr">a</span>: <span class="built_in">number</span>; <span class="attr">b</span>: <span class="built_in">string</span>; <span class="attr">c</span>: <span class="built_in">boolean</span> &#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PartialProps</span> = <span class="title class_">Partial</span>&lt;<span class="title class_">Props</span>&gt;</span><br><span class="line"><span class="comment">// keyof T 即 keyof Props 表示获取 Props 的所有键，也就是：&#x27;a&#x27; | &#x27;b&#x27; | &#x27;c&#x27;。</span></span><br><span class="line"><span class="comment">// 在 [] 后面添加 ?（问号），表示将这些属性变为可选的，以此来实现 Partial 的功能。</span></span><br><span class="line"><span class="comment">// 冒号后面的 T[P] 表示获取 T 中每个键对应的类型。比如，如果是 &#x27;a&#x27; 则类型是 number；如果是&#x27;b&#x27; 则类型是 string。</span></span><br><span class="line"><span class="comment">// 最终，新类型 PartialProps 和旧类型 Props 结构完全相同，只是让所有类型都变为可选了。</span></span><br></pre></td></tr></table></figure>

<p>刚刚用到的 T[P] 语法，在 TS 中叫做索引查询（访问）类型。<br>作用：用来查询属性的类型。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Props</span> = &#123; <span class="attr">a</span>: <span class="built_in">number</span>; <span class="attr">b</span>: <span class="built_in">string</span>; <span class="attr">c</span>: <span class="built_in">boolean</span> &#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TypeA</span> = <span class="title class_">Props</span>[<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line"><span class="comment">// Props[&#x27;a&#x27;] 表示查询类型 Props 中属性 &#x27;a&#x27; 对应的类型 number。所以，TypeA 的类型为 number。</span></span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\18389\AppData\Roaming\Typora\typora-user-images\image-20230517143649669.png" alt="image-20230517143649669"></p>
<p>索引查询类型的其他使用方式：同时查询多个索引的类型</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Props</span> = &#123; <span class="attr">a</span>: <span class="built_in">number</span>; <span class="attr">b</span>: <span class="built_in">string</span>; <span class="attr">c</span>: <span class="built_in">boolean</span> &#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TypeA</span> = <span class="title class_">Props</span>[<span class="string">&#x27;a&#x27;</span> | <span class="string">&#x27;b&#x27;</span>] <span class="comment">// string | number</span></span><br><span class="line"><span class="comment">// 使用字符串字面量的联合类型，获取属性 a 和 b 对应的类型，结果为： string | number。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Props</span> = &#123; <span class="attr">a</span>: <span class="built_in">number</span>; <span class="attr">b</span>: <span class="built_in">string</span>; <span class="attr">c</span>: <span class="built_in">boolean</span> &#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TypeA</span> = <span class="title class_">Props</span>[keyof <span class="title class_">Props</span>]</span><br><span class="line"><span class="comment">// 使用 keyof 操作符获取 Props 中所有键对应的类型，结果为： string | number | boolean。</span></span><br></pre></td></tr></table></figure>

<h2 id="五、TypeScript-类型声明文件"><a href="#五、TypeScript-类型声明文件" class="headerlink" title="五、TypeScript 类型声明文件"></a>五、TypeScript 类型声明文件</h2><p>概述<br>今天几乎所有的 JavaScript 应用都会引入许多第三方库来完成任务需求。<br>这些第三方库不管是否是用 TS 编写的，最终都要编译成 JS 代码，才能发布给开发者使用。<br>我们知道是 TS 提供了类型，才有了代码提示和类型保护等机制。<br>但在项目开发中使用第三方库时，你会发现它们几乎都有相应的 TS 类型，这些类型是怎么来的呢？<strong>类</strong><br><strong>型声明文件</strong><br><strong>类型声明文件：用来为已存在的 JS 库提供类型信息。</strong><br>这样在 TS 项目中使用这些库时，就像用 TS 一样，都会有代码提示、类型保护等机制了。</p>
<h3 id="5-1-TS-中的两种文件类型"><a href="#5-1-TS-中的两种文件类型" class="headerlink" title="5.1 TS 中的两种文件类型"></a>5.1 TS 中的两种文件类型</h3><p>TS 中有两种文件类型：</p>
<ol>
<li>ts 文件<ul>
<li>既包含类型信息又可执行代码</li>
<li>可以被编译为 .js 文件，然后，执行代码</li>
<li>用途：编写程序代码的地方</li>
</ul>
</li>
<li>.d.ts文件<ul>
<li>只包含类型信息的类型声明文件</li>
<li>不会生成 .js 文件，仅用于提供类型信息</li>
<li>用途：为 JS 提供类型信息</li>
</ul>
</li>
</ol>
<blockquote>
<p>.ts 是 implementation（代码实现文件）；.d.ts 是 declaration（类型声明文件）。</p>
</blockquote>
<h3 id="5-2-类型声明文件的使用说明"><a href="#5-2-类型声明文件的使用说明" class="headerlink" title="5.2 类型声明文件的使用说明"></a>5.2 类型声明文件的使用说明</h3><p>在使用 TS 开发项目时，类型声明文件的使用包括以下两种方式：</p>
<ol>
<li>使用已有的类型声明文件</li>
<li>创建自己的类型声明文件</li>
</ol>
<p>学习顺序：先会用（别人的）再会写（自己的）。</p>
<p><strong>使用已有的类型声明文件</strong></p>
<ol>
<li>内置类型声明文件</li>
<li>第三方库的类型声明文件</li>
</ol>
<p><strong>内置类型声明文件：TS 为 JS 运行时可用的所有标准化内置 API 都提供了声明文件。</strong><br>比如，在使用数组时，数组所有方法都会有相应的代码提示以及类型信息：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\18389\AppData\Roaming\Typora\typora-user-images\image-20230517144403694.png" alt="image-20230517144403694"></p>
<p>实际上这都是 TS 提供的内置类型声明文件。<br>可以通过 Ctrl + 鼠标左键（Mac：option + 鼠标左键）来查看内置类型声明文件内容。<br>比如，查看 forEach 方法的类型声明，在 VSCode 中会自动跳转到 lib.es5.d.ts 类型声明文件中。<br>当然，像 window、document 等 BOM、DOM API 也都有相应的类型声明（lib.dom.d.ts）。<br><strong>第三方库的类型声明文件</strong>：目前，几乎所有常用的第三方库都有相应的类型声明文件。<br>第三方库的类型声明文件有两种存在形式：</p>
<ol>
<li>库自带类型声明文件	</li>
<li>由 DefinitelyTyped 提供</li>
</ol>
<p><strong>库自带类型声明文件</strong>：比如，axios</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\18389\AppData\Roaming\Typora\typora-user-images\image-20230517144525757.png" alt="image-20230517144525757"></p>
<blockquote>
<p>这种情况下，正常导入该库，TS 就会自动加载库自己的类型声明文件，以提供该库的类型声明。</p>
</blockquote>
<p><strong>由 DefinitelyTyped 提供</strong></p>
<p><a target="_blank" rel="noopener" href="https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master">DefinitelyTyped</a>是一个 github 仓库，用来提供高质量 TypeScript 类型声明。<br>可以通过 npm&#x2F;yarn 来下载该仓库提供的 TS 类型声明包，这些包的名称格式为：@types&#x2F;*。<br>比如，@types&#x2F;react、@types&#x2F;lodash 等。<br>说明：在实际项目开发时，如果你使用的第三方库没有自带的声明文件，VSCode 会给出明确的提示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\18389\AppData\Roaming\Typora\typora-user-images\image-20230519101820473.png" alt="image-20230519101820473"></p>
<blockquote>
<p>当安装 @types&#x2F;* 类型声明包后，TS 也会自动加载该类声明包，以提供该库的类型声明</p>
</blockquote>
<h3 id="5-2-2-创建自己的类型声明文件"><a href="#5-2-2-创建自己的类型声明文件" class="headerlink" title="5.2.2 创建自己的类型声明文件"></a>5.2.2 创建自己的类型声明文件</h3><p>创建自己的类型声明文件：</p>
<ol>
<li>项目内共享类型</li>
<li>为已有 JS 文件提供类型声明</li>
</ol>
<p><strong>项目内共享类型</strong><br>如果多个 .ts 文件中都用到同一个类型，此时可以创建 .d.ts 文件提供该类型，实现类型共享</p>
<p>操作步骤：</p>
<ol>
<li>创建 index.d.ts 类型声明文件</li>
<li>创建需要共享的类型，并使用 export 导出（TS 中的类型也可以使用 import&#x2F;export 实现模块化功能）</li>
<li>在需要使用共享类型的 .ts 文件中，通过 import 导入即可（.d.ts 后缀导入时，直接省略）为已有 JS 文件提供类型声明</li>
</ol>
<p><strong>为已有 JS 文件提供类型声明</strong></p>
<ol>
<li>在将 JS 项目<a target="_blank" rel="noopener" href="https://www.typescriptlang.org/docs/handbook/migrating-from-javascript.html">迁移</a>到 TS 项目时，为了让已有的 .js 文件有类型声明。</li>
<li>成为库作者，创建库给其他人使用。</li>
</ol>
<p>注意：类型声明文件的编写与模块化方式相关，不同的模块化方式有不同的写法。但由于历史原因，JS<br>模块化的发展经历过多种变化（AMD、CommonJS、UMD、ESModule 等），而 TS 支持各种模块化形<br>式的类型声明。这就导致，类型声明文件<a target="_blank" rel="noopener" href="https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html">相关内容</a>又多又杂。</p>
<p>演示：基于最新的 <strong>ESModule</strong>（import&#x2F;export）来为已有 .js 文件，创建类型声明文件</p>
<p>开发环境准备：使用 webpack 搭建，通过 <strong>ts-loader</strong> 处理 .ts 文件</p>
<blockquote>
<p>TS 项目中也可以使用 .js 文件</p>
<p>在导入 .js 文件时，TS 会自动加载与 .js 同名的 .d.ts 文件，以提供类型声明</p>
<p>declare 关键字：用于类型声明，为其他地方（比如，.js 文件）已存在的变量声明类型，而不是创<br>建一个新的变量</p>
<ol>
<li>对于 type、interface 等这些明确就是 TS 类型的（只能在 TS 中使用的），可以省略 declare<br>关键字。</li>
<li>对于 let、function 等具有双重含义（在 JS、TS 中都能用），应该使用 declare 关键字，明<br>确指定此处用于类型声明。</li>
</ol>
</blockquote>
</article><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://example.com/2023/06/20/TS%20%E6%A6%82%E8%BF%B0%E3%80%81%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83%E3%80%81%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%9E%8B/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=TS概述、搭建环境、常用类型&amp;url=http://example.com/2023/06/20/TS%20%E6%A6%82%E8%BF%B0%E3%80%81%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83%E3%80%81%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%9E%8B/&amp;pic=https://pic2.zhimg.com/v2-a6d23e37f009ab0337ec88401458962f_250x0.jpg?source=172ae18b" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="rm.copyPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/TypeScript/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>TypeScript<span class="tagsPageCount">2</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://i.mji.rip/2023/07/20/5bbefe8269d5cccbf9446960fa555116.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://npm.elemecdn.com/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://npm.elemecdn.com/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div></div><div class="post-copyright"><i class="anzhiyufont anzhiyu-icon-copyright"></i><div class="post-copyright__author"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://example.com/2023/06/20/TS%20%E6%A6%82%E8%BF%B0%E3%80%81%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83%E3%80%81%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%9E%8B/">原创</a><a class="post-copyright-title"><span>TS概述、搭建环境、常用类型</span></a></div><div class="post-copyright-info-box"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"></span><a class="link" href="http://example.com"></a></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a class="link" href="http://example.com/2023/06/20/TS%20%E6%A6%82%E8%BF%B0%E3%80%81%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83%E3%80%81%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%9E%8B/">http://example.com/2023/06/20/TS%20%E6%A6%82%E8%BF%B0%E3%80%81%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83%E3%80%81%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%9E%8B/</a></span><span class="copy-button" onclick="rm.copyPageUrl('http://example.com/2023/06/20/TS%20%E6%A6%82%E8%BF%B0%E3%80%81%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83%E3%80%81%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%9E%8B/)'"><i class="anzhiyufont anzhiyu-icon-copy"></i></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">阿闲Blog</a>！</span></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/06/20/Pinia%E5%AD%A6%E4%B9%A0/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.mji.rip/2023/07/20/7b528b6f73d61f1794dc57a87bd8f7fa.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">pinia学习</div></div></a></div><div class="next-post pull-right"><a href="/2023/06/20/TS%20%E4%B8%8E%20JS%20%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic2.zhimg.com/v2-a6d23e37f009ab0337ec88401458962f_250x0.jpg?source=172ae18b" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">TS与JS之间的区别</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/06/20/TS%20%E4%B8%8E%20JS%20%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/" title="TS与JS之间的区别"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic2.zhimg.com/v2-a6d23e37f009ab0337ec88401458962f_250x0.jpg?source=172ae18b" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-06-20</div><div class="title">TS与JS之间的区别</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="author-info-top"> <div class="card-info-avatar"></div></div><div class="author-info__sayhi" id="author-info__sayhi"></div><h1 class="author-info__name"></h1><div class="author-info__description">浪漫的灵魂从不向平淡的日子妥协💐</div><div class="banner-button-group"><a class="banner-button" onclick="pjax.loadUrl(&quot;/about/&quot;)"><span class="banner-button-text">了解更多</span><i class="anzhiyufont anzhiyu-icon-arrow-circle-right" style="font-size: 1.5rem"></i></a></div><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/idlers" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="social-icon faa-parent animated-hover" href="https://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=1838906938@qq.com" target="_blank" title="Email"><i class="anzhiyufont anzhiyu-icon-envelope"></i></a><a class="social-icon faa-parent animated-hover" href="/atom.xml" target="_blank" title="RSS"><i class="anzhiyufont anzhiyu-icon-rss"></i></a><a class="social-icon faa-parent animated-hover" href="tencent://Message/?Uin=1838906938&amp;amp;websiteName=local.edu.com:8888=&amp;amp;Menu=yes" target="_blank" title="QQ"><i class="anzhiyufont anzhiyu-icon-qq"></i></a></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://i.mji.rip/2023/07/19/e068573872aeec73d5c92533179c8dfe.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Typescript-%E6%A6%82%E8%BF%B0%E3%80%81%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83%E3%80%81%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.</span> <span class="toc-text">Typescript 概述、搭建环境、常用类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81TypeScript-%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.</span> <span class="toc-text">一、TypeScript 介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-TypeScript-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1 TypeScript 是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-TypeScript-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%B8%BA-JS-%E6%B7%BB%E5%8A%A0%E7%B1%BB%E5%9E%8B%E6%94%AF%E6%8C%81%EF%BC%9F"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.2 TypeScript 为什么要为 JS 添加类型支持？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-TypeScript-%E7%9B%B8%E6%AF%94-JS-%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.3 TypeScript 相比 JS 的优势</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81TypeScript-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="toc-number">1.2.</span> <span class="toc-text">二、TypeScript 环境搭建</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%AE%89%E8%A3%85%E7%BC%96%E8%AF%91-TS-%E7%9A%84%E5%B7%A5%E5%85%B7%E5%8C%85"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1 安装编译 TS 的工具包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E7%BC%96%E8%AF%91%E5%B9%B6%E8%BF%90%E8%A1%8C-TS-%E4%BB%A3%E7%A0%81"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.2 编译并运行 TS 代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E7%AE%80%E5%8C%96%E8%BF%90%E8%A1%8C-TS-%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.2.3.</span> <span class="toc-text">2.3 简化运行 TS 的步骤</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81TypeScript-%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.</span> <span class="toc-text">三、TypeScript 常用类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.3.1.</span> <span class="toc-text">3.1 类型注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%B8%B8%E7%94%A8%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B%E6%A6%82%E8%BF%B0"><span class="toc-number">1.3.2.</span> <span class="toc-text">3.2 常用基础类型概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.3 原始类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.4.</span> <span class="toc-text">3.4 数组类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"><span class="toc-number">1.3.5.</span> <span class="toc-text">3.5 类型别名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.6.</span> <span class="toc-text">3.6 函数类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-1-%E5%8D%95%E7%8B%AC%E6%8C%87%E5%AE%9A%E5%8F%82%E6%95%B0%E3%80%81%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.6.1.</span> <span class="toc-text">3.6.1 单独指定参数、返回值的类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-2-%E5%90%8C%E6%97%B6%E6%8C%87%E5%AE%9A%E5%8F%82%E6%95%B0%E3%80%81%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.6.2.</span> <span class="toc-text">3.6.2 同时指定参数、返回值的类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-3-%E5%87%BD%E6%95%B0%E5%8F%AF%E9%80%89%E5%8F%82%E6%95%B0"><span class="toc-number">1.3.6.3.</span> <span class="toc-text">3.6.3 函数可选参数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.7.</span> <span class="toc-text">3.7 对象类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-7-1-%E5%8F%AF%E9%80%89%E5%B1%9E%E6%80%A7"><span class="toc-number">1.3.7.1.</span> <span class="toc-text">3.7.1 可选属性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-8-%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.3.8.</span> <span class="toc-text">3.8 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF"><span class="toc-number">1.3.8.0.1.</span> <span class="toc-text">接口继承</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-9-%E5%85%83%E7%BB%84"><span class="toc-number">1.3.9.</span> <span class="toc-text">3.9 元组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-10-%E7%B1%BB%E5%9E%8B%E6%8E%A8%E8%AE%BA"><span class="toc-number">1.3.10.</span> <span class="toc-text">3.10 类型推论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-11-%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80"><span class="toc-number">1.3.11.</span> <span class="toc-text">3.11 类型断言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-12-%E5%AD%97%E9%9D%A2%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.12.</span> <span class="toc-text">3.12 字面量类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-13-%E6%9E%9A%E4%B8%BE"><span class="toc-number">1.3.13.</span> <span class="toc-text">3.13 枚举</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-14-any-%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.14.</span> <span class="toc-text">3.14 any 类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-15-typeof"><span class="toc-number">1.3.15.</span> <span class="toc-text">3.15 typeof</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81TypeScript%E9%AB%98%E7%BA%A7%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.4.</span> <span class="toc-text">四、TypeScript高级类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-class-%E7%B1%BB"><span class="toc-number">1.4.1.</span> <span class="toc-text">4.1 class 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E7%B1%BB%E5%9E%8B%E5%85%BC%E5%AE%B9%E6%80%A7"><span class="toc-number">1.4.2.</span> <span class="toc-text">4.2 类型兼容性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E4%BA%A4%E5%8F%89%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.4.3.</span> <span class="toc-text">4.3 交叉类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E6%B3%9B%E5%9E%8B"><span class="toc-number">1.4.4.</span> <span class="toc-text">4.4 泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-%E7%B4%A2%E5%BC%95%E7%AD%BE%E5%90%8D%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.4.5.</span> <span class="toc-text">4.5 索引签名类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-%E6%98%A0%E5%B0%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.4.6.</span> <span class="toc-text">4.6 映射类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81TypeScript-%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6"><span class="toc-number">1.5.</span> <span class="toc-text">五、TypeScript 类型声明文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-TS-%E4%B8%AD%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.5.1.</span> <span class="toc-text">5.1 TS 中的两种文件类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E"><span class="toc-number">1.5.2.</span> <span class="toc-text">5.2 类型声明文件的使用说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-2-%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6"><span class="toc-number">1.5.3.</span> <span class="toc-text">5.2.2 创建自己的类型声明文件</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/07/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/" title="前端面试题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.mji.rip/2023/07/20/5bbefe8269d5cccbf9446960fa555116.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端面试题"/></a><div class="content"><a class="title" href="/2023/07/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/" title="前端面试题">前端面试题</a><time datetime="2023-07-24T07:52:40.347Z" title="发表于 2023-07-24 15:52:40">2023-07-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/21/Hexo%20deploy%20%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/" title="Hexo deploy遇到的问题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.mji.rip/2023/07/21/b0b85162c34490eee38218fd0b674a4c.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hexo deploy遇到的问题"/></a><div class="content"><a class="title" href="/2023/07/21/Hexo%20deploy%20%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/" title="Hexo deploy遇到的问题">Hexo deploy遇到的问题</a><time datetime="2023-07-21T14:22:37.178Z" title="发表于 2023-07-21 22:22:37">2023-07-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/20/%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D/" title="面试自我介绍"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.mji.rip/2023/07/20/4f86a31d56a184290046181d7d4496fc.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="面试自我介绍"/></a><div class="content"><a class="title" href="/2023/07/20/%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D/" title="面试自我介绍">面试自我介绍</a><time datetime="2023-07-20T14:21:47.444Z" title="发表于 2023-07-20 22:21:47">2023-07-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/20/%E9%9D%A2%E8%AF%95%E7%A4%BC%E4%BB%AA/" title="面试礼仪"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.mji.rip/2023/07/20/1171b56bd6fd48dc0da0dd0aaddcdb2a.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="面试礼仪"/></a><div class="content"><a class="title" href="/2023/07/20/%E9%9D%A2%E8%AF%95%E7%A4%BC%E4%BB%AA/" title="面试礼仪">面试礼仪</a><time datetime="2023-07-20T14:21:47.439Z" title="发表于 2023-07-20 22:21:47">2023-07-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/20/%E7%AE%80%E5%8E%86%E5%88%B6%E4%BD%9C/" title="简历制作"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.mji.rip/2023/07/20/42de66abac518049960f30ddb4dddcd7.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="简历制作"/></a><div class="content"><a class="title" href="/2023/07/20/%E7%AE%80%E5%8E%86%E5%88%B6%E4%BD%9C/" title="简历制作">简历制作</a><time datetime="2023-07-20T14:21:47.433Z" title="发表于 2023-07-20 22:21:47">2023-07-20</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="footer_deal"><a class="deal_link" target="_blank" rel="noopener" href="https://mail.qq.com/cgi-bin/frame_html?sid=NgxCaxXBgxiaBGkN&amp;r=f731997301edcb52a8f8caf2dba03460&amp;lang=zh" title="email"><i class="anzhiyufont anzhiyu-icon-envelope"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://weibo.com/u/5637893308" title="微博"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://www.facebook.com/profile.php?id=100089634836331&amp;sk=about" title="facebook"><i class="anzhiyufont anzhiyu-icon-facebook1"></i></a><img class="footer_mini_logo" title="返回顶部" onclick="anzhiyu.scrollToDest(0, 500)" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.giphy.com/media/3o7aCTfyhYawdOXcFW/giphy.webp" size="50px"/><a class="deal_link" target="_blank" rel="noopener" href="https://github.com/idlers" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://space.bilibili.com/346723352" title="Bilibili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://www.douyin.com/user/self" title="抖音"><i class="anzhiyufont anzhiyu-icon-tiktok"></i></a></div><div class="copyright">&copy;2021 - 2023 By null</div><div id="workboard"><img class="workSituationImg boardsign" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.0.4/img/badge/安知鱼-上班摸鱼中.svg" alt="距离月入25k也就还差一个大佬带我~" title="距离月入25k也就还差一个大佬带我~"/><div id="runtimeTextTip"></div></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title="本站项目由Github托管"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Source-Github.svg" alt="本站项目由Github托管"/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.2.0/img/badge/Copyright-BY-NC-SA.svg" alt="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"/></a></p></div></footer></div></div></div><div id="sidebar"><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://w.wallhaven.cc/full/yx/wallhaven-yxvy1x.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">35</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child" style="left:-79px;"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child" style="left:-79px;"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 阿闲</span></a><ul class="menus_item_child" style="left:-79px;"><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 影视聚</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child" style="left:-79px;"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于阿闲</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言闲话</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 闲人文章</span></a></li></ul></div></div></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="center-console" type="button" title="中控台"><i class="anzhiyufont anzhiyu-icon-fish"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><div id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()">播放音乐</div><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random"></meting-js></div><div id="console"><div class="close-btn" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-xmark" style="font-size: 35px;"></i></div><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="wechat" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="alipay" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments" onclick="anzhiyu.hideConsole()"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> <span>最新评论</span></span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags" onclick="anzhiyu.hideConsole()"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/AI/" style="font-size: 1.05rem;">AI<sup>1</sup></a><a href="/tags/Axure/" style="font-size: 1.05rem;">Axure<sup>3</sup></a><a href="/tags/Front-matter/" style="font-size: 1.05rem;">Front-matter<sup>1</sup></a><a href="/tags/Git/" style="font-size: 1.05rem;">Git<sup>3</sup></a><a href="/tags/Hexo/" style="font-size: 1.05rem;">Hexo<sup>2</sup></a><a href="/tags/Pinia/" style="font-size: 1.05rem;">Pinia<sup>1</sup></a><a href="/tags/TypeScript/" style="font-size: 1.05rem;">TypeScript<sup>2</sup></a><a href="/tags/Typora/" style="font-size: 1.05rem;">Typora<sup>3</sup></a><a href="/tags/shields%E5%BE%BD%E7%AB%A0/" style="font-size: 1.05rem;">shields徽章<sup>1</sup></a><a href="/tags/%E4%BA%92%E8%81%94%E5%86%B2%E6%B5%AA/" style="font-size: 1.05rem;">互联冲浪<sup>2</sup></a><a href="/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/" style="font-size: 1.05rem;">前端技术栈<sup>1</sup></a><a href="/tags/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/" style="font-size: 1.05rem;">前端相关<sup>1</sup></a><a href="/tags/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/" style="font-size: 1.05rem;">实用工具<sup>1</sup></a><a href="/tags/%E5%B0%B1%E4%B8%9A/" style="font-size: 1.05rem;">就业<sup>1</sup></a><a href="/tags/%E5%B0%B1%E4%B8%9A%E7%9B%B8%E5%85%B3/" style="font-size: 1.05rem;">就业相关<sup>5</sup></a><a href="/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/" style="font-size: 1.05rem;">开发工具<sup>1</sup></a><a href="/tags/%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB/" style="font-size: 1.05rem;">资源分享<sup>5</sup></a></div></div><hr/></div></div><div class="console-card history" onclick="anzhiyu.hideConsole()"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/07/"><span class="card-archive-list-date">七月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">6</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/06/"><span class="card-archive-list-date">六月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">29</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" onclick="anzhiyu.switchDarkMode()" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div><div class="console-btn-item" id="consoleKeyboard" onclick="anzhiyu.keyboardToggle()" title="快捷键开关"><a class="keyboard-switch"><i class="anzhiyufont anzhiyu-icon-keyboard"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div id="he-plugin-simple"></div><script>var WIDGET = {
  "CONFIG": {
    "modules": "0124",
    "background": "2",
    "tmpColor": "FFFFFF",
    "tmpSize": "16",
    "cityColor": "FFFFFF",
    "citySize": "16",
    "aqiColor": "E8D87B",
    "aqiSize": "16",
    "weatherIconSize": "24",
    "alertIconSize": "18",
    "padding": "10px 10px 10px 10px",
    "shadow": "0",
    "language": "auto",
    "borderRadius": "20",
    "fixed": "true",
    "vertical": "top",
    "horizontal": "left",
    "left": "20",
    "top": "7.1",
    "key": "df245676fb434a0691ead1c63341cd94"
  }
}
</script><link rel="stylesheet" href="https://widget.qweather.net/simple/static/css/he-simple.css?v=1.4.0"/><script src="https://widget.qweather.net/simple/static/js/he-simple.js?v=1.4.0"></script><div><script src="https://npm.elemecdn.com/hexo-theme-anzhiyu@1.3.1/source/js/utils.js"></script><script src="https://npm.elemecdn.com/hexo-theme-anzhiyu@1.3.1/source/js/main.js"></script><script src="https://npm.elemecdn.com/hexo-theme-anzhiyu@1.3.1/source/js/tw_cn.js"></script><script src="https://npm.elemecdn.com/@fancyapps/ui@4.0.31/dist/fancybox.umd.js"></script><script src="https://npm.elemecdn.com/instant.page@5.1.1/instantpage.js" type="module"></script><script src="https://npm.elemecdn.com/vanilla-lazyload@17.3.1/dist/lazyload.iife.min.js"></script><script src="https://npm.elemecdn.com/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://npm.elemecdn.com/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script async src="/anzhiyu/random.js"></script><script async="async">(function () {
  var grt = new Date("04/01/2021 00:00:00"); //设置网站上线时间
  var now = new Date();
  var dnum;
  var hnum;
  var mnum;
  var snum;
  var nowHour;

  // 计算并更新天数、小时数、分钟数和秒数
  function updateTime() {
    now = new Date(); // 更新 now 的值
    nowHour = now.getHours(); // 更新 nowHour 的值
    var days = (now - grt) / 1000 / 60 / 60 / 24;
    dnum = Math.floor(days);
    var hours = (now - grt) / 1000 / 60 / 60 - 24 * dnum;
    hnum = Math.floor(hours);
    if (String(hnum).length == 1) {
      hnum = "0" + hnum;
    }
    var minutes = (now - grt) / 1000 / 60 - 24 * 60 * dnum - 60 * hnum;
    mnum = Math.floor(minutes);
    if (String(mnum).length == 1) {
      mnum = "0" + mnum;
    }
    var seconds = (now - grt) / 1000 - 24 * 60 * 60 * dnum - 60 * 60 * hnum - 60 * mnum;
    snum = Math.round(seconds);
    if (String(snum).length == 1) {
      snum = "0" + snum;
    }
  }

  // 更新网页中显示的网站运行时间
  function updateHtml() {
    const footer = document.getElementById("footer");
    if (!footer) return
    let currentTimeHtml = "";
    if (nowHour < 18 && nowHour >= 9) {
      // 如果是上班时间，默认就是"安知鱼-上班摸鱼中.svg"图片，不需要更改
      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    } else {
      // 如果是下班时间，插入"安知鱼-下班啦.svg"图片
      let img = document.querySelector("#workboard .workSituationImg");
      img.src = "https://npm.elemecdn.com/anzhiyu-blog@2.0.4/img/badge/安知鱼-下班啦.svg";
      img.title = "下班了就该开开心心的玩耍，嘿嘿~";
      img.alt = "下班了就该开开心心的玩耍，嘿嘿~";

      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    }

    if (document.getElementById("runtimeTextTip")) {
      document.getElementById("runtimeTextTip").innerHTML = currentTimeHtml;
    }
  }

  setInterval(() => {
    updateTime();
    updateHtml();
  }, 1000);
})();</script><script src="https://npm.elemecdn.com/hexo-theme-anzhiyu@1.3.1/source/js/search/local-search.js"></script><div class="js-pjax"><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://npm.elemecdn.com/mermaid@9.1.7/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail = "visitor@anheyu.com";</script><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script>// 初始化函数
let rm = {};

//禁止图片与超链接拖拽
let aElements = document.getElementsByTagName("a");
for (let i = 0; i < aElements.length; i++) {
  aElements[i].setAttribute("draggable", "false");
  let imgElements = aElements[i].getElementsByTagName("img");
  for (let j = 0; j < imgElements.length; j++) {
    imgElements[j].setAttribute("draggable", "false");
  }
}

// 显示菜单
rm.showRightMenu = function (isTrue, x = 0, y = 0) {
  console.info(x, y)
  let rightMenu = document.getElementById("rightMenu");
  rightMenu.style.top = x + "px";
  rightMenu.style.left = y + "px";
  if (isTrue) {
    rightMenu.style.display = "block";
    stopMaskScroll();
  } else {
    rightMenu.style.display = "none";
  }
};

// 隐藏菜单
rm.hideRightMenu = function () {
  rm.showRightMenu(false);
  let rightMenuMask = document.querySelector("#rightmenu-mask");
  rightMenuMask.style.display = "none";
};

// 尺寸
let rmWidth = document.getElementById("rightMenu").offsetWidth;
let rmHeight = document.getElementById("rightMenu").offsetHeight;

// 重新定义尺寸
rm.reloadrmSize = function () {
  rightMenu.style.visibility = "hidden";
  rightMenu.style.display = "block";
  // 获取宽度和高度
  rmWidth = document.getElementById("rightMenu").offsetWidth;
  rmHeight = document.getElementById("rightMenu").offsetHeight;
  rightMenu.style.visibility = "visible";
};

// 获取点击的href
let domhref = "";
let domImgSrc = "";
let globalEvent = null;

var oncontextmenuFunction = function (event) {
  if (document.body.clientWidth > 768) {
    let pageX = event.clientX + 10; //加10是为了防止显示时鼠标遮在菜单上
    let pageY = event.clientY;

    //其他额外菜单
    const $rightMenuOther = document.querySelector(".rightMenuOther");
    const $rightMenuPlugin = document.querySelector(".rightMenuPlugin");
    const $rightMenuCopyText = document.querySelector("#menu-copytext");
    const $rightMenuPasteText = document.querySelector("#menu-pastetext");
    const $rightMenuCommentText = document.querySelector("#menu-commenttext");
    const $rightMenuNewWindow = document.querySelector("#menu-newwindow");
    const $rightMenuNewWindowImg = document.querySelector("#menu-newwindowimg");
    const $rightMenuCopyLink = document.querySelector("#menu-copylink");
    const $rightMenuCopyImg = document.querySelector("#menu-copyimg");
    const $rightMenuDownloadImg = document.querySelector("#menu-downloadimg");
    const $rightMenuSearch = document.querySelector("#menu-search");
    const $rightMenuSearchBaidu = document.querySelector("#menu-searchBaidu");
    const $rightMenuMusicToggle = document.querySelector("#menu-music-toggle");
    const $rightMenuMusicBack = document.querySelector("#menu-music-back");
    const $rightMenuMusicForward = document.querySelector("#menu-music-forward");
    const $rightMenuMusicPlaylist = document.querySelector("#menu-music-playlist");
    const $rightMenuMusicCopyMusicName = document.querySelector("#menu-music-copyMusicName");

    let href = event.target.href;
    let imgsrc = event.target.currentSrc;

    // 判断模式 扩展模式为有事件
    let pluginMode = false;
    $rightMenuOther.style.display = "block";
    globalEvent = event;

    // 检查是否需要复制 是否有选中文本
    if (selectTextNow && window.getSelection()) {
      pluginMode = true;
      $rightMenuCopyText.style.display = "block";
      $rightMenuCommentText.style.display = "block";
      $rightMenuSearch.style.display = "block";
      $rightMenuSearchBaidu.style.display = "block";
    } else {
      $rightMenuCopyText.style.display = "none";
      $rightMenuCommentText.style.display = "none";
      $rightMenuSearchBaidu.style.display = "none";
      $rightMenuSearch.style.display = "none";
    }

    //检查是否右键点击了链接a标签
    if (href) {
      pluginMode = true;
      $rightMenuNewWindow.style.display = "block";
      $rightMenuCopyLink.style.display = "block";
      domhref = href;
    } else {
      $rightMenuNewWindow.style.display = "none";
      $rightMenuCopyLink.style.display = "none";
    }

    //检查是否需要复制图片
    if (imgsrc) {
      pluginMode = true;
      $rightMenuCopyImg.style.display = "block";
      $rightMenuDownloadImg.style.display = "block";
      $rightMenuNewWindowImg.style.display = "block";
      document.getElementById("rightMenu").style.width="12rem"
      domImgSrc = imgsrc;
    } else {
      $rightMenuCopyImg.style.display = "none";
      $rightMenuDownloadImg.style.display = "none";
      $rightMenuNewWindowImg.style.display = "none";
    }

    // 判断是否为输入框
    if (event.target.tagName.toLowerCase() === "input" || event.target.tagName.toLowerCase() === "textarea") {
      pluginMode = true;
      $rightMenuPasteText.style.display = "block";
    } else {
      $rightMenuPasteText.style.display = "none";
    }
    const navMusicEl = document.querySelector("#nav-music");
    //判断是否是音乐
    if (navMusicEl && navMusicEl.contains(event.target)) {
      pluginMode = true;
      $rightMenuMusicToggle.style.display = "block";
      $rightMenuMusicBack.style.display = "block";
      $rightMenuMusicForward.style.display = "block";
      $rightMenuMusicPlaylist.style.display = "block";
      $rightMenuMusicCopyMusicName.style.display = "block";
    } else {
      $rightMenuMusicToggle.style.display = "none";
      $rightMenuMusicBack.style.display = "none";
      $rightMenuMusicForward.style.display = "none";
      $rightMenuMusicPlaylist.style.display = "none";
      $rightMenuMusicCopyMusicName.style.display = "none";
    }

    // 如果不是扩展模式则隐藏扩展模块
    if (pluginMode) {
      $rightMenuOther.style.display = "none";
      $rightMenuPlugin.style.display = "block";
    } else {
      $rightMenuPlugin.style.display = "none";
    }

    rm.reloadrmSize();

    // 鼠标默认显示在鼠标右下方，当鼠标靠右或靠下时，将菜单显示在鼠标左方\上方
    if (pageX + rmWidth > window.innerWidth) {
      pageX -= rmWidth + 10;
    }
    if (pageY + rmHeight > window.innerHeight) {
      pageY -= pageY + rmHeight - window.innerHeight;
    }

    rm.showRightMenu(true, pageY, pageX);
    document.getElementById("rightmenu-mask").style.display = "flex";
    return false;
  }
};

// 监听右键初始化
window.oncontextmenu = oncontextmenuFunction

// 下载图片状态
rm.downloadimging = false;

// 复制图片到剪贴板
rm.writeClipImg = function (imgsrc) {
  console.log("按下复制");
  rm.hideRightMenu();
  anzhiyu.snackbarShow("正在下载中，请稍后", false, 10000);
  if (rm.downloadimging == false) {
    rm.downloadimging = true;
    setTimeout(function () {
      copyImage(imgsrc);
      anzhiyu.snackbarShow("复制成功！图片已添加盲水印，请遵守版权协议");
      rm.downloadimging = false;
    }, "10000");
  }
};

function imageToBlob(imageURL) {
  const img = new Image();
  const c = document.createElement("canvas");
  const ctx = c.getContext("2d");
  img.crossOrigin = "";
  img.src = imageURL;
  return new Promise(resolve => {
    img.onload = function () {
      c.width = this.naturalWidth;
      c.height = this.naturalHeight;
      ctx.drawImage(this, 0, 0);
      c.toBlob(
        blob => {
          // here the image is a blob
          resolve(blob);
        },
        "image/png",
        0.75
      );
    };
  });
}

async function copyImage(imageURL) {
  const blob = await imageToBlob(imageURL);
  const item = new ClipboardItem({ "image/png": blob });
  navigator.clipboard.write([item]);
}

rm.copyUrl = function (id) {
  const input = document.createElement("input"); // Create a new <input> element
  input.id = "copyVal"; // Set the id of the new element to "copyVal"
  document.body.appendChild(input); // Append the new element to the end of the <body> element
  
  const text = id;
  input.value = text;
  input.select();
  input.setSelectionRange(0, input.value.length);
  document.execCommand("copy");
  
  input.remove(); // Remove the <input> element from the DOM
};

function stopMaskScroll() {
  if (document.getElementById("rightmenu-mask")) {
    let xscroll = document.getElementById("rightmenu-mask");
    xscroll.addEventListener(
      "mousewheel",
      function (e) {
        //阻止浏览器默认方法
        rm.hideRightMenu();
        // e.preventDefault();
      },
      { passive: true }
    );
  }
  if (document.getElementById("rightMenu")) {
    let xscroll = document.getElementById("rightMenu");
    xscroll.addEventListener(
      "mousewheel",
      function (e) {
        //阻止浏览器默认方法
        rm.hideRightMenu();
        // e.preventDefault();
      },
      { passive: true }
    );
  }
}

rm.rightmenuCopyText = function (txt) {
  if (navigator.clipboard) {
    navigator.clipboard.writeText(txt);
  }
  rm.hideRightMenu();
};

rm.copyPageUrl = function (url) {
  if (!url) {
    url = window.location.href;
  }
  rm.copyUrl(url);
  anzhiyu.snackbarShow("复制本页链接地址成功", false, 2000);
  rm.hideRightMenu();
};

rm.sharePage = function () {
  var content = window.location.href;
  rm.copyUrl(url);
  anzhiyu.snackbarShow("复制本页链接地址成功", false, 2000);
  rm.hideRightMenu();
};

// 复制当前选中文本
var selectTextNow = "";
document.onmouseup = document.ondblclick = selceText;

function selceText() {
  var txt;
  if (document.selection) {
    txt = document.selection.createRange().text;
  } else {
    txt = window.getSelection().toString();
  }
  selectTextNow = txt !== "" ? txt : "";
}

// 读取剪切板
rm.readClipboard = function () {
  if (navigator.clipboard) {
    navigator.clipboard.readText().then(clipText => rm.insertAtCaret(globalEvent.target, clipText));
  }
};

// 粘贴文本到焦点
rm.insertAtCaret = function (elemt, value) {
  const startPos = elemt.selectionStart,
    endPos = elemt.selectionEnd;
  if (document.selection) {
    elemt.focus();
    var sel = document.selection.createRange();
    sel.text = value;
    elemt.focus();
  } else {
    if (startPos || startPos == "0") {
      var scrollTop = elemt.scrollTop;
      elemt.value = elemt.value.substring(0, startPos) + value + elemt.value.substring(endPos, elemt.value.length);
      elemt.focus();
      elemt.selectionStart = startPos + value.length;
      elemt.selectionEnd = startPos + value.length;
      elemt.scrollTop = scrollTop;
    } else {
      elemt.value += value;
      elemt.focus();
    }
  }
};

//粘贴文本
rm.pasteText = function () {
  const result = rm.readClipboard() || "";
  rm.hideRightMenu();
};

//引用到评论
rm.rightMenuCommentText = function (txt) {
  rm.hideRightMenu();
  const postCommentDom = document.getElementById("post-comment");
  var domTop = postCommentDom.offsetTop;
  window.scrollTo(0, domTop - 80);
  if (txt == "undefined" || txt == "null") txt = "好棒！";
  function setText() {
    setTimeout(() => {
      var input = document.getElementsByClassName("el-textarea__inner")[0];
      if (!input) setText();
      let evt = document.createEvent("HTMLEvents");
      evt.initEvent("input", true, true);
      let inputValue = replaceAll(txt, "\n", "\n> ");
      input.value = "> " + inputValue + "\n\n";
      input.dispatchEvent(evt);
      input.focus();
      input.setSelectionRange(-1, -1);
      if (document.getElementById("comment-tips")) {
        document.getElementById("comment-tips").classList.add("show");
      }
    }, 100);
  }
  setText();
};

//替换所有内容
function replaceAll(string, search, replace) {
  return string.split(search).join(replace);
}

// 百度搜索
rm.searchBaidu = function () {
  anzhiyu.snackbarShow("即将跳转到百度搜索", false, 2000);
  setTimeout(function () {
    window.open("https://www.baidu.com/s?wd=" + selectTextNow);
  }, "2000");
  rm.hideRightMenu();
};

//分享链接
rm.copyLink = function () {
  rm.rightmenuCopyText(domhref);
  anzhiyu.snackbarShow("已复制链接地址");
};

function addRightMenuClickEvent() {
  // 添加点击事件
  document.getElementById("menu-backward").addEventListener("click", function () {
  window.history.back();
    rm.hideRightMenu();
  });

  document.getElementById("menu-forward").addEventListener("click", function () {
    window.history.forward();
    rm.hideRightMenu();
  });

  document.getElementById("menu-refresh").addEventListener("click", function () {
    window.location.reload();
  });

  document.getElementById("menu-top").addEventListener("click", function () {
    anzhiyu.scrollToDest(0, 500);
    rm.hideRightMenu();
  });

  const menuLinks = document.querySelectorAll(".menu-link");
  menuLinks.forEach(function (link) {
    link.addEventListener("click", rm.hideRightMenu);
  });

  document.getElementById("menu-darkmode").addEventListener("click", anzhiyu.switchDarkMode);

  document.getElementById("menu-home") && document.getElementById("menu-home").addEventListener("click", function () {
    window.location.href = window.location.origin;
  });

  document.getElementById("menu-randomPost").addEventListener("click", function () {
    toRandomPost();
  });

  document.getElementById("menu-commentBarrage").addEventListener("click", anzhiyu.switchCommentBarrage);

  document.getElementById("rightmenu-mask").addEventListener("click", rm.hideRightMenu);

  document.getElementById("rightmenu-mask").addEventListener("contextmenu", function (event) {
    rm.hideRightMenu();
    event.preventDefault(); // Prevent the default context menu from appearing
  });

  document.getElementById("menu-copy").addEventListener("click", rm.copyPageUrl);

  document.getElementById("menu-pastetext").addEventListener("click", rm.pasteText);

  document.getElementById("menu-copytext").addEventListener("click", function () {
    rm.rightmenuCopyText(selectTextNow);
    anzhiyu.snackbarShow("复制成功，复制和转载请标注本文地址");
  });

  document.getElementById("menu-commenttext").addEventListener("click", function () {
    rm.rightMenuCommentText(selectTextNow);
  });

  document.getElementById("menu-newwindow").addEventListener("click", function () {
    window.open(domhref, "_blank");
    rm.hideRightMenu();
  });

  document.getElementById("menu-copylink").addEventListener("click", rm.copyLink);

  document.getElementById("menu-downloadimg").addEventListener("click", function () {
    anzhiyu.downloadImage(domImgSrc, "anzhiyu");
  });

  document.getElementById("menu-newwindowimg").addEventListener("click", function () {
    window.open(domImgSrc, "_blank");
    rm.hideRightMenu();
  });

  document.getElementById("menu-copyimg").addEventListener("click", function () {
    rm.writeClipImg(domImgSrc);
  });

  document.getElementById("menu-searchBaidu").addEventListener("click", rm.searchBaidu);

  //音乐
  document.getElementById("menu-music-toggle").addEventListener("click", anzhiyu.musicToggle);

  document.getElementById("menu-music-back").addEventListener("click", anzhiyu.musicSkipBack);

  document.getElementById("menu-music-forward").addEventListener("click", anzhiyu.musicSkipForward);

  document.getElementById("menu-music-copyMusicName").addEventListener("click", function () {
    rm.rightmenuCopyText(anzhiyu.musicGetName());
    anzhiyu.snackbarShow("复制歌曲名称成功", false, 3000);
  });

}

addRightMenuClickEvent();</script><script data-pjax>var themeColorMeta = document.querySelector('meta[name="theme-color"]');
var pageHeaderEl = document.getElementById("page-header");
var navMusicEl = document.getElementById("nav-music");
var consoleEl = document.getElementById("console");
// 已随机的歌曲
var selectRandomSong = [];
// 音乐默认声音大小
var musicVolume = 0.8;
// 是否切换了周杰伦音乐列表
var changeMusicListFlag = false;
// 当前默认播放列表
var defaultPlayMusicList = [];

document.getElementById("page-name").innerText = document.title.split(" | 阿闲Blog")[0];
anzhiyu.initIndexEssay();
anzhiyu.changeTimeInEssay();
anzhiyu.removeBodyPaceClass();
anzhiyu.qrcodeCreate();
anzhiyu.changeTimeInAlbumDetail();
anzhiyu.reflashEssayWaterFall();
anzhiyu.sayhi();
anzhiyu.stopImgRightDrag();
anzhiyu.addNavBackgroundInit();
anzhiyu.setValueToBodyType();
anzhiyu.catalogActive();
anzhiyu.tagsPageActive();
anzhiyu.categoriesBarActive();
anzhiyu.topCategoriesBarScroll();
anzhiyu.switchRightClickMenuHotReview();

anzhiyu.getCustomPlayList();
anzhiyu.addEventListenerConsoleMusicList(false);
setTimeout(() => {
  if (typeof addFriendLinksInFooter === "function") {
    addFriendLinksInFooter();
  }
}, 200)</script><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.1.0/icon/ali_iconfont_css.css"><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://npm.elemecdn.com/butterfly-extsrc@1.1.3/dist/canvas-fluttering-ribbon.min.js"></script><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://npm.elemecdn.com/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://npm.elemecdn.com/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://npm.elemecdn.com/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '1.5s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('flink-list-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__flipInY');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('flink-list-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__animated');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('article-sort-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__slideInRight');
    arr[i].setAttribute('data-wow-duration', '1.5s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('site-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__flipInY');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('site-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__animated');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow_init.js"></script><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var qweather_key = 'b16a1fa0e63c46a4b8f28abfb06ae3fe';
  var gaud_map_key = 'e2b04289e870b005374ee030148d64fd&s=rsv3';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '112.982279,28.19409';
  var clock_default_rectangle_enable = 'false';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><!-- hexo injector body_end end --></body></html>