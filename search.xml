<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hexo deploy遇到的问题</title>
      <link href="/2023/07/21/Hexo%20deploy%20%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2023/07/21/Hexo%20deploy%20%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo-deploy-部署时遇到的问题"><a href="#Hexo-deploy-部署时遇到的问题" class="headerlink" title="Hexo deploy 部署时遇到的问题"></a>Hexo deploy 部署时遇到的问题</h1><p>前一段时间比较忙所以没有来得及更新🥱</p><p>最近这两天才腾出时间，然而就在我 <code>hexo d</code> 时出现以下报错，对于 <code>hexo d</code> 我都是小心翼翼😭</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fatal: Could not read from remote repository.</span><br><span class="line"></span><br><span class="line">Please make sure you have the correct access rights and the repository exists.</span><br><span class="line">FATAL Somethings wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.html</span><br></pre></td></tr></table></figure><p>一翻译：<code>无法从远程存储库读取。</code> 之后就是各种 百度 Google </p><p>结果就是SSH Key连接失败导致无法提交代码。</p><p>在本文中，我将分享如何解决这个问题的详细步骤，希望对其他遇到相同问题的朋友有所帮助。</p><p><strong>步骤一：配置Git身份</strong></p><p>首先，确保你在Git中设置了正确的用户名和邮箱信息。进入你需要提交代码的项目文件夹，在命令行或Git Bash中执行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">csharpCopy codegit config --global user.name &quot;yourname&quot;</span><br><span class="line">git config --global user.email &quot;your@email.com&quot;</span><br></pre></td></tr></table></figure><p>注：将”yourname”替换为你的名字，”<a href="mailto:your@email.com">your@email.com</a>“替换为你的邮箱。</p><p><strong>步骤二：删除旧的SSH Key</strong></p><p>搜索并找到.ssh文件夹，并手动删除其中的known_hosts文件，此文件会存储已连接的主机列表。</p><p><strong>步骤三：生成新的SSH Key</strong></p><p>在命令行或Git Bash中执行以下命令生成新的SSH Key：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">perlCopy code</span><br><span class="line">ssh-keygen -t rsa -C &quot;your@email.com&quot;</span><br></pre></td></tr></table></figure><p>按下回车后，系统会在.ssh文件夹下自动生成两个文件：id_rsa和id_rsa.pub。</p><p><strong>步骤四：添加SSH Key到GitHub账户</strong></p><p>打开<a href="https://github.com/%E5%B9%B6%E7%99%BB%E5%BD%95%E4%BD%A0%E7%9A%84%E8%B4%A6%E6%88%B7%EF%BC%8C%E7%84%B6%E5%90%8E%E8%BF%9B%E5%85%A5%22Settings%22%EF%BC%88%E8%AE%BE%E7%BD%AE%EF%BC%89%E3%80%82">https://github.com/并登录你的账户，然后进入&quot;Settings&quot;（设置）。</a></p><p>在”Settings”页面中，选择”SSH and GPG keys”（SSH密钥）选项。</p><p>打开id_rsa.pub文件，并复制其中的全部内容。</p><p>在GitHub的”SSH and GPG keys”页面中，点击”New SSH Key”（新建SSH密钥）按钮。</p><p>将刚刚复制的SSH Key内容粘贴到”Key”字段中，然后点击”Add SSH Key”（添加SSH密钥）按钮。</p><p><strong>步骤五：测试SSH Key连接</strong></p><p>在命令行或Git Bash中输入以下命令测试SSH Key是否连接成功：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cssCopy code</span><br><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>首次连接时，系统可能会询问是否信任该主机，输入”yes”并按下回车。</p><p>如果一切顺利，会提示你连接成功。</p><p><strong>步骤六：提交代码</strong></p><p>恭喜你，现在SSH Key连接问题应该已经解决了！退出Git并重新进入到你的项目文件夹，现在你应该能够正常提交代码了。</p><p>希望本文对解决Git提交遇到的SSH Key问题有所帮助，让你避免踩入类似的坑。如果你遇到其他问题或有其他Git相关的疑问，欢迎向社区或论坛寻求帮助。持续学习和积累经验，让我们在代码管理的路上越走越远！</p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试自我介绍</title>
      <link href="/2023/07/20/%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D/"/>
      <url>/2023/07/20/%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h1><h2 id="自我介绍的重要性"><a href="#自我介绍的重要性" class="headerlink" title="自我介绍的重要性"></a>自我介绍的重要性</h2><p>自我介绍是面试者与公司职员首次面对面深入交流的第一个环节，是建立面试官与你之间共同话题的关键，它是你是否可以和面试官愉快交流的开端，也是展示你个人信息和技能经历的机会。</p><h2 id="为什么要自我介绍"><a href="#为什么要自我介绍" class="headerlink" title="为什么要自我介绍"></a>为什么要自我介绍</h2><ol><li>给面试官扫描简历的时间，加深对你的印象。</li><li>从你的说话语气、思路判断你是一个什么样的人（性格方面）。</li><li>简单了解你的个人信息和过往技能经历。</li></ol><h2 id="自我介绍思路"><a href="#自我介绍思路" class="headerlink" title="自我介绍思路"></a>自我介绍思路</h2><ol><li>自报家门：介绍姓名、年龄、出身地。</li><li>武功绝技：强调自己擅长的领域或技能。</li><li>英勇事迹：与岗位相关的成就或经历。</li></ol><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>口语化：用口语表达，与面试官拉近距离。</li><li>使用”咱们公司”而非”贵公司”，避免使用”您”称呼。</li><li>控制时间，最好在45秒到90秒之间。</li><li>营造轻松的气氛。</li></ol><h2 id="案例剖析-1"><a href="#案例剖析-1" class="headerlink" title="案例剖析-1"></a>案例剖析-1</h2><p>小明的自我介绍：</p><blockquote><p>“很荣幸能有机会向各位自我介绍。我叫小明，今年<br>18岁，我学的是电子商务专业。这次来应聘销售岗位<br>的工作，我觉得自己通过学习可以从事这项工作，并有者浓厚的兴趣，如果能给我这个机会，我一定会在工作<br>中努力成长，一定不会让前辈们失望。我很乐意回答各位考官所提出来的任何问题。”</p></blockquote><p>小红的自我介绍：</p><blockquote><p>“我叫小红，我是一名普通的高职专科实习生，来自保定市，我一直追求着成长和发张。在校担任学生干<br>部期间获得校级优秀学生干部称号，有比较好的组织协调能力，在暑假期间多次勤工俭学，可以吃苦耐劳，参<br>加保定市校园歌曲大赛二等奖，有很强的动手能力和学习能力，我能够在不同文化和工作人员的背景下出色的<br>工作。”</p></blockquote><h2 id="案例剖析-2"><a href="#案例剖析-2" class="headerlink" title="案例剖析-2"></a>案例剖析-2</h2><p>小明的自我介绍：</p><blockquote><p>“我叫小明，我是一名普通的高职专科实习生，来自保定市，我一直追求着成长和发张。在校担任学生干<br>部期间获得校级优秀学生干部称号，有比较好的组织协调能力，在暑假期间多次勤工俭学，可以吃苦耐劳，参<br>加保定市校园歌曲大赛二等奖，有很强的动手能力和学习能力，我能够在不同文化和工作人员的背景下出色的<br>工作。”</p></blockquote><p>小丽的自我介绍：</p><blockquote><p>“我是小丽，在校期间我和几位同学用PHP语言开发过一套学生信息管理系统，用java语言开发了一个校<br>园二手交易平台，为了解决并发问题，自学了线程锁，解决交易重复问题。我相信通过我所学的技术可以很快<br>胜任公司交付我的工作。”</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>经历要和岗位相符，展现自己的解决问题和学习能力。</li><li>强调自己的自学能力和团队意识。</li><li>给面试官留有交流的空间，营造轻松愉快的气氛。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 就业相关 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试礼仪</title>
      <link href="/2023/07/20/%E9%9D%A2%E8%AF%95%E7%A4%BC%E4%BB%AA/"/>
      <url>/2023/07/20/%E9%9D%A2%E8%AF%95%E7%A4%BC%E4%BB%AA/</url>
      
        <content type="html"><![CDATA[<h1 id="面试礼仪"><a href="#面试礼仪" class="headerlink" title="面试礼仪"></a>面试礼仪</h1><h2 id="面试电话接听"><a href="#面试电话接听" class="headerlink" title="面试电话接听"></a>面试电话接听</h2><p>面试电话是我们直接接触公司职员的第一步，</p><p>说话态度和礼貌程度决定你是否可以顺利参加这次面试，</p><p>同时也是你是否可以合理安排所有面试时间的基础。</p><h3 id="需要确认的信息"><a href="#需要确认的信息" class="headerlink" title="需要确认的信息"></a>需要确认的信息</h3><ol><li>确认岗位：<ul><li>确认是否和你意向岗位相同职位：<ul><li>相同的话：接着往下听就可以。</li><li>不相同：问一下这个岗位具体是做什么的。<ul><li>这个岗位和专业相关性比较高（需要去面试一下）。</li><li>岗位和专业几乎是不相关的，而且你不愿意去（直接拒绝）。</li></ul></li></ul></li></ul></li><li>确认面试时间（一天的面试最好控制在2-3家，一周9家面试最佳状态）。<ul><li>如果面试时间冲突：<ul><li>直接使用一个不是隐私的理由（强烈推荐：不好意思啊经理，XX时间不太方便，您看XX时间可以不）。</li><li>立刻给一个具体的时间和HR确认（表现出你对时间的敏感度）。</li></ul></li></ul></li><li>确认面试地点：<ul><li>可以：我现在在朋友这里住，等工作定下来之后再找房子。</li><li>岗位确认下来之后是需要给我一定时间找房子。</li><li>提醒HR将面试邀请发送到你的邮箱。</li></ul></li><li>第一个面试邀请里面包含的公司介绍以及对应的岗位（可以根据公司介绍以及岗位需求准备对应的面试资料）。</li><li>第二个面试邀请里面包含了面试间和公司的联系方式（可以规划一下第二天面试的路线，如果有紧急情况面试不了试的，可以及时和HR沟通，争取一下面试机会）。</li></ol><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li>面试电话如果没有特殊情况下，尽量控制在1分钟之内结束。</li><li>语气要不卑不亢。</li><li>职位确认如果职位不对要反问。</li><li>时间冲突要更改时间。</li></ul><h2 id="面试着装"><a href="#面试着装" class="headerlink" title="面试着装"></a>面试着装</h2><p>着装代表一个人对生活和工作的态度，同时也是面试官对你心理定位的一种途径（积极向上方面定位）。</p><ul><li>衣服整洁干净。</li><li>不要穿护理呼哨的衣服。</li><li>衣服颜色不要超过三色（白T恤，单一颜色的裤子）。</li><li>不要穿拖鞋。</li></ul><h3 id="发型干净利落"><a href="#发型干净利落" class="headerlink" title="发型干净利落"></a>发型干净利落</h3><ul><li>切记不要染发。</li><li>头发记得每天洗（晚上洗头）。</li></ul><h3 id="整体精神稳重"><a href="#整体精神稳重" class="headerlink" title="整体精神稳重"></a>整体精神稳重</h3>]]></content>
      
      
      
        <tags>
            
            <tag> 就业相关 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序员简历制作</title>
      <link href="/2023/07/20/%E7%AE%80%E5%8E%86%E5%88%B6%E4%BD%9C/"/>
      <url>/2023/07/20/%E7%AE%80%E5%8E%86%E5%88%B6%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="简历制作"><a href="#简历制作" class="headerlink" title="简历制作"></a>简历制作</h1><ul><li><h2 id="求职流程与简历的重要性"><a href="#求职流程与简历的重要性" class="headerlink" title="求职流程与简历的重要性"></a>求职流程与简历的重要性</h2><ol><li><strong>确认岗位：</strong> 可以让HR一眼看到你意向的岗位，意向岗位只能有一个，可以胜任的岗位也需列出来。<ul><li>Java<ul><li>Java开发工程师</li><li>前端开发（小程序原生开发）</li><li>系统运维工程师</li><li>功能测试工程师</li><li>手机测试工程师</li><li>桌面运维工程师（装系统、做远程会议支持）</li></ul></li><li>前端<ul><li>前端开发工程师</li><li>小程序开发工程师</li><li>功能测试</li></ul></li><li>移动专业<ul><li>安卓</li><li>前端开发</li><li>小程序开发工程师</li><li>功能测试</li></ul></li><li>测试<ul><li>性能测试工程师</li><li>功能测试工程师</li><li>手机测试工程师</li><li>桌面运维工程师</li></ul></li></ul></li><li><strong>准备简历：</strong> <ul><li>表述出你为什么可以胜任这个岗位。</li><li>所有的模块都要论证你为什么可以\胜任这个岗位。</li></ul></li><li><strong>背面试题：</strong> <ul><li>在面试过程中，将专业问题进行熟悉，准备面试题。</li><li>前端：<a href="https://interview.poetries.top/">https://interview.poetries.top/</a></li></ul></li><li><strong>获取招聘信息：</strong> <ul><li>调查招聘的要点以及公司背景，对公司有一定的了解。</li><li>根据岗位需求来准备对应面试题。</li></ul></li><li><strong>面试：</strong> <ul><li>在面试过程中展示自己的能力。</li><li>展示自己的专业技能和职业技能。</li></ul></li></ol></li></ul><h2 id="简历的组成与制作"><a href="#简历的组成与制作" class="headerlink" title="简历的组成与制作"></a>简历的组成与制作</h2><h3 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h3><ul><li>姓名：xxx</li><li>性别：男&#x2F;女</li><li>籍贯：河北省廊坊市</li><li>现居住地：</li><li>邮箱：xxx.163.com</li><li>电话：1388888888</li></ul><h3 id="求职意向"><a href="#求职意向" class="headerlink" title="求职意向"></a>求职意向</h3><ul><li>意向岗位：前端开发工程师</li><li>意向城市：北京（只能写一个城市）</li><li>求职类型：全职&#x2F;实习</li><li>目前状态：离校&#x2F;随时到岗</li></ul><h3 id="教育背景"><a href="#教育背景" class="headerlink" title="教育背景"></a>教育背景</h3><ul><li>学校名称：2021.09—至今</li><li>专业：软件工程</li><li>所学课程：《计算机基础》《数据结构》《数据库原理》《毛概》《java基础》《专业英语》</li><li>校园经历：（比如参加过哪些比赛、担任过什么样的职务等）</li></ul><h3 id="掌握技能"><a href="#掌握技能" class="headerlink" title="掌握技能"></a>掌握技能</h3><p>从基础到框架的一个顺序，使用熟悉、熟练掌握、熟练应用、了解等词汇描述所对应的技能。</p><ul><li>专业技能：完成专业性工作的技能。<ul><li>熟练掌握HTML5、CSS3。</li><li>熟悉Sass和Less编译，实现CSS的管理和维护。</li><li>熟练使用前端的基础框架和类库，如jQuery、Swiper等。</li><li>熟练使用响应式和弹性盒布局，使用rem、vh、px和百分比进行移动端的布局。</li><li>熟练使用AJAX、Axios进行前后端数据交互。</li><li>熟练使用Bootstrap、Layui、Vant、等前端框架，能够快速实现页面开发。</li><li>熟练掌握JavaScript核心基础，并掌握ES6常用语言法。</li><li>熟练使用Vue框架，擅长Vue全家桶(VueRouter+Vuex)+ElementUI进行项目的开发。</li><li>熟练使用uni-app框架进行多端应用开发。</li><li>熟练使用微信小程序和微信公众号开发的常用组件和API。</li><li>了解Node.js，使用Express框架开发过小型项目。</li><li>了解TypeScript的静态类型检查。</li><li>了解Webpack和Vite前端自动化构建工具，以及Git代码托管工具。</li><li>了解SVG矢量图和Canvas画图的基本使用。</li><li>了解Prettier、ESLint、Stylelint等代码质量检查工具。</li><li>了解Apifox、Apipost、Postman等调试工具。</li><li>熟练使用VS Code、WebStorm、HBuilderX、IDEA、Eclipse、WXCode等开发工具</li></ul></li><li>职业技能：辅助完成专业性工作的技能。<ul><li>熟练使用office，WPS（Excel、PPT、Word）等办公软件。</li><li>熟练使用Photoshop、Premiere、Adobe XD、Axure和剪映专业版等UI&#x2F;UX工具。</li><li>熟练使用Markdown语法，Typora编辑器。</li><li>熟练使用Xmind思维导图编辑器。</li></ul></li></ul><h3 id="项目-x2F-工作经验"><a href="#项目-x2F-工作经验" class="headerlink" title="项目&#x2F;工作经验"></a>项目&#x2F;工作经验</h3><p>至少两个项目，项目时间为倒序。</p><ul><li>项目名称：一定要高大上一点儿。</li><li>项目介绍：这个项目主要实现了什么功能，为生活或者工作带来什么样的便利，有什么样的意义。</li><li>所用技术：使用“+”或者“、”将项目的主要技术链接起来。</li><li>个人职责：特指使用XX技术完成XX功能。</li><li>项目收获：描述出你做完之后的感想。</li></ul><h3 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h3><p>两行半即可，可以使用百度夸自己的语句，郎朗上口。</p><h2 id="简历制作的注意事项"><a href="#简历制作的注意事项" class="headerlink" title="简历制作的注意事项"></a>简历制作的注意事项</h2><ul><li>挑选风格简约的简历模板，不使用表格模板。</li><li>专业术语及标点符号的使用务必正确。</li><li>使用时间倒叙手法排列内容（项目&#x2F;工作&#x2F;活动经验）。</li><li>在简历中照片可有可无，如果没有照片，需要将模版中的照片位删除（女生最好提供一个照片：比较干练的形象）。</li><li>如果在制作简历之前已有意向招聘信息，需按照招聘信息中的要求去着重&#x2F;适度夸张的描写简历相关部分。</li><li>如果内容较少，可以适当添加活动经历、个人爱好、自我评价等内容。</li><li>招聘平台的个人简介内容和附件简历务必填写齐全。</li><li>简历最好是两页半。</li><li>简历模板选择上下结构的模板（切记不要选择左右结构的）。</li><li>简历模板从智联和51job上找（注册一个账号就可以使用）。</li><li>注意简历的排版和格式，要让简历整洁、易读，字体大小适中，排版整齐。一定要检查简历中的错别字、语法错误等，保持语言表达的准确性和流畅性。同时，简历内容需要真实，不要夸大或虚构自己的技能和经验，这样只会让你在面试中更加被动。最后，将简历保存为PDF格式，以确保在不同设备上都可以良好地展示。</li></ul><h2 id="简历投递的注意事项"><a href="#简历投递的注意事项" class="headerlink" title="简历投递的注意事项"></a>简历投递的注意事项</h2><h3 id="投递时间"><a href="#投递时间" class="headerlink" title="投递时间"></a>投递时间</h3><ul><li>海投：周一、二上午的8：45—8：55</li><li>精投：9：30—10：00</li><li>为避免出现排版错乱情况，简历需为PDF格式文件，命名为求职岗位名称—姓名—电话</li><li>同一公司的招聘信息不要重复投递</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 就业相关 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端技术栈</title>
      <link href="/2023/07/20/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
      <url>/2023/07/20/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h1 id="前端技术栈"><a href="#前端技术栈" class="headerlink" title="前端技术栈"></a>前端技术栈</h1><blockquote><p>原思维导图文件请联系作者邮箱：<a href="mailto:&#x75;&#114;&#x62;&#x61;&#x6e;&#x69;&#x64;&#x6c;&#x65;&#114;&#115;&#x40;&#49;&#54;&#x33;&#x2e;&#99;&#111;&#x6d;">&#x75;&#114;&#x62;&#x61;&#x6e;&#x69;&#x64;&#x6c;&#x65;&#114;&#115;&#x40;&#49;&#54;&#x33;&#x2e;&#99;&#111;&#x6d;</a></p></blockquote><p><img src="https://i.mji.rip/2023/07/20/d997703a8328680fe4fa60ddd22890c0.png" alt="前端技术站"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端技术栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TS与JS之间的区别</title>
      <link href="/2023/06/20/TS%20%E4%B8%8E%20JS%20%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2023/06/20/TS%20%E4%B8%8E%20JS%20%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="TypeScript与JavaScript的区别"><a href="#TypeScript与JavaScript的区别" class="headerlink" title="TypeScript与JavaScript的区别"></a>TypeScript与JavaScript的区别</h1><h2 id="静态类型检查"><a href="#静态类型检查" class="headerlink" title="静态类型检查"></a>静态类型检查</h2><p>TypeScript引入了静态类型系统，可以在编译时检测和捕获类型错误。开发者可以在变量、函数参数、返回值等地方声明类型，并由编译器进行类型检查，提前发现潜在的类型错误。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TypeScript 静态类型检查示例</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = <span class="title function_">add</span>(<span class="number">5</span>, <span class="string">&quot;10&quot;</span>); <span class="comment">// 编译时会报类型错误，字符串无法与数字相加</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个示例中，函数<code>add</code>接收两个参数，都声明为<code>number</code>类型，并且返回值也被声明为<code>number</code>类型。在调用<code>add</code>函数时，传递了一个字符串作为第二个参数，这会导致编译时类型错误。</p><h2 id="类和接口"><a href="#类和接口" class="headerlink" title="类和接口"></a>类和接口</h2><p>TypeScript支持面向对象编程的概念，引入了类和接口的概念。开发者可以使用类来创建对象，并定义类的属性和方法。接口用于定义对象的结构和行为规范。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TypeScript 类和接口示例</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">  <span class="title function_">calculateArea</span>(): <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">  <span class="attr">radius</span>: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">radius: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">radius</span> = radius;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">calculateArea</span>(): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="property">PI</span> * <span class="variable language_">this</span>.<span class="property">radius</span> * <span class="variable language_">this</span>.<span class="property">radius</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> circle = <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">5</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(circle.<span class="title function_">calculateArea</span>());</span><br></pre></td></tr></table></figure><p>在这个示例中，我们定义了一个<code>Shape</code>接口，它包含了一个<code>calculateArea</code>方法的规范。然后，我们创建了一个<code>Circle</code>类，它实现了<code>Shape</code>接口，并实现了<code>calculateArea</code>方法。我们创建了一个<code>circle</code>对象，并调用了<code>calculateArea</code>方法来计算圆的面积</p><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>TypeScript支持模块化的开发方式，可以使用模块来组织和管理代码。开发者可以使用import和export关键字导入和导出模块，实现代码的复用和分离。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TypeScript 模块化示例</span></span><br><span class="line"><span class="comment">// 文件: utils.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件: main.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; add &#125; <span class="keyword">from</span> <span class="string">&quot;./utils&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(<span class="number">5</span>, <span class="number">10</span>));</span><br></pre></td></tr></table></figure><p>在这个示例中，我们将函数<code>add</code>定义在<code>utils.ts</code>模块中，并通过<code>export</code>关键字导出。然后，在<code>main.ts</code>模块中使用<code>import</code>关键字引入<code>add</code>函数，并进行调用。</p><h2 id="类型注解和类型推断"><a href="#类型注解和类型推断" class="headerlink" title="类型注解和类型推断"></a>类型注解和类型推断</h2><p>TypeScript可以通过类型注解显式地声明变量的类型，也可以通过类型推断根据上下文自动推断变量的类型。这提供了更好的代码可读性和可维护性。</p><p><strong>类型注解</strong>：在类型注解中，我们显式地声明变量的类型。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">num</span>: <span class="built_in">number</span>; <span class="comment">// 声明一个名为num的变量，其类型为number</span></span><br><span class="line">num = <span class="number">10</span>; <span class="comment">// 正确，num是一个number类型的变量</span></span><br><span class="line">num = <span class="string">&#x27;hello&#x27;</span>; <span class="comment">// 错误，不能将字符串赋值给number类型的变量</span></span><br></pre></td></tr></table></figure><p>在上面的示例中，我们使用了类型注解来将变量<code>num</code>的类型指定为<code>number</code>。这意味着<code>num</code>只能存储数字类型的值。如果我们尝试将字符串赋值给<code>num</code>，TypeScript会给出编译错误。</p><p><strong>类型推断</strong>：在类型推断中，TypeScript根据变量的值和上下文自动推断变量的类型。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value = <span class="number">10</span>; <span class="comment">// 推断value的类型为number</span></span><br><span class="line">value = <span class="number">20</span>; <span class="comment">// 正确，value是一个number类型的变量</span></span><br><span class="line">value = <span class="string">&#x27;hello&#x27;</span>; <span class="comment">// 错误，不能将字符串赋值给number类型的变量</span></span><br></pre></td></tr></table></figure><p>在这个示例中，我们没有显式地声明<code>value</code>的类型，但根据初始赋值为<code>10</code>，TypeScript推断出<code>value</code>的类型为<code>number</code>。后续对<code>value</code>的赋值必须是<code>number</code>类型，否则会引发编译错误。</p><p><strong>类型推断的另一个示例：</strong></p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = <span class="title function_">add</span>(<span class="number">5</span>, <span class="number">10</span>); <span class="comment">// result的类型推断为number，因为add函数返回一个number类型的值</span></span><br></pre></td></tr></table></figure><p>在上面的示例中，我们定义了一个接受两个<code>number</code>类型参数并返回<code>number</code>类型值的函数<code>add</code>。当我们调用<code>add(5,10)</code>时<br>TypeScript根据函数返回值的类型推断出<code>result</code>的类型为<code>number</code>。</p><p>总结来说，类型注解可以在变量声明时明确指定类型，而类型推断则是根据上下文自动推断变量的类型。类型注解可以提高代码的可读性和可维护性，而类型推断则减少了不必要的冗余代码。使用哪种方法取决于个人偏好和特定情况。</p><h2 id="代码重构和智能感知"><a href="#代码重构和智能感知" class="headerlink" title="代码重构和智能感知"></a>代码重构和智能感知</h2><p>TypeScript提供了更强大的代码编辑器支持，包括代码重构、智能感知、自动补全等功能，提高了开发效率和代码质量。</p><p><strong>代码重构</strong>：代码重构是指通过改变代码的结构和组织方式，改进代码的设计和可读性，同时保持其功能不变。TypeScript编辑器可以帮助我们进行各种代码重构操作，例如重命名、提取函数、提取变量等。</p><p><strong>重命名</strong>：重命名功能可确保代码中所有引用的标识符都被正确更新。例如，我们可以重命名一个变量，然后编辑器会自动更新所有使用该变量的地方。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="number">25</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将变量名从age重命名为newAge</span></span><br><span class="line"><span class="keyword">let</span> newAge = age;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newAge);</span><br></pre></td></tr></table></figure><p>在上面的示例中，我们通过重命名<code>age</code>变量为<code>newAge</code>，编辑器会自动更新所有使用<code>age</code>的地方。</p><p><strong>提取函数</strong>：提取函数可以将一段代码片段提取为一个新的函数，提高代码的可读性和复用性。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">calculateArea</span>(<span class="params">width: <span class="built_in">number</span>, height: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> area = width * height;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Area: <span class="subst">$&#123;area&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">calculateArea</span>(<span class="number">5</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>在上面的示例中，我们可以将计算面积的代码片段提取为一个名为<code>calculateArea</code>的函数。</p><p><strong>智能感知和自动补全</strong>：TypeScript编辑器提供智能感知和自动补全功能，通过分析代码上下文和类型信息，给出准确的建议和补全选项。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">person</span>: <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">25</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person. <span class="comment">// 在这里输入&quot;.&quot;，编辑器会提供智能感知和自动补全选项</span></span><br></pre></td></tr></table></figure><p>在上面的示例中，当我们输入<code>person.</code>时，编辑器会根据<code>Person</code>接口的定义，提供<code>name</code>和<code>age</code>作为智能感知和自动补全选项。</p><h2 id="工具支持和生态系统"><a href="#工具支持和生态系统" class="headerlink" title="工具支持和生态系统"></a>工具支持和生态系统</h2><p>TypeScript拥有完善的开发工具和生态系统，包括强大的编译器、调试器、编辑器插件等。这些工具和生态系统为开发者提供了丰富的开发环境和工具链，当使用TypeScript进行开发时，可以利用其完善的工具支持和丰富的生态系统，包括编译器、调试器和编辑器插件等。下面是一些示例代码，演示了如何使用这些工具和生态系统来提高开发体验：</p><p><strong>编译器</strong>：TypeScript编译器将TypeScript代码转换为可在浏览器或Node.js等环境中运行的JavaScript代码。可以使用命令行或构建工具配置编译器选项。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typescriptCopy code<span class="comment">// 创建一个名为greeting.ts的TypeScript文件</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">greeting</span>: <span class="built_in">string</span> = <span class="string">&#x27;Hello, TypeScript!&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(greeting);</span><br></pre></td></tr></table></figure><p>在上面的示例中，我们创建了一个名为<code>greeting.ts</code>的TypeScript文件，并使用<code>console.log</code>打印出一个字符串。可以使用以下命令将该文件编译为JavaScript</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc greeting.ts</span><br></pre></td></tr></table></figure><p>执行上述命令后，TypeScript编译器会生成一个名为<code>greeting.js</code>的JavaScript文件，其中包含了转换后的代码。</p><p><strong>调试器</strong>：可以使用调试器来调试TypeScript代码，以逐行查看代码执行过程、检查变量值等。例如，使用Node.js调试器进行调试。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typescriptCopy code<span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = <span class="title function_">add</span>(<span class="number">5</span>, <span class="number">10</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br></pre></td></tr></table></figure><p>在上面的示例中，我们定义了一个简单的加法函数，并打印了函数的返回结果。可以使用Node.js调试器来逐行调试这段代码。</p><p><strong>编辑器插件</strong>：TypeScript有许多编辑器插件可供选择，增强了开发体验和工作流程。以下是一些常用的编辑器插件：</p><ul><li>Visual Studio Code：VS Code是一款流行的开源代码编辑器，提供了丰富的TypeScript支持，包括语法高亮、智能感知、代码重构等功能。可以通过在VS Code中安装TypeScript插件来获得这些功能。</li><li>WebStorm：WebStorm是一款强大的JavaScript和TypeScript集成开发环境，提供了先进的代码编辑、调试和重构功能，以及与其他Web技术的无缝集成。</li><li>Atom：Atom是一款可定制的开源文本编辑器，通过安装TypeScript插件可以提供TypeScript的语法高亮、智能感知等功能。</li><li>Sublime Text：Sublime Text是一款轻量级的代码编辑器，可以通过安装TypeScript插件来增加对TypeScript的支持。</li></ul><p>总的来说，TypeScript相对于JavaScript增加了静态类型检查、类和接口、模块化、类型注解和推断、代码重构和智能感知等功能，提供了更强大、可靠和可维护的开发体验。</p>]]></content>
      
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TS概述、搭建环境、常用类型</title>
      <link href="/2023/06/20/TS%20%E6%A6%82%E8%BF%B0%E3%80%81%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83%E3%80%81%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%9E%8B/"/>
      <url>/2023/06/20/TS%20%E6%A6%82%E8%BF%B0%E3%80%81%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83%E3%80%81%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Typescript-概述、搭建环境、常用类型"><a href="#Typescript-概述、搭建环境、常用类型" class="headerlink" title="Typescript 概述、搭建环境、常用类型"></a>Typescript 概述、搭建环境、常用类型</h1><h2 id="一、TypeScript-介绍"><a href="#一、TypeScript-介绍" class="headerlink" title="一、TypeScript 介绍"></a>一、TypeScript 介绍</h2><h3 id="1-1-TypeScript-是什么"><a href="#1-1-TypeScript-是什么" class="headerlink" title="1.1 TypeScript 是什么"></a>1.1 TypeScript 是什么</h3><ul><li><strong>TypeScript（简称：TS）是 JavaScript 的超集（JS 有的 TS 都有）</strong> </li><li><strong>TypeScript &#x3D; Type + JavaScript（在 JS 基础之上，为 JS 添加了类型支持）</strong> </li><li><strong>TypeScript 是微软开发的开源编程语言，可以在任何运行 JavaScript 的地方运行</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TypeScript代码:有明确的类型，即: number (数值类型)</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">age1</span>:number = <span class="number">18</span></span><br><span class="line"><span class="comment">// JavaScript 代码:无明确的类型</span></span><br><span class="line"><span class="keyword">let</span> age2 = <span class="number">18</span></span><br></pre></td></tr></table></figure><h3 id="1-2-TypeScript-为什么要为-JS-添加类型支持？"><a href="#1-2-TypeScript-为什么要为-JS-添加类型支持？" class="headerlink" title="1.2 TypeScript 为什么要为 JS 添加类型支持？"></a>1.2 TypeScript 为什么要为 JS 添加类型支持？</h3><p>背景：JS 的类型系统存在”先天缺陷”，JS 代码中绝大部分错误都是类型错误 (Uncaught TypeError)。<br>问题：增加了找 Bug、改 Bug 的时间，严重影响开发效率。<br>从编程语言的动静来区分，TypeScript 属于静态类型的编程语言，JS属于动态类型的编程语言。<br>静态类型：编译期做类型检查<br>动态类型：执行期做类型检查<br>代码编译和代码执行的顺序：1编译 2执行。<br>对于JS来说：需要等到代码真正去执行的时候才能发现错误（晚）。<br>对于TS来说：在代码编译的时候（代码执行前）就可以发现错误（早）。<br>并且，配合 VSCode 等开发工具，TS 可以提前到在编写代码的同时就发现代码中的错误，减少找 Bug、改 Bug 时间</p><h3 id="1-3-TypeScript-相比-JS-的优势"><a href="#1-3-TypeScript-相比-JS-的优势" class="headerlink" title="1.3 TypeScript 相比 JS 的优势"></a>1.3 TypeScript 相比 JS 的优势</h3><ol><li>更早（写代码的同时）发现错误，减少找 Bug、改 Bug 时间，提升开发效率。 </li><li>程序中任何位置的代码都有代码提示，随时随地的安全感，增强了开发体验。 </li><li>强大的类型系统提升了代码的可维护性，使得重构代码更加容易。 </li><li>支特最新的 ECMAScript 语法，优先体验最新的语法，让你走在前端技术的最前沿。 </li><li>TS 类型推断机制，不需要在代码中的每个地方都显示标注类型，让你在享受优势的同时，尽量降低了成本。</li></ol><p>除此之外，Vue3 源码使用 TS 重写、Angular 默认支持 TS、React 与 TS 完美配合，TypeScript 已成为大中型前端项目的首先编程语言。</p><h2 id="二、TypeScript-环境搭建"><a href="#二、TypeScript-环境搭建" class="headerlink" title="二、TypeScript 环境搭建"></a>二、TypeScript 环境搭建</h2><h3 id="2-1-安装编译-TS-的工具包"><a href="#2-1-安装编译-TS-的工具包" class="headerlink" title="2.1 安装编译 TS 的工具包"></a>2.1 安装编译 TS 的工具包</h3><p>Node.js 和浏览器，只认识TS代码，不认识TS代码，需要安装编译TS的工具包将TS代码转化为S代<br>码，然后才能运行。<br>安装命令：<code>npm i -g typescript</code><br>typescript包：用来编译 TS 代码的包，提供了 tsc 命令，实现了 TS -&gt; JS 的转化。<br>验证是否安装成功：tsc-v (查看 typescript 的版本)。</p><h3 id="2-2-编译并运行-TS-代码"><a href="#2-2-编译并运行-TS-代码" class="headerlink" title="2.2 编译并运行 TS 代码"></a>2.2 编译并运行 TS 代码</h3><ol><li>创建 hello.ts文件（注意：TS 文件的后缀名为 .ts) </li><li>将TS编译为JS:在终端中输入命令，<code>tsc hello.ts</code> (此时，在同级目录中会出现一个同名的 JS 文件) </li><li>执行 JS 代码：在终端中输入命令，<code>node hello.js</code></li></ol><blockquote><p>所有合法的 JS 代码都是 TS 代码，有 JS 基础只需要学习 TS 的类型即可<br>由 TS 编译生成的 JS 文件，代码中就没有类型信息了</p></blockquote><h3 id="2-3-简化运行-TS-的步骤"><a href="#2-3-简化运行-TS-的步骤" class="headerlink" title="2.3 简化运行 TS 的步骤"></a>2.3 简化运行 TS 的步骤</h3><p>每次修改代码后，都要重复执行两个命令，才能运行 TS 代码，太繁琐使用 ts-node 包，直接在 Node.js 中执行 TS 代码</p><p>安装命令：<code>npm i -g ts-code</code> (ts-node 包提供了 ts-node 命令)</p><p>使用方式：<code>ts-node hello.ts</code></p><p>ts-node 命令在内部偷偷的将 TS&gt;JS，然后，再运行 JS 代码</p><h2 id="三、TypeScript-常用类型"><a href="#三、TypeScript-常用类型" class="headerlink" title="三、TypeScript 常用类型"></a>三、TypeScript 常用类型</h2><p><strong>类型概述</strong></p><p>TypeScript 是 JS 的超集，TS 提供了 JS 的所有功能，并且额外的增加了：<strong>类型系统</strong>。</p><ul><li>所有的 JS 代码都是 TS 代码。</li><li>JS 类型（比如 number&#x2F;string 等），但是 JS 不会检查变量的类型是否发生变化。而 TS 会检查。</li></ul><p>TypeScript 类型系统的主要优势：可以显示标记出代码中的意外行为，从而降低了发生错误的可能性。</p><h3 id="3-1-类型注解"><a href="#3-1-类型注解" class="headerlink" title="3.1 类型注解"></a>3.1 类型注解</h3><p><strong>示例代码：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">age</span>: number = <span class="number">18</span></span><br></pre></td></tr></table></figure><p>代码中的 <code>：number</code> 就是类型注解<br>为变量添加类型约束。上述代码中，约定变量 age 的类型为 number (数值类型)<br>约定了什么类型，就只能给变量赋值该类型的值，否则，就会报错</p><h3 id="3-2-常用基础类型概述"><a href="#3-2-常用基础类型概述" class="headerlink" title="3.2 常用基础类型概述"></a>3.2 常用基础类型概述</h3><p>可以将 TS 中的常用基础类型细分为两类： JS 已有类型 和TS 新增类型</p><ol><li>JS 已有类型</li></ol><ul><li>原始类型：number&#x2F;string&#x2F;boolean&#x2F;null&#x2F;undefined&#x2F;symbol </li><li>对象类型：object（包括，数组、对象、函数等对象）</li></ul><ol start="2"><li>TS 新增类型</li></ol><ul><li>联合类型、自定义类型（类型别名）、接口、元组、字面量类型、枚举、void、any 等</li></ul><h3 id="3-3-原始类型"><a href="#3-3-原始类型" class="headerlink" title="3.3 原始类型"></a>3.3 原始类型</h3><p>原始类型：number &#x2F;string &#x2F;boolean &#x2F;null &#x2F;undefined &#x2F;symbol</p><p>特点：简单。这些类型，可以按照  JS 中类型的名称来书写。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">age</span>: <span class="built_in">number</span> = <span class="number">18</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">pname</span>: <span class="built_in">string</span> = <span class="string">&#x27;张三&#x27;</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">flag</span>: <span class="built_in">boolean</span> = <span class="literal">true</span></span><br><span class="line"><span class="comment">// 等等...</span></span><br></pre></td></tr></table></figure><h3 id="3-4-数组类型"><a href="#3-4-数组类型" class="headerlink" title="3.4 数组类型"></a>3.4 数组类型</h3><p>对象类型：object（包括，数组、对象、函数等对象）</p><p>对象类型，在 TS 中更加细化，每个具体的对象都有自己的类型语法</p><p>数组类型的两种写法：（推荐使用 number[] 写法）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">numbers</span>: number[] = [ <span class="number">1</span> , <span class="number">2</span> , <span class="number">3</span> , <span class="number">4</span> , <span class="number">5</span> ]</span><br><span class="line"><span class="keyword">let</span> <span class="attr">strings</span>: <span class="title class_">Array</span>&lt;string&gt; = [<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;world&#x27;</span>]</span><br></pre></td></tr></table></figure><p>如果数组中既有 number 类型，又有 string 类型 ，那么可以使用 <strong>联合类型</strong> 。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">list</span>: (number | string)[] = [ <span class="number">1</span> , <span class="string">&#x27;hello&#x27;</span>, <span class="number">2</span> , <span class="string">&#x27;world&#x27;</span>]</span><br></pre></td></tr></table></figure><p>“|” （竖线）在 TS 中叫做联合类型（由两个或多个其他类型组成的类型，表示可以是这些类型中的任意一种）</p><h3 id="3-5-类型别名"><a href="#3-5-类型别名" class="headerlink" title="3.5 类型别名"></a>3.5 类型别名</h3><p>类型别名（自定义类型），为任意类型起别名。</p><p>当同一类型（复杂）被多次使用时，可以通过类型别名，简化该类型的使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 type 关键字来创建类型别名</span></span><br><span class="line"><span class="comment">// 类型别名可以是任意合法的变量名称</span></span><br><span class="line"><span class="comment">// 创建类型别名后，直接使用该类型别名作为变量的类型注解即可</span></span><br><span class="line">type customArray = (number | string)[]</span><br><span class="line"><span class="keyword">let</span> <span class="attr">arr1</span>: customArray = [ <span class="number">1</span> , <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="number">4</span> ]</span><br><span class="line"><span class="keyword">let</span> <span class="attr">arr2</span>: customArray = [ <span class="number">1</span> , <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="number">2</span> ]</span><br></pre></td></tr></table></figure><h3 id="3-6-函数类型"><a href="#3-6-函数类型" class="headerlink" title="3.6 函数类型"></a>3.6 函数类型</h3><p>函数的类型实际上指的是 <strong>函数参数</strong> 和 <strong>返回值</strong> 的类型</p><p>为函数指定类型的两种方式：</p><ol><li>单独指定参数、返回值的类型 </li><li>同时指定参数、返回值的类型</li></ol><h4 id="3-6-1-单独指定参数、返回值的类型"><a href="#3-6-1-单独指定参数、返回值的类型" class="headerlink" title="3.6.1 单独指定参数、返回值的类型"></a>3.6.1 单独指定参数、返回值的类型</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">num1: number, num2: number</span>): number &#123;</span><br><span class="line"><span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="keyword">const</span> add = (<span class="attr">num1</span>: number, <span class="attr">num2</span>: number): <span class="function"><span class="params">number</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-6-2-同时指定参数、返回值的类型"><a href="#3-6-2-同时指定参数、返回值的类型" class="headerlink" title="3.6.2 同时指定参数、返回值的类型"></a>3.6.2 同时指定参数、返回值的类型</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">add</span>: <span class="function">(<span class="params">num1: number, num2: number</span>) =&gt;</span> number = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当函数作为表达式时，可以通过类似箭头函数形式的语法来为函数添加类型</p><blockquote><p>这种形式只适用于函数表达式</p></blockquote><p>如果函数没有返回值，那么，函数返回值类型为：void</p><h4 id="3-6-3-函数可选参数"><a href="#3-6-3-函数可选参数" class="headerlink" title="3.6.3 函数可选参数"></a>3.6.3 函数可选参数</h4><p>使用函数实现某个功能时，参数可以传也可以不传。这种情况下，在给函数参数指定类型时，需要用到<strong>可选参数</strong>。</p><p>比如，数组的 slice 方法，可以 slice(0) 也可以 slice(1) 还可以 slice(1,3)</p><p>在可传可不传的参数名称后面添加？（问号）</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mySlice</span>(<span class="params">start?: <span class="built_in">number</span>, end?: <span class="built_in">number</span></span>): <span class="built_in">void</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;起始索引：&#x27;</span>, start, <span class="string">&#x27;结束索引：&#x27;</span>, end)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可选参数只能出现在参数列表的最后，也就是说可选参数后面不能再出现必选参数</p></blockquote><h3 id="3-7-对象类型"><a href="#3-7-对象类型" class="headerlink" title="3.7 对象类型"></a>3.7 对象类型</h3><p>JS中的对象是由属性和方法构成的，而TS中对象的类型就是在描述对象的结构（有什么类型的属性和方法)。对象类型的写法：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">person</span>: &#123; <span class="attr">name</span>: <span class="built_in">string</span>; <span class="attr">age</span>: <span class="built_in">number</span>; <span class="title function_">sayHi</span>(): <span class="built_in">void</span> &#125; = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;zs&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接使用{}来描述对象结构。属性采用<strong>属性名</strong>：<strong>类型</strong>的形式；方法采用<strong>方法名()<strong>：</strong>返回值类型</strong>的形式</p><p>如果方法有参数，就在方法名后面的小括号中指定参数类型（比如：<strong>greet ( name: string ) : void</strong>)</p><p>在一行代码中指定对象的多个属性类型时，使用；（分号）来分隔</p><p>如果一行代码只指定一个属性类型（通过换行来分隔多个属性类型），可以去掉；（分号）</p><p>方法的类型也可以使用箭头函数形式<strong>（比如：{ sayHi : () &#x3D;&gt; void })</strong></p><h4 id="3-7-1-可选属性"><a href="#3-7-1-可选属性" class="headerlink" title="3.7.1 可选属性"></a>3.7.1 可选属性</h4><p>对象的属性或方法，也可以是可选的，此时需要用到可选属性。<br>比如，我们在使用 axios({ … }) 时，如果发送 GET 请求，method 属性就可以省略。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myAxios</span>(<span class="params">config: &#123; url: <span class="built_in">string</span>; method?: <span class="built_in">string</span> &#125;</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(config)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>可选属性</strong>的语法与函数可选参数的语法一致，都使用 ?（问号）来表示</p><h3 id="3-8-接口"><a href="#3-8-接口" class="headerlink" title="3.8 接口"></a>3.8 接口</h3><p>当一个对象类型被多次使用时，一般会使用接口(interface)来描述对象的类型，达到复用的目的。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 interface 关键字来声明接口</span></span><br><span class="line"><span class="comment">// 接口名称（比如，此处的 IPerson），可以是任意合法的变量名称</span></span><br><span class="line"><span class="comment">// 声明接口后，直接使用接口名称作为变量的类型</span></span><br><span class="line"><span class="comment">// 因为每一行只有一个属性类型，因此，属性类型后没有 ;（分号）</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IPerson</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">    <span class="title function_">sayHi</span>(): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">person</span>: <span class="title class_">IPerson</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;zhangsan&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">19</span> ,</span><br><span class="line">    <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>interface（接口）和 type（类型别名）的对比</strong></p><ul><li>相同点：都可以给对象指定类型</li><li>不同点 <ul><li>接口，只能为对象指定类型。</li><li>类型别名，不仅可以为对象指定类型，实际上可以为任意类型指定别名。</li></ul></li></ul><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IPerson</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line"><span class="title function_">sayHi</span>(): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 类型别名</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">IPerson</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">    <span class="title function_">sayHi</span>(): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">NumStr</span> = <span class="built_in">number</span> | <span class="built_in">string</span></span><br></pre></td></tr></table></figure><h5 id="接口继承"><a href="#接口继承" class="headerlink" title="接口继承"></a>接口继承</h5><p>比如，这两个接口都有X、y两个属性，重复写两次，比较繁琐，可以采用继承的方式来实现。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Point2D</span> &#123;</span><br><span class="line">    <span class="attr">X</span>: <span class="built_in">number</span></span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Point3D</span> &#123;</span><br><span class="line">    <span class="attr">X</span>: <span class="built_in">number</span></span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">number</span></span><br><span class="line">    <span class="attr">z</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 改造后</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Point2D</span> &#123; <span class="attr">x</span>: <span class="built_in">number</span>; <span class="attr">y</span>: <span class="built_in">number</span> &#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Point3D</span> <span class="keyword">extends</span> <span class="title class_">Point2D</span> &#123; <span class="attr">z</span>: <span class="built_in">number</span> &#125;</span><br></pre></td></tr></table></figure><p>使用 extends（继承）关键字实现了接口 Point3D 继承 Point2D<br>继承后，Point3D 就有了 Point2D 的所有属性和方法（此时，Point3D 同时有 x、y、z 三个属性）</p><h3 id="3-9-元组"><a href="#3-9-元组" class="headerlink" title="3.9 元组"></a>3.9 元组</h3><p>比如在地图中，使用经纬度坐标来标记位置信息。<br>可以使用数组来记录坐标，那么，该数组中只有两个元素，并且这两个元素都是数值类型</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">position</span>: <span class="built_in">number</span>[] = [<span class="number">39.5427</span>，<span class="number">116.2317</span> ]</span><br></pre></td></tr></table></figure><p>使用number)表示的不严谨，因为该类型的数组中可以出现任意多个数字，这时候可以采用<strong>元组(Tuple)</strong><br><strong>元组</strong>类型是另一种类型的数组，它<strong>确切地知道包含多少个元素，以及特定索引对应的类型</strong></p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 元组类型可以确切地标记出有多少个元素，以及每个元素的类型</span></span><br><span class="line"><span class="comment">// 该示例中，元素有两个元素，每个元素的类型都是 number</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">position</span>: [ <span class="built_in">number</span>, <span class="built_in">number</span>] = [ <span class="number">39.5427</span>，<span class="number">116.2317</span>]</span><br></pre></td></tr></table></figure><h3 id="3-10-类型推论"><a href="#3-10-类型推论" class="headerlink" title="3.10 类型推论"></a>3.10 类型推论</h3><p>在TS中，某些没有明确指出类型的地方，TS的<strong>类型推论机制会帮助提供类型。</strong><br>由于类型推论的存在，这些地方，类型注解可以省略不写！<br>发生类型推论的2种常见场景：</p><ol><li>声明变量并初始化时</li><li>决定函数返回值时</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/760851/1684217517870-adcbdaf8-61dc-4be0-a43b-755323af79e6.png#averageHue=%23fcfcfc&clientId=u9a070cde-6f07-4&from=paste&height=72&id=ubf97444a&originHeight=108&originWidth=310&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=2897&status=done&style=none&taskId=u81c53a9a-83be-4b68-ace8-a831514a9e6&title=&width=206.66666666666666" alt="image.png"></p><blockquote><p>鼠标移入变量名称age,TS自动推断出变量age为number类型</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2023/png/760851/1684217523133-142fedfd-6c63-4c54-8aba-5e37e53ad412.png#averageHue=%23fbfbfa&clientId=u9a070cde-6f07-4&from=paste&height=87&id=u2771941f&originHeight=130&originWidth=602&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=7867&status=done&style=none&taskId=uaa6d38cd-3ae5-4db7-808a-498405e22d9&title=&width=401.3333333333333" alt="image.png"><br>这两种情况下，类型注解可以省略不写<br>能省略类型注解的地方就省略(“偷懒”，充分利用TS类型推论的能力，提升开发效率)</p><blockquote><p>如果不知道类型，可以通过鼠标放在变量名称上，利用VSCode的提示来查看类型</p></blockquote><h3 id="3-11-类型断言"><a href="#3-11-类型断言" class="headerlink" title="3.11 类型断言"></a>3.11 类型断言</h3><p>有时候你会比TS更加明确一个值的类型，此时，可以使用类型断言来指定更具体的类型<br><img src="https://cdn.nlark.com/yuque/0/2023/png/760851/1684217572397-4435b314-974a-415f-ab35-c616f6f92b4a.png#averageHue=%23f9f8f7&clientId=u150173ce-c6a1-4&from=paste&height=56&id=u1e96dd04&originHeight=84&originWidth=469&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=5872&status=done&style=none&taskId=ue82d76ea-83dc-4e8d-bbcd-2ca0df5ece1&title=&width=312.6666666666667" alt="image.png"><br><strong>注意：</strong>getElementByld 方法返回值的类型是 HTMLElement，该类型只包含所有标签公共的属性或方法，不包含 a 标签特有的 href 等属性<br>因此，这个<strong>类型大宽泛（不具体）</strong>，无法操作 href 等 a 标签特有的属性或方法。<br>解决方式：这种情况下就需要使用<strong>类型断言</strong>指定更加具体的类型。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/760851/1684217582560-8f8d9655-964b-4dc3-a809-28e2020efff2.png#averageHue=%23fcfbfb&clientId=u150173ce-c6a1-4&from=paste&height=72&id=u70e0f6b0&originHeight=108&originWidth=726&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=8133&status=done&style=none&taskId=u8040af66-2578-4b71-8f71-42a1f4ad2d4&title=&width=484" alt="image.png"><br>使用 as 关键字实现类型断言<br>关键字 as 后面的类型是一个更加具体的类型(HTMLAnchorElement 是 HTMLElement 的子类型)<br>通过类型断言，aLik 的类型变得更加具体，这样就可以访问 a 标签特有的属性或方法了<br><strong>第二种写法：</strong>使用 &lt;&gt; 语法<br><img src="https://cdn.nlark.com/yuque/0/2023/png/760851/1684217597880-580890e2-bd79-46f7-a339-422a6aeee5eb.png#averageHue=%23fbfbfa&clientId=u150173ce-c6a1-4&from=paste&height=67&id=uda22288e&originHeight=100&originWidth=659&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=8042&status=done&style=none&taskId=uaa2d6c4c-1d54-413b-b191-3336b996242&title=&width=439.3333333333333" alt="image.png"></p><blockquote><p>在浏览器控制台，通过 console..dir() 打印 DOM 元素，在属性列表的最后面，即可看到该元素的类型</p></blockquote><h3 id="3-12-字面量类型"><a href="#3-12-字面量类型" class="headerlink" title="3.12 字面量类型"></a>3.12 字面量类型</h3><p>例如：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str1 = <span class="string">&#x27;Hello TS&#x27;</span></span><br><span class="line"><span class="keyword">const</span> str2 = <span class="string">&#x27;Hello TS&#x27;</span></span><br></pre></td></tr></table></figure><p>通过TS类型推论机制，可以得到</p><ul><li>变量str1的类型为：string</li><li>常量str2的类型为：Hello TS</li></ul><p>str1是一个变量 (Iet)，它的值可以是任意字符串，所以类型为：string<br>str2是一个常量 (const)，它的值不能变化只能是 ‘Hello TS’ ，所以，它的类型为：’Hello TS’</p><blockquote><p>此处的Hello TS’,就是一个字面量类型。也就是说某个特定的字符串也可以作为TS中的类型<br>除字符串外，任意的S字面量（比如，对象、数字等）都可以作为类型使用</p></blockquote><p><strong>字面量类型配合联合类型一起使用</strong>，用来表示一组明确的可选值列表<br>比如：在贪吃蛇游戏中，游戏的方向的可选值只能是上、下、左、右中的任意一个</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">changeDirection</span>(<span class="params">direction: <span class="string">&#x27; up&#x27;</span> | <span class="string">&#x27; down&#x27;</span> | <span class="string">&#x27;left&#x27;</span> | <span class="string">&#x27; right&#x27;</span></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(direction)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释：参数direction的值只能是up&#x2F;down&#x2F;left&#x2F;.right中的任意一个。<br>优势：相比于string类型，使用字面量类型更加精确、严谨。</p><h3 id="3-13-枚举"><a href="#3-13-枚举" class="headerlink" title="3.13 枚举"></a>3.13 枚举</h3><p>枚举的功能类似于字面量类型+联合类型组合的功能，也可以表示一组明确的可选值。<br>枚举：定义一组命名常量。它描述一个值，该值可以是这些命名常量中的一个。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 enum 关键字定义枚举</span></span><br><span class="line"><span class="comment">// 约定枚举名称、枚举中的值以大写字母开头</span></span><br><span class="line"><span class="comment">// 枚举中的多个值之间通过 ,（逗号）分隔</span></span><br><span class="line"><span class="comment">// 定义好枚举后，直接使用枚举名称作为类型注解</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">    <span class="title class_">Up</span>,</span><br><span class="line">    <span class="title class_">Down</span>,</span><br><span class="line">    <span class="title class_">Left</span>,</span><br><span class="line">    <span class="title class_">Right</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">changeDirection</span>(<span class="params">direction: Direction</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(direction)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：形参 direction 的类型为枚举 Direction，那么，实参的值就应该是枚举 Direction 成员的任意一个。<br>访问枚举成员：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">changeDirection</span>(<span class="params">direction: Direction</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(direction)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 类似于 JS 中的对象，直接通过点（.）语法访问枚举的成员</span></span><br><span class="line"><span class="title function_">changeDirection</span>(<span class="title class_">Direction</span>.<span class="property">Up</span>)</span><br></pre></td></tr></table></figure><p>问题：我们把枚举成员作为了函数的实参，它的值是什么？<br><img src="https://cdn.nlark.com/yuque/0/2023/png/760851/1684217666549-1edcb26b-a4b4-4981-9a89-fba57e063061.png#averageHue=%23fcfbfa&clientId=u150173ce-c6a1-4&from=paste&height=98&id=ud51fb4a7&originHeight=147&originWidth=574&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=10965&status=done&style=none&taskId=u5daf275e-6289-4811-beb5-5f3d19f8d0a&title=&width=382.6666666666667" alt="image.png"><br>通过将鼠标移入 Direction.Up，可以看到枚举成员 Up的值为 0<br>枚举成员是有值的，默认为：从 0 开始自增的数值<br>枚举成员的值为数字的枚举，称为：<strong>数字枚举</strong><br>也可以给枚举中的成员初始化值，例如</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Down -&gt; 11、 Left -&gt; 12、 Right -&gt; 13</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">    <span class="title class_">Up</span> = <span class="number">10</span>,</span><br><span class="line">    <span class="title class_">Down</span>,</span><br><span class="line">    <span class="title class_">Left</span>,</span><br><span class="line">    <span class="title class_">Right</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">    <span class="title class_">Up</span> = <span class="number">10</span>,</span><br><span class="line">    <span class="title class_">Down</span> = <span class="number">20</span>,</span><br><span class="line">    <span class="title class_">Left</span> = <span class="number">30</span>,</span><br><span class="line">    <span class="title class_">Right</span> = <span class="number">40</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>字符串枚举</strong>：枚举成员的值是字符串</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">    <span class="title class_">Up</span> = <span class="string">&#x27;Up&#x27;</span>,</span><br><span class="line">    <span class="title class_">Down</span> = <span class="string">&#x27;Down&#x27;</span>,</span><br><span class="line">    <span class="title class_">Left</span> = <span class="string">&#x27;Left&#x27;</span>,</span><br><span class="line">    <span class="title class_">Right</span> = <span class="string">&#x27;Right&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>字符串枚举没有自增长行为，因此，字符串枚举的每个成员必须有初始值</p></blockquote><p>枚举是TS为数不多的非 JavaScript 类型级扩展（不仅仅是类型）的特性之一<br>因为：其他类型仅仅被当做类型，而枚举不仅用作类型，还提供值（枚举成员都是有值的）<br>也就是说，其他的类型会在编译为 JS 代码时自动移除。但是，枚举类型会被编译为 JS 代码！</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译前TS代码</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">    <span class="title class_">Up</span> = <span class="string">&#x27;Up&#x27;</span>,</span><br><span class="line">    <span class="title class_">Down</span> = <span class="string">&#x27;Down&#x27;</span>,</span><br><span class="line">    <span class="title class_">Left</span> = <span class="string">&#x27;Left&#x27;</span>,</span><br><span class="line">    <span class="title class_">Right</span> = <span class="string">&#x27;Right&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译后JS代码</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Direction</span>;</span><br><span class="line">(<span class="keyword">function</span> (<span class="params">Direction</span>) &#123;</span><br><span class="line">    <span class="title class_">Direction</span>[<span class="string">&quot;Up&quot;</span>] = <span class="string">&quot;Up&quot;</span>;</span><br><span class="line">    <span class="title class_">Direction</span>[<span class="string">&quot;Down&quot;</span>] = <span class="string">&quot;Down&quot;</span>;</span><br><span class="line">    <span class="title class_">Direction</span>[<span class="string">&quot;Left&quot;</span>] = <span class="string">&quot;Left&quot;</span>;</span><br><span class="line">    <span class="title class_">Direction</span>[<span class="string">&quot;Right&quot;</span>] = <span class="string">&quot;Right&quot;</span>;</span><br><span class="line">&#125;)(<span class="title class_">Direction</span> || (<span class="title class_">Direction</span> = &#123;&#125;));</span><br></pre></td></tr></table></figure><p>枚举与前面讲到的字面量类型+联合类型组合的功能类似，都用来表示一组明确的可选值列表<br>一般情况下，推荐使用字面量类型+联合类型组合的方式，因为相比枚举，这种方式更加直观、简洁、高效</p><h3 id="3-14-any-类型"><a href="#3-14-any-类型" class="headerlink" title="3.14 any 类型"></a>3.14 any 类型</h3><p>原则：不推荐使用 any ! 这会让 TypeScript 变为 “AnyScript” (失去TS类型保护的优势)。<br>因为当值的类型为 any 时，可以对该值进行任意操作，并且不会有代码提示。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">obj</span>: <span class="built_in">any</span> = &#123; <span class="attr">x</span>: <span class="number">0</span> &#125;</span><br><span class="line">obj.<span class="property">bar</span> = <span class="number">100</span></span><br><span class="line"><span class="title function_">obj</span>()</span><br><span class="line"><span class="keyword">const</span> <span class="attr">n</span>: <span class="built_in">number</span> = obj</span><br></pre></td></tr></table></figure><p>解释：以上操作都不会有任何类型错误提示，即使可能存在错误！<br>尽可能的避免使用 any 类型，除非临时使用 any 来“”避免”书写很长、很复杂的类型！<br>其他隐式具有 any 类型的情况：</p><ol><li>声明变量不提供类型也不提供默认值</li><li>函数参数不加类型</li></ol><p>注意：因为不推荐使用ay,所以，这两种情况下都应该提供类型！</p><h3 id="3-15-typeof"><a href="#3-15-typeof" class="headerlink" title="3.15 typeof"></a>3.15 typeof</h3><p>众所周知，JS中提供了typeof操作符，用来在S中获取数据的类型。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="string">&#x27;hello world&#x27;</span>) <span class="comment">// 打印 string</span></span><br></pre></td></tr></table></figure><p>实际上，TS也提供了typeof操作符：可以在类型上下文中引用变量或属性的类型（类型查询）。<br>使用场景：根据已有变量的值，获取该值的类型，来简化类型书写。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">formatPoint</span>(<span class="params">point: &#123; x: <span class="built_in">number</span>; y: <span class="built_in">number</span> &#125;</span>) &#123;&#125;</span><br><span class="line"><span class="title function_">formatPoint</span>(p)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">formatPoint</span>(<span class="params">point: <span class="keyword">typeof</span> p</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><p>解释：</p><ol><li>使用 typeof 操作符来获取变量 p 的类型，结果与第一种（对象字面量形式的类型）相同。</li><li>typeof 出现在类型注解的位置（参数名称的冒号后面）所处的环境就在类型上下文（区别于 JS 代码)。</li><li>注意：typeof 只能用来查询变量或属性的类型，无法查询其他形式的类型（比如，函数调用的类型)</li></ol><h2 id="四、TypeScript高级类型"><a href="#四、TypeScript高级类型" class="headerlink" title="四、TypeScript高级类型"></a>四、TypeScript高级类型</h2><p><strong>概述</strong><br>TS中的高级类型有很多，重点学习以下高级类型：</p><ol><li>class类</li><li>类型兼容性</li><li>交叉类型</li><li>泛型和keyof</li><li>索引签名类型和索引查询类型</li><li>映射类型</li></ol><h3 id="4-1-class-类"><a href="#4-1-class-类" class="headerlink" title="4.1 class 类"></a>4.1 class 类</h3><p>TypeScript全面支持ES2015中引入的class关键字，并为其添加了类型注解和其他语法（比如，可见性修饰符等)<br><img src="https://cdn.nlark.com/yuque/0/2023/png/760851/1684217802850-36cf0124-c32a-4f03-ad52-9243d617b742.png#averageHue=%23fcfcfc&clientId=u150173ce-c6a1-4&from=paste&height=77&id=uac143007&originHeight=115&originWidth=356&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=4843&status=done&style=none&taskId=u412a6161-0106-4934-b40a-c21757efa46&title=&width=237.33333333333334" alt="image.png"><br>解释：<br>1.根据TS中的类型推论，可以知道Person类的实例对象p的类型是Person.。<br>2.TS中的class,不仅提供了class的语法功能，也作为一种类型存在。<br><strong>实例属性初始化：</strong></p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">    gender = <span class="string">&#x27;男&#x27;</span> <span class="comment">// gender: string = &#x27;男&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释：</p><ol><li>声明成员age,类型为number(没有初始值)。</li><li>声明成员gender,并设置初始值，此时，可省略类型注解(TS类型推论为string类型)</li></ol><p><strong>构造函数：</strong></p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">    <span class="attr">gender</span>: <span class="built_in">string</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">age: <span class="built_in">number</span>, gender: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">gender</span> = gender</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释：</p><ol><li>成员初始化（比如，age:number)后，才可以通过this.age来访问实例成员。</li><li>需要为构造函数指定类型注解，否则会被隐式推断为ay;构造函数不需要返回值类型。</li></ol><p><strong>实例方法：</strong></p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    x = <span class="number">10</span></span><br><span class="line">    y = <span class="number">10</span></span><br><span class="line">    </span><br><span class="line">    <span class="title function_">scale</span>(<span class="attr">n</span>: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">x</span> *= n</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">y</span> *= n</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：方法的类型注解（参数和返回值）与函数用法相同<br><strong>类继承</strong><br>类的继承有两种方式：extends(继承父类)和implements(实现接口)。<br>JS 中只有 <code>extends</code>，而 <code>implements</code> 是 TS 提供的。<br><strong>extends</strong></p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// extends 继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="title function_">move</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Move&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 extends 关键字实现继承</span></span><br><span class="line"><span class="comment">// 子类 Dog 继承父类 Animal，则 Dog 的实例对象 dog 就同时具有了父类 Animal 和 子类 Dog 的</span></span><br><span class="line">所有属性和方法。</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">    <span class="title function_">back</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;旺旺旺&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> dog = <span class="keyword">new</span> <span class="title class_">Dog</span>()</span><br></pre></td></tr></table></figure><p><strong>implements</strong></p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Singable</span> &#123;</span><br><span class="line"><span class="title function_">sing</span>(): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过 implements 关键字让 class 实现接口</span></span><br><span class="line"><span class="comment">// Person 类实现接口 Singable 意味着，Person 类中必须提供 Singable 接口中指定的所有方法和属性。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Singable</span> &#123;</span><br><span class="line">    <span class="title function_">sing</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;缓缓飘落的枫叶像思念&#x27;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>访问修饰符</strong><br>类成员可见性：可以使用 TS 来<strong>控制 class 的方法或属性对于 class 外的代码是否可见。</strong><br>可见性修饰符包括：</p><ol><li>public(公有的)</li><li>protected(受保护的)</li><li>private(私有的)</li></ol><p><strong>public</strong>：表示公有的、<strong>公开的，公有成员可以被任何地方访问</strong>，默认可见性</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="comment">// 在类属性或方法前面添加 public 关键字，来修饰该属性或方法是共有的</span></span><br><span class="line"><span class="comment">// 因为 public 是默认可见性，所以，可以直接省略</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">move</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Moving along!&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>protected</strong>：表示受保护的，仅对其声明所在类和子类中（非实例对象）可见</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>：表示私有的，只在当前类中可见，对实例对象以及子类也是不可见的<span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">move</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Moving along!&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在类属性或方法前面添加 protected 关键字，来修饰该属性或方法是受保护的</span></span><br><span class="line"><span class="comment">// 在子类的方法内部可以通过 this 来访问父类中受保护的成员，但是，对实例不可见！</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line"><span class="title function_">bark</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;叫~~~&#x27;</span>)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">move</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>private</strong>：表示私有的，只在当前类中可见，对实例对象以及子类也是不可见的</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">move</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Moving along!&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">walk</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">move</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在类属性或方法前面添加 private 关键字，来修饰该属性或方法是私有的</span></span><br><span class="line"><span class="comment">// 私有的属性或方法只在当前类中可见，对子类和实例对象也都是不可见的！</span></span><br></pre></td></tr></table></figure><p>除了可见性修饰符之外，还有一个常见修饰符就是：readonly (只读修饰符)<br>readonly：表示只读，用来防止在构造函数之外对属性进行赋值。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">age</span>: <span class="built_in">number</span> = <span class="number">18</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用 readonly 关键字修饰该属性是只读的，注意只能修饰属性不能修饰方法</span></span><br><span class="line"><span class="comment">// 注意：属性 age 后面的类型注解（比如，此处的 number）如果不加，则 age 的类型为 18 （字面量</span></span><br><span class="line">类型）</span><br><span class="line"><span class="comment">// 接口或者 &#123;&#125; 表示的对象类型，也可以使用 readonly</span></span><br></pre></td></tr></table></figure><h3 id="4-2-类型兼容性"><a href="#4-2-类型兼容性" class="headerlink" title="4.2 类型兼容性"></a>4.2 类型兼容性</h3><p>两种类型系统：</p><ol><li>Structural Type System (结构化类型系统)</li><li>Nominal Type System (标明类型系统)</li></ol><p>TS采用的是结构化类型系统，也叫做 duck typing (鸭子类型)，类型检查关注的是值所具有的形状<br>也就是说，在结构类型系统中，如果两个对象具有相同的形状，则认为它们属于同一类型</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">number</span></span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point2D</span> &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">number</span></span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">p</span>: <span class="title class_">Point</span> = <span class="keyword">new</span> <span class="title class_">Point2D</span>()</span><br><span class="line"><span class="comment">// Point 和 Point2D 是两个名称不同的类</span></span><br><span class="line"><span class="comment">// 变量 p 的类型被显示标注为 Point 类型，但是，它的值却是 Point2D 的实例，并且没有类型错误</span></span><br><span class="line"><span class="comment">// 因为 TS 是结构化类型系统，只检查 Point 和 Point2D 的结构是否相同（相同，都具有 x 和 y 两个属性，属性类型也相同）</span></span><br><span class="line"><span class="comment">// 但是，如果在 Nominal Type System 中（比如，C#、Java 等），它们是不同的类，类型无法兼容</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：在结构化类型系统中，如果两个对象具有相同的形状，则认为它们属于同一类型，这种说法并不准确</p></blockquote><p>更准确的说法：对于对象类型来说，y 的成员至少与 x 相同，则 x 兼容 y（成员多的可以赋值给少的）</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">number</span></span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point3D</span> &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">number</span></span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">number</span></span><br><span class="line">    <span class="attr">Z</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">p</span>: <span class="title class_">Point</span> = <span class="keyword">new</span> <span class="title class_">Point3D</span>()</span><br><span class="line"><span class="comment">// Point3D 的成员至少与 Point 相同，则 Point 兼容 Point3D</span></span><br><span class="line"><span class="comment">// 所以，成员多的 Point3D 可以赋值给成员少的 Point</span></span><br></pre></td></tr></table></figure><p>除了 class 之外，TS 中的其他类型也存在相互兼容的情况，包括： <strong>接口兼容性</strong> 、 <strong>函数兼容性</strong> 等接口兼容性<br><strong>接口之间的兼容性，类似于 class</strong> 。并且，class 和 interface 之间也可以兼容。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="attr">X</span>: <span class="built_in">number</span></span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Point2D</span> &#123;</span><br><span class="line">    <span class="attr">X</span>: <span class="built_in">number</span></span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">p1</span>: <span class="title class_">Point</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">p2</span>: <span class="title class_">Point2D</span> = p1</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Point3D</span> &#123;</span><br><span class="line">    <span class="attr">X</span>: <span class="built_in">number</span></span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">number</span></span><br><span class="line">    <span class="attr">z</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">p3</span>: <span class="title class_">Point3D</span></span><br><span class="line">p2 = p3</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point3D</span> &#123;</span><br><span class="line">    <span class="attr">X</span>: <span class="built_in">number</span></span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">number</span></span><br><span class="line">    <span class="attr">Z</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">p3</span>: <span class="title class_">Point2D</span> = <span class="keyword">new</span> <span class="title class_">Point3D</span>()</span><br></pre></td></tr></table></figure><p><strong>函数之间兼容性比较复杂</strong>，需要考虑：1、参数个数2、参数类型3、返回值类型<br><strong>参数个数</strong>，参数多的兼容参数少的（或者说，<strong>参数少的可以赋值给多的</strong>）</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="variable constant_">F1</span> = <span class="function">(<span class="params">a: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">void</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">F2</span> = <span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">void</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">f1</span>: <span class="variable constant_">F1</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">f2</span>: <span class="variable constant_">F2</span> = f1</span><br></pre></td></tr></table></figure><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">arr.<span class="title function_">forEach</span>(<span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line">arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>参数少的可以赋值给参数多的，所以，f1 可以赋值给 f2<br>数组forEach方法的第一个参数是回调函数，该示例中类型为：(value: string, index: number, array: string [] ) &#x3D;&gt; void<br>在 JS 中省略用不到的函数参数实际上是很常见的，这样的使用方式，促成了TS中函数类型之间的兼容性<br>并目因为回调函数是有类型的，所以，TS会自动推导出参数item、index、array的类型</p></blockquote><p><strong>参数类型</strong>，相同位置的参数类型要相同（原始类型）或兼容（对象类型）</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="variable constant_">F1</span> = <span class="function">(<span class="params">a: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">string</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">F2</span> = <span class="function">(<span class="params">a: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">string</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">f1</span>: <span class="variable constant_">F1</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">f2</span>: <span class="variable constant_">F2</span> = f1</span><br></pre></td></tr></table></figure><p>解释：函数类型 F2 兼容函数类型 F1，因为 F1 和 F2 的第一个参数类型相同。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Point2D</span> &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">number</span></span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Point3D</span> &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">number</span></span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">number</span></span><br><span class="line">    <span class="attr">Z</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">F2</span> = <span class="function">(<span class="params">p: Point2D</span>) =&gt;</span> <span class="built_in">void</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">F3</span> = <span class="function">(<span class="params">p: Point3D</span>) =&gt;</span> <span class="built_in">void</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">f2</span>: <span class="variable constant_">F2</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">f3</span>: <span class="variable constant_">F3</span> = f2</span><br><span class="line">f2 = f3</span><br></pre></td></tr></table></figure><blockquote><p>注意，此处与前面讲到的接口兼容性冲突<br>技巧：将对象拆开，把每个属性看做一个个参数，则，参数少的（f2）可以赋值给参数多的（f3）</p></blockquote><p><strong>返回值类型</strong> ，只关注返回值类型本身即可</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="variable constant_">F5</span> = <span class="function">() =&gt;</span> <span class="built_in">string</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">F6</span> = <span class="function">() =&gt;</span> <span class="built_in">string</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">f5</span>: <span class="variable constant_">F5</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">f6</span>: <span class="variable constant_">F6</span> = f5</span><br></pre></td></tr></table></figure><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="variable constant_">F7</span> = <span class="function">() =&gt;</span> &#123; <span class="attr">name</span>: <span class="built_in">string</span> &#125;</span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">F8</span> = <span class="function">() =&gt;</span> &#123; <span class="attr">name</span>: <span class="built_in">string</span>; <span class="attr">age</span>: <span class="built_in">number</span> &#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">f7</span>: <span class="variable constant_">F7</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">f8</span>: <span class="variable constant_">F8</span></span><br><span class="line">f7 = f8</span><br></pre></td></tr></table></figure><blockquote><p>如果返回值类型是原始类型，此时两个类型要相同，比如，左侧类型 F5 和 F6<br>如果返回值类型是对象类型，此时成员多的可以赋值给成员少的，比如，右侧类型 F7 和 F8</p></blockquote><h3 id="4-3-交叉类型"><a href="#4-3-交叉类型" class="headerlink" title="4.3 交叉类型"></a>4.3 交叉类型</h3><p>交叉类型（&amp;）：功能类似于接口继承（extends），用于组合多个类型为一个类型（常用于对象类型）。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Contact</span> &#123;</span><br><span class="line"><span class="attr">phone</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PersonDetail</span> = <span class="title class_">Person</span> &amp; <span class="title class_">Contact</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">obj</span>: <span class="title class_">PersonDetail</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;jack&#x27;</span>,</span><br><span class="line">    <span class="attr">phone</span>: <span class="string">&#x27;150......&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用交叉类型后，新的类型 PersonDetail 就同时具备了 Person 和 Contact 的所有属性类型</p></blockquote><p><strong>相当于</strong></p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">PersonDetail</span> = &#123; <span class="attr">name</span>: <span class="built_in">string</span>; <span class="attr">phone</span>: <span class="built_in">string</span> &#125;</span><br></pre></td></tr></table></figure><p>交叉类型（&amp;）和接口继承（extends）的对比<br>相同点：都可以实现对象类型的组合<br>不同点：两种方式实现类型组合时，对于同名属性之间，处理类型冲突的方式不同</p><h3 id="4-4-泛型"><a href="#4-4-泛型" class="headerlink" title="4.4 泛型"></a>4.4 泛型</h3><p>泛型是可以在保证类型安全前提下，让函数等与多种类型一起工作，从而实现复用，常用于：函数、接<br>口、class 中。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">id</span>(<span class="params">value: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需求：创建一个 id 函数，传入什么数据就返回该数据本身（也就是说，参数和返回值类型相同）。<br>比如，id(10) 调用以上函数就会直接返回 10 本身。但是，该函数只接收数值类型，无法用于其他类型。<br>为了能让函数能够接受任意类型，可以将参数类型修改为 any。但是，这样就失去了 TS 的类型保护，类<br>型不安全。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">id</span>(<span class="params">value: <span class="built_in">any</span></span>): <span class="built_in">any</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泛型在保证类型安全（不丢失类型信息）的同时，可以让函数等与多种不同的类型一起工作，灵活可复<br>用。<br>实际上，在 C＃和 Java 等编程语言中，泛型都是用来实现可复用组件功能的主要工具之一。</p><p><strong>创建泛型函数</strong></p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> id&lt;<span class="title class_">Type</span>&gt;(<span class="attr">value</span>: <span class="title class_">Type</span>): <span class="title class_">Type</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在函数名称的后面添加 &lt;&gt;（尖括号），尖括号中添加类型变量，比如此处的 Type</span></span><br><span class="line"><span class="comment">// 类型变量 Type，是一种特殊类型的变量，它处理类型而不是值</span></span><br><span class="line"><span class="comment">// 该类型变量相当于一个类型容器，能够捕获用户提供的类型（具体是什么类型由用户调用该函数时指定）</span></span><br><span class="line"><span class="comment">// 因为 Type 是类型，因此可以将其作为函数参数和返回值的类型，表示参数和返回值具有相同的类型</span></span><br><span class="line"><span class="comment">// 类型变量 Type，可以是任意合法的变量名称</span></span><br></pre></td></tr></table></figure><p><strong>调用泛型函数</strong></p><p>同样，如果传入类型 string，函数 id 参数和返回值的类型就都是 string。<br>这样，通过泛型就做到了让 id 函数与多种不同的类型一起工作，实现了复用的同时保证了类型安全。</p><p><strong>简化调用泛型函数</strong></p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="title function_">id</span>(<span class="string">&#x27;200&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> str = <span class="title function_">id</span>(<span class="number">10</span>)</span><br><span class="line"><span class="comment">// 在调用泛型函数时，可以省略 &lt;类型&gt; 来简化泛型函数的调用</span></span><br><span class="line"><span class="comment">// 此时，TS 内部会采用一种叫做类型参数推断的机制，来根据传入的实参自动推断出类型变量 Type 的类型</span></span><br><span class="line"><span class="comment">// 比如，传入实参 10，TS 会自动推断出变量 num 的类型 number，并作为 Type 的类型</span></span><br></pre></td></tr></table></figure><p>推荐：使用这种简化的方式调用泛型函数，使代码更短，更易于阅读。</p><p>说明：当编译器无法推断类型或者推断的类型不准确时，就需要显式地传入类型参数。</p><p>泛型约束 ：默认情况下，泛型函数的类型变量 Type 可以代表多个类型，这导致无法访问任何属性。<br>比如，id(‘a’) 调用函数时获取参数的长度：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> id&lt;<span class="title class_">Type</span>&gt;(<span class="attr">value</span>: <span class="title class_">Type</span>): <span class="title class_">Type</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value.<span class="property">length</span>)</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Type 可以代表任意类型，无法保证一定存在 length 属性，比如 number 类型就没有 length。</span></span><br><span class="line"><span class="comment">// 需要为泛型添加约束来收缩类型（缩窄类型取值范围）</span></span><br></pre></td></tr></table></figure><p>添加泛型约束收缩类型，主要有以下两种方式：</p><ol><li><p>指定更加具体的类型</p></li><li><p>添加约束</p></li></ol><p><strong>指定更加具体的类型</strong></p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> id&lt;<span class="title class_">Type</span>&gt;(<span class="attr">value</span>: <span class="title class_">Type</span>[]): <span class="title class_">Type</span>[] &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value.<span class="property">length</span>)</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将类型修改为 Type[]（Type 类型的数组），因为只要是数组就一定存在 length 属性，因此就可以访问了</span></span><br></pre></td></tr></table></figure><p><strong>添加约束</strong></p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Ilength</span> &#123;</span><br><span class="line">    <span class="attr">length</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> id&lt;<span class="title class_">Type</span> <span class="keyword">extends</span> <span class="title class_">Ilength</span>&gt;(<span class="attr">value</span>: <span class="title class_">Type</span>): <span class="title class_">Type</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value.<span class="property">length</span>)</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建描述约束的接口 ILength，该接口要求提供 length 属性</span></span><br><span class="line"><span class="comment">// 通过 extends 关键字使用该接口，为泛型（类型变量）添加约束</span></span><br><span class="line"><span class="comment">// 该约束表示：传入的类型必须具有 length 属性</span></span><br></pre></td></tr></table></figure><blockquote><p>传入的实参（比如，数组）只要有 length 属性即可，这也符合前面讲到的接口的类型兼容性</p></blockquote><p>泛型的类型变量可以有多个，并且类型变量之间还可以约束（比如，第二个类型变量受第一个类型变量<br>约束）。</p><p>比如，创建一个函数来获取对象中属性的值</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> getProp&lt;<span class="title class_">Type</span>, <span class="title class_">Key</span> <span class="keyword">extends</span> keyof <span class="title class_">Type</span>&gt;(<span class="attr">obj</span>: <span class="title class_">Type</span>, <span class="attr">key</span>: <span class="title class_">Key</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> obj[key]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;jack&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;</span><br><span class="line"><span class="title function_">getProp</span>(person, <span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"><span class="comment">// 添加了第二个类型变量 Key，两个类型变量之间使用（,）逗号分隔</span></span><br><span class="line"><span class="comment">// keyof 关键字接收一个对象类型，生成其键名称（可能是字符串或数字）的联合类型</span></span><br><span class="line"><span class="comment">// 本示例中 keyof Type 实际上获取的是 person 对象所有键的联合类型，也就是：&#x27;name&#x27; | &#x27;age&#x27;</span></span><br><span class="line"><span class="comment">// 类型变量 Key 受 Type 约束，可以理解为：Key 只能是 Type 所有键中的任意一个，或者说只能访问</span></span><br><span class="line"><span class="comment">// 对象中存在的属性</span></span><br></pre></td></tr></table></figure><p><strong>泛型接口</strong>：接口也可以配合泛型来使用，以增加其灵活性，增强其复用性</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IdFunc</span>&lt;<span class="title class_">Type</span>&gt; &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="function">(<span class="params">value: Type</span>) =&gt;</span> <span class="title class_">Type</span></span><br><span class="line">    <span class="attr">ids</span>: <span class="function">() =&gt;</span> <span class="title class_">Type</span>[]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">obj</span>: <span class="title class_">IdFunc</span>&lt;<span class="built_in">number</span>&gt; = &#123;</span><br><span class="line">    <span class="title function_">id</span>(<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">ids</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在接口名称的后面添加 &lt;类型变量&gt;，那么，这个接口就变成了泛型接口</span></span><br><span class="line"><span class="comment">// 接口的类型变量，对接口中所有其他成员可见，也就是接口中所有成员都可以使用类型变量</span></span><br><span class="line"><span class="comment">// 使用泛型接口时，需要显式指定具体的类型（比如，此处的 IdFunc&lt;nunber&gt;）</span></span><br><span class="line"><span class="comment">// 此时，id 方法的参数和返回值类型都是 number；ids 方法的返回值类型是 number[]</span></span><br></pre></td></tr></table></figure><p>实际上，JS 中的数组在 TS 中就是一个泛型接口</p><p><img src="C:\Users\18389\AppData\Roaming\Typora\typora-user-images\image-20230517142632837.png" alt="image-20230517142632837"></p><p><img src="C:\Users\18389\AppData\Roaming\Typora\typora-user-images\image-20230517142637698.png" alt="image-20230517142637698"></p><p>当我们在使用数组时，TS 会根据数组的不同类型，来自动将类型变量设置为相应的类型<br>可以通过 Ctrl + 鼠标左键（Mac：option + 鼠标左键）来查看具体的类型信息</p><p>泛型类：class 也可以配合泛型来使用。<br>泛型类与泛型接口类似。 泛型类使用（ &lt;&gt; ）括起泛型类型，跟在类名后面</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GenericNumber</span>&lt;<span class="title class_">Type</span>&gt; &#123;</span><br><span class="line">    <span class="attr">zeroValue</span>: <span class="title class_">Type</span></span><br><span class="line">    <span class="attr">add</span>: <span class="function">(<span class="params">x: Type, y: Type</span>) =&gt;</span> <span class="title class_">Type</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 此处的 add 方法，采用的是箭头函数形式的类型书写方式</span></span><br><span class="line"><span class="keyword">let</span> myGenericNumber = <span class="keyword">new</span> <span class="title class_">GenericNumber</span>&lt;<span class="built_in">number</span>&gt;()</span><br><span class="line">myGenericNumber.<span class="property">zeroValue</span> = <span class="number">0</span></span><br><span class="line">myGenericNumber.<span class="property">add</span> = <span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> stringNumeric = <span class="keyword">new</span> <span class="title class_">GenericNumber</span>&lt;<span class="built_in">string</span>&gt;()</span><br><span class="line">stringNumeric.<span class="property">zeroValue</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line">stringNumeric.<span class="property">add</span> = <span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringNumeric.<span class="title function_">add</span>(stringNumeric.<span class="property">zeroValue</span>, <span class="string">&#x27;test&#x27;</span>))</span><br><span class="line"><span class="comment">// GenericNumber可以指定 number 类型也可以使用字符串或其它更复杂的类型</span></span><br></pre></td></tr></table></figure><p><strong>泛型工具类型</strong>：TS 内置了一些常用的工具类型，来简化 TS 中的一些常见操作。<br>说明：它们都是基于泛型实现的（泛型适用于多种类型，更加通用），并且是内置的，可以直接在代码<br>中使用。<br>这些工具类型有很多，主要学习以下几个 ：</p><ul><li><code>Partial&lt;Type&gt;</code></li><li><code>Readonly&lt;Type&gt;</code></li></ul><p><code>Partial&lt;Type&gt;</code></p><p><code>Partial&lt;Type&gt;</code>用来构造（创建）一个类型，将 Type 的所有属性设置为可选</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Props</span> &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="built_in">string</span></span><br><span class="line">    <span class="attr">children</span>: <span class="built_in">number</span>[]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PartialProps</span> = <span class="title class_">Partial</span>&lt;<span class="title class_">Props</span>&gt;</span><br><span class="line"><span class="comment">// 构造出来的新类型 PartialProps 结构和 Props 相同，但所有属性都变为可选的</span></span><br></pre></td></tr></table></figure><p><code>Partial&lt;Type&gt;</code>用来构造一个类型，将 Type 的所有属性都设置为 readonly（只读）</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Props</span> &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="built_in">string</span></span><br><span class="line">    <span class="attr">children</span>: <span class="built_in">number</span>[]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ReadonlyProps</span> = <span class="title class_">Readonly</span>&lt;<span class="title class_">Props</span>&gt;</span><br><span class="line"><span class="comment">// 构造出来的新类型 ReadonlyProps 结构和 Props 相同，但所有属性都变为只读的</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">props</span>: <span class="title class_">ReadonlyProps</span> = &#123; <span class="attr">id</span>: <span class="string">&#x27;1&#x27;</span>, <span class="attr">children</span>: [] &#125;</span><br><span class="line">props.<span class="property">id</span> = <span class="string">&#x27;2&#x27;</span></span><br><span class="line"><span class="comment">// 当我们想重新给 id 属性赋值时，就会报错：无法分配到 &quot;id&quot; ，因为它是只读属性</span></span><br></pre></td></tr></table></figure><p><code>Pick&lt;Type, Keys&gt; </code>从 Type 中选择一组属性来构造新类型</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Props</span> &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="built_in">string</span></span><br><span class="line">    <span class="attr">title</span>: <span class="built_in">string</span></span><br><span class="line">    <span class="attr">children</span>: <span class="built_in">number</span>[]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PickProps</span> = <span class="title class_">Pick</span>&lt;<span class="title class_">Props</span>, <span class="string">&#x27;id&#x27;</span> | <span class="string">&#x27;title&#x27;</span>&gt;</span><br><span class="line"><span class="comment">// Pick 工具类型有两个类型变量：1 表示选择谁的属性 2 表示选择哪几个属性</span></span><br><span class="line"><span class="comment">// 其中第二个类型变量，如果只选择一个则只传入该属性名即可</span></span><br><span class="line"><span class="comment">// 第二个类型变量传入的属性只能是第一个类型变量中存在的属性</span></span><br><span class="line"><span class="comment">// 构造出来的新类型 PickProps，只有 id 和 title 两个属性类型</span></span><br></pre></td></tr></table></figure><p><code>Record&lt;Keys,Type&gt;</code> 构造一个对象类型，属性键为 Keys，属性类型为 Type</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">RecordObj</span> = <span class="title class_">Record</span>&lt;<span class="string">&#x27;a&#x27;</span> | <span class="string">&#x27;b&#x27;</span> | <span class="string">&#x27;c&#x27;</span>, <span class="built_in">string</span>[]&gt;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">obj</span>: <span class="title class_">RecordObj</span> = &#123;</span><br><span class="line">    <span class="attr">a</span>: [<span class="string">&#x27;1&#x27;</span>],</span><br><span class="line">    <span class="attr">b</span>: [<span class="string">&#x27;2&#x27;</span>],</span><br><span class="line">    <span class="attr">c</span>: [<span class="string">&#x27;3&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Record 工具类型有两个类型变量：1 表示对象有哪些属性 2 表示对象属性的类型</span></span><br><span class="line"> 构建的新对象类型 <span class="title class_">RecordObj</span> 表示：这个对象有三个属性分别为a/b/c，属性值的类型都是 <span class="built_in">string</span>[]</span><br></pre></td></tr></table></figure><h3 id="4-5-索引签名类型"><a href="#4-5-索引签名类型" class="headerlink" title="4.5 索引签名类型"></a>4.5 索引签名类型</h3><p>绝大多数情况下，我们都可以在使用对象前就确定对象的结构，并为对象添加准确的类型。<br>使用场景：<strong>当无法确定对象中有哪些属性</strong>（或者说对象中可以出现任意多个属性），此时，就用到索引<br>签名类型了。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">AnyObject</span> &#123;</span><br><span class="line">    [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">obj</span>: <span class="title class_">AnyObject</span> = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用 [key: string] 来约束该接口中允许出现的属性名称。表示只要是 string 类型的属性名称，都可以出现在对象中。</span></span><br><span class="line"><span class="comment">// 这样，对象 obj 中就可以出现任意多个属性（比如，a、b 等）。</span></span><br><span class="line"><span class="comment">// key 只是一个占位符，可以换成任意合法的变量名称。</span></span><br><span class="line"><span class="comment">// 隐藏的前置知识：JS 中对象（&#123;&#125;）的键是 string 类型的。</span></span><br></pre></td></tr></table></figure><p>在 JS 中数组是一类特殊的对象，特殊在数组的键（索引）是数值类型。<br>并且，数组也可以出现任意多个元素。所以，在数组对应的泛型接口中，也用到了索引签名类型。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MyArray</span>&lt;T&gt; &#123;</span><br><span class="line">    [<span class="attr">n</span>: <span class="built_in">number</span>]: T</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>: <span class="title class_">MyArray</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment">// MyArray 接口模拟原生的数组接口，并使用 [n: number] 来作为索引签名类型。</span></span><br><span class="line"><span class="comment">// 该索引签名类型表示：只要是 number 类型的键（索引）都可以出现在数组中，或者说数组中可以有任意多个元素。</span></span><br><span class="line"><span class="comment">// 同时也符合数组索引是 number 类型这一前提。</span></span><br></pre></td></tr></table></figure><h3 id="4-6-映射类型"><a href="#4-6-映射类型" class="headerlink" title="4.6 映射类型"></a>4.6 映射类型</h3><p>映射类型：基于旧类型创建新类型（对象类型），减少重复、提升开发效率。<br>比如，类型 PropKeys 有 x&#x2F;y&#x2F;z，另一个类型 Type1 中也有 x&#x2F;y&#x2F;z，并且 Type1 中 x&#x2F;y&#x2F;z 的类型相同：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">PorpKeys</span> = <span class="string">&#x27;x&#x27;</span> | <span class="string">&#x27;y&#x27;</span> | <span class="string">&#x27;x&#x27;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Type1</span> = &#123; <span class="attr">x</span>: <span class="built_in">number</span>; <span class="attr">y</span>: <span class="built_in">number</span>; <span class="attr">z</span>: <span class="built_in">number</span> &#125;</span><br></pre></td></tr></table></figure><p>这样书写没错，但 x&#x2F;y&#x2F;z 重复书写了两次。像这种情况，就可以使用映射类型来进行简化。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">PropKeys</span> = <span class="string">&#x27;x&#x27;</span> | <span class="string">&#x27;y&#x27;</span> | <span class="string">&#x27;z&#x27;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Type2</span> = &#123; [key <span class="keyword">in</span> <span class="title class_">PropKeys</span>]: <span class="built_in">number</span> &#125;</span><br><span class="line"><span class="comment">// 映射类型是基于索引签名类型的，所以，该语法类似于索引签名类型，也使用了 []。</span></span><br><span class="line"><span class="comment">// Key in PropKeys 表示 Key 可以是 PropKeys 联合类型中的任意一个，类似于 forin(let k in obj)。</span></span><br><span class="line"><span class="comment">// 使用映射类型创建的新对象类型 Type2 和类型 Type1 结构完全相同。</span></span><br><span class="line"><span class="comment">// 注意：映射类型只能在类型别名中使用，不能在接口中使用。</span></span><br></pre></td></tr></table></figure><p>映射类型除了根据联合类型创建新类型外，还可以根据对象类型来创建：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Props</span> = &#123; <span class="attr">a</span>: <span class="built_in">number</span>; <span class="attr">b</span>: <span class="built_in">string</span>; <span class="attr">c</span>: <span class="built_in">boolean</span> &#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Type3</span> = &#123; [key <span class="keyword">in</span> keyof <span class="title class_">Props</span>]: <span class="built_in">number</span> &#125;</span><br><span class="line"><span class="comment">// 首先，先执行 keyof Props 获取到对象类型 Props 中所有键的联合类型即，&#x27;a&#x27; | &#x27;b&#x27; | &#x27;c&#x27;</span></span><br><span class="line"><span class="comment">// 然后，Key in ... 就表示 Key 可以是 Props 中所有的键名称中的任意一个。</span></span><br></pre></td></tr></table></figure><p><img src="C:\Users\18389\AppData\Roaming\Typora\typora-user-images\image-20230517143450179.png" alt="image-20230517143450179"></p><p>实际上，前面讲到的泛型工具类型（比如， Partial<Type> ）都是基于映射类型实现的。</p><p>比如， <code>Partial&lt;Type&gt;</code> 的实现：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Partial</span>&lt;T&gt; = &#123;</span><br><span class="line">    [P <span class="keyword">in</span> keyof T]?: T[P]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Props</span> = &#123; <span class="attr">a</span>: <span class="built_in">number</span>; <span class="attr">b</span>: <span class="built_in">string</span>; <span class="attr">c</span>: <span class="built_in">boolean</span> &#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PartialProps</span> = <span class="title class_">Partial</span>&lt;<span class="title class_">Props</span>&gt;</span><br><span class="line"><span class="comment">// keyof T 即 keyof Props 表示获取 Props 的所有键，也就是：&#x27;a&#x27; | &#x27;b&#x27; | &#x27;c&#x27;。</span></span><br><span class="line"><span class="comment">// 在 [] 后面添加 ?（问号），表示将这些属性变为可选的，以此来实现 Partial 的功能。</span></span><br><span class="line"><span class="comment">// 冒号后面的 T[P] 表示获取 T 中每个键对应的类型。比如，如果是 &#x27;a&#x27; 则类型是 number；如果是&#x27;b&#x27; 则类型是 string。</span></span><br><span class="line"><span class="comment">// 最终，新类型 PartialProps 和旧类型 Props 结构完全相同，只是让所有类型都变为可选了。</span></span><br></pre></td></tr></table></figure><p>刚刚用到的 T[P] 语法，在 TS 中叫做索引查询（访问）类型。<br>作用：用来查询属性的类型。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Props</span> = &#123; <span class="attr">a</span>: <span class="built_in">number</span>; <span class="attr">b</span>: <span class="built_in">string</span>; <span class="attr">c</span>: <span class="built_in">boolean</span> &#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TypeA</span> = <span class="title class_">Props</span>[<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line"><span class="comment">// Props[&#x27;a&#x27;] 表示查询类型 Props 中属性 &#x27;a&#x27; 对应的类型 number。所以，TypeA 的类型为 number。</span></span><br></pre></td></tr></table></figure><p><img src="C:\Users\18389\AppData\Roaming\Typora\typora-user-images\image-20230517143649669.png" alt="image-20230517143649669"></p><p>索引查询类型的其他使用方式：同时查询多个索引的类型</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Props</span> = &#123; <span class="attr">a</span>: <span class="built_in">number</span>; <span class="attr">b</span>: <span class="built_in">string</span>; <span class="attr">c</span>: <span class="built_in">boolean</span> &#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TypeA</span> = <span class="title class_">Props</span>[<span class="string">&#x27;a&#x27;</span> | <span class="string">&#x27;b&#x27;</span>] <span class="comment">// string | number</span></span><br><span class="line"><span class="comment">// 使用字符串字面量的联合类型，获取属性 a 和 b 对应的类型，结果为： string | number。</span></span><br></pre></td></tr></table></figure><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Props</span> = &#123; <span class="attr">a</span>: <span class="built_in">number</span>; <span class="attr">b</span>: <span class="built_in">string</span>; <span class="attr">c</span>: <span class="built_in">boolean</span> &#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TypeA</span> = <span class="title class_">Props</span>[keyof <span class="title class_">Props</span>]</span><br><span class="line"><span class="comment">// 使用 keyof 操作符获取 Props 中所有键对应的类型，结果为： string | number | boolean。</span></span><br></pre></td></tr></table></figure><h2 id="五、TypeScript-类型声明文件"><a href="#五、TypeScript-类型声明文件" class="headerlink" title="五、TypeScript 类型声明文件"></a>五、TypeScript 类型声明文件</h2><p>概述<br>今天几乎所有的 JavaScript 应用都会引入许多第三方库来完成任务需求。<br>这些第三方库不管是否是用 TS 编写的，最终都要编译成 JS 代码，才能发布给开发者使用。<br>我们知道是 TS 提供了类型，才有了代码提示和类型保护等机制。<br>但在项目开发中使用第三方库时，你会发现它们几乎都有相应的 TS 类型，这些类型是怎么来的呢？<strong>类</strong><br><strong>型声明文件</strong><br><strong>类型声明文件：用来为已存在的 JS 库提供类型信息。</strong><br>这样在 TS 项目中使用这些库时，就像用 TS 一样，都会有代码提示、类型保护等机制了。</p><h3 id="5-1-TS-中的两种文件类型"><a href="#5-1-TS-中的两种文件类型" class="headerlink" title="5.1 TS 中的两种文件类型"></a>5.1 TS 中的两种文件类型</h3><p>TS 中有两种文件类型：</p><ol><li>ts 文件<ul><li>既包含类型信息又可执行代码</li><li>可以被编译为 .js 文件，然后，执行代码</li><li>用途：编写程序代码的地方</li></ul></li><li>.d.ts文件<ul><li>只包含类型信息的类型声明文件</li><li>不会生成 .js 文件，仅用于提供类型信息</li><li>用途：为 JS 提供类型信息</li></ul></li></ol><blockquote><p>.ts 是 implementation（代码实现文件）；.d.ts 是 declaration（类型声明文件）。</p></blockquote><h3 id="5-2-类型声明文件的使用说明"><a href="#5-2-类型声明文件的使用说明" class="headerlink" title="5.2 类型声明文件的使用说明"></a>5.2 类型声明文件的使用说明</h3><p>在使用 TS 开发项目时，类型声明文件的使用包括以下两种方式：</p><ol><li>使用已有的类型声明文件</li><li>创建自己的类型声明文件</li></ol><p>学习顺序：先会用（别人的）再会写（自己的）。</p><p><strong>使用已有的类型声明文件</strong></p><ol><li>内置类型声明文件</li><li>第三方库的类型声明文件</li></ol><p><strong>内置类型声明文件：TS 为 JS 运行时可用的所有标准化内置 API 都提供了声明文件。</strong><br>比如，在使用数组时，数组所有方法都会有相应的代码提示以及类型信息：</p><p><img src="C:\Users\18389\AppData\Roaming\Typora\typora-user-images\image-20230517144403694.png" alt="image-20230517144403694"></p><p>实际上这都是 TS 提供的内置类型声明文件。<br>可以通过 Ctrl + 鼠标左键（Mac：option + 鼠标左键）来查看内置类型声明文件内容。<br>比如，查看 forEach 方法的类型声明，在 VSCode 中会自动跳转到 lib.es5.d.ts 类型声明文件中。<br>当然，像 window、document 等 BOM、DOM API 也都有相应的类型声明（lib.dom.d.ts）。<br><strong>第三方库的类型声明文件</strong>：目前，几乎所有常用的第三方库都有相应的类型声明文件。<br>第三方库的类型声明文件有两种存在形式：</p><ol><li>库自带类型声明文件</li><li>由 DefinitelyTyped 提供</li></ol><p><strong>库自带类型声明文件</strong>：比如，axios</p><p><img src="C:\Users\18389\AppData\Roaming\Typora\typora-user-images\image-20230517144525757.png" alt="image-20230517144525757"></p><blockquote><p>这种情况下，正常导入该库，TS 就会自动加载库自己的类型声明文件，以提供该库的类型声明。</p></blockquote><p><strong>由 DefinitelyTyped 提供</strong></p><p><a href="https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master">DefinitelyTyped</a>是一个 github 仓库，用来提供高质量 TypeScript 类型声明。<br>可以通过 npm&#x2F;yarn 来下载该仓库提供的 TS 类型声明包，这些包的名称格式为：@types&#x2F;*。<br>比如，@types&#x2F;react、@types&#x2F;lodash 等。<br>说明：在实际项目开发时，如果你使用的第三方库没有自带的声明文件，VSCode 会给出明确的提示。</p><p><img src="C:\Users\18389\AppData\Roaming\Typora\typora-user-images\image-20230519101820473.png" alt="image-20230519101820473"></p><blockquote><p>当安装 @types&#x2F;* 类型声明包后，TS 也会自动加载该类声明包，以提供该库的类型声明</p></blockquote><h3 id="5-2-2-创建自己的类型声明文件"><a href="#5-2-2-创建自己的类型声明文件" class="headerlink" title="5.2.2 创建自己的类型声明文件"></a>5.2.2 创建自己的类型声明文件</h3><p>创建自己的类型声明文件：</p><ol><li>项目内共享类型</li><li>为已有 JS 文件提供类型声明</li></ol><p><strong>项目内共享类型</strong><br>如果多个 .ts 文件中都用到同一个类型，此时可以创建 .d.ts 文件提供该类型，实现类型共享</p><p>操作步骤：</p><ol><li>创建 index.d.ts 类型声明文件</li><li>创建需要共享的类型，并使用 export 导出（TS 中的类型也可以使用 import&#x2F;export 实现模块化功能）</li><li>在需要使用共享类型的 .ts 文件中，通过 import 导入即可（.d.ts 后缀导入时，直接省略）为已有 JS 文件提供类型声明</li></ol><p><strong>为已有 JS 文件提供类型声明</strong></p><ol><li>在将 JS 项目<a href="https://www.typescriptlang.org/docs/handbook/migrating-from-javascript.html">迁移</a>到 TS 项目时，为了让已有的 .js 文件有类型声明。</li><li>成为库作者，创建库给其他人使用。</li></ol><p>注意：类型声明文件的编写与模块化方式相关，不同的模块化方式有不同的写法。但由于历史原因，JS<br>模块化的发展经历过多种变化（AMD、CommonJS、UMD、ESModule 等），而 TS 支持各种模块化形<br>式的类型声明。这就导致，类型声明文件<a href="https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html">相关内容</a>又多又杂。</p><p>演示：基于最新的 <strong>ESModule</strong>（import&#x2F;export）来为已有 .js 文件，创建类型声明文件</p><p>开发环境准备：使用 webpack 搭建，通过 <strong>ts-loader</strong> 处理 .ts 文件</p><blockquote><p>TS 项目中也可以使用 .js 文件</p><p>在导入 .js 文件时，TS 会自动加载与 .js 同名的 .d.ts 文件，以提供类型声明</p><p>declare 关键字：用于类型声明，为其他地方（比如，.js 文件）已存在的变量声明类型，而不是创<br>建一个新的变量</p><ol><li>对于 type、interface 等这些明确就是 TS 类型的（只能在 TS 中使用的），可以省略 declare<br>关键字。</li><li>对于 let、function 等具有双重含义（在 JS、TS 中都能用），应该使用 declare 关键字，明<br>确指定此处用于类型声明。</li></ol></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pinia学习</title>
      <link href="/2023/06/20/Pinia%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/06/20/Pinia%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Pinia-状态管理"><a href="#Pinia-状态管理" class="headerlink" title="Pinia 状态管理"></a>Pinia 状态管理</h1><h2 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h2><p>了解 Pinia 与 Vuex 的区别<br>掌握 state、getter、actions 的概念<br>掌握 state、getter、actions 的使用</p><h2 id="一、Pinia概述"><a href="#一、Pinia概述" class="headerlink" title="一、Pinia概述"></a>一、Pinia概述</h2><hr><h3 id="1-1-什么是Pinia"><a href="#1-1-什么是Pinia" class="headerlink" title="1.1 什么是Pinia"></a>1.1 什么是Pinia</h3><p>官方概念<br>Pinia 是 Vue 的专属状态管理库，它允许你跨组件或页面共享状态。</p><h3 id="1-2-Pinia-和-Vuex-的区别"><a href="#1-2-Pinia-和-Vuex-的区别" class="headerlink" title="1.2 Pinia 和 Vuex 的区别"></a>1.2 Pinia 和 Vuex 的区别</h3><ul><li>Pinia Vue2 和 Vue3 都能支持</li><li>抛弃传统的 Mutation ，只有 state, getter 和 action ，简化状态管理库</li><li>不需要嵌套模块，符合 Vue3 的 Composition api，让代码扁平化</li><li>TypeScript支持</li></ul><p>更详细的内容参考：<a href="https://pinia.vuejs.org/zh/cookbook/migration-vuex.html">迁移指南</a></p><h3 id="1-3-使用状态管理的好处"><a href="#1-3-使用状态管理的好处" class="headerlink" title="1.3 使用状态管理的好处"></a>1.3 使用状态管理的好处</h3><ol><li>能够在pinia中集中管理共享的数据，易于开发和后期维护</li><li>能够高效地实现组件之间的数据共享，提高开发效率</li><li>存储在pinia中的数据都是响应式的，能够实时保持数据与页面的同步</li></ol><h2 id="二、Vue-中使用-Pinia"><a href="#二、Vue-中使用-Pinia" class="headerlink" title="二、Vue 中使用 Pinia"></a>二、Vue 中使用 Pinia</h2><h3 id="2-1-安装-Pinia-依赖包"><a href="#2-1-安装-Pinia-依赖包" class="headerlink" title="2.1 安装 Pinia 依赖包"></a>2.1 安装 Pinia 依赖包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i pinia --save</span><br></pre></td></tr></table></figure><h3 id="2-2-导入-Pinia-包"><a href="#2-2-导入-Pinia-包" class="headerlink" title="2.2 导入 Pinia 包"></a>2.2 导入 Pinia 包</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; createPinia &#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span><br><span class="line"><span class="comment">// 创建pinia 实例</span></span><br><span class="line"><span class="keyword">const</span> pinia = <span class="title function_">createPinia</span>()</span><br><span class="line"></span><br><span class="line"><span class="title function_">createApp</span>(<span class="title class_">App</span>).<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="2-3-将-store-挂载到-vue-app"><a href="#2-3-将-store-挂载到-vue-app" class="headerlink" title="2.3 将 store 挂载到 vue app"></a>2.3 将 store 挂载到 vue app</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="comment">// 导入pinia</span></span><br><span class="line"><span class="keyword">import</span> &#123; createPinia &#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建pinia 实例</span></span><br><span class="line"><span class="keyword">const</span> pinia = <span class="title function_">createPinia</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 挂载到 app</span></span><br><span class="line">app.<span class="title function_">use</span>(pinia)</span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="2-4-创建-store"><a href="#2-4-创建-store" class="headerlink" title="2.4 创建 store"></a>2.4 创建 store</h3><p><code>store</code> 简单来说就是数据仓库的意思，我们数据都放在<code>store</code> 里面。当然你也可以把它理解为一个公共<br>组件，只不过该公共组件只存放数据，这些数据我们其它所有的组件都能够访问且可以修改。<br>我们需要使用<code>pinia</code> 提供的<code>defineStore()</code> 方法来创建一个<code>store</code> ，该<code>store</code> 用来存放我们需要全局使用的数据。<br>首先在项目<code>src </code>目录下新建<code>store</code>文件夹，用来存放我们创建的各种<code>store</code>，然后在该目录下新建<br><code>user.ts</code>文件，主要用来存放与<code>user</code> 相关的<code>store</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># /src/store/user.<span class="property">ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; defineStore &#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个参数是应用程序中 store 的唯一 id</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useUsersStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;users&#x27;</span>, &#123;</span><br><span class="line"><span class="comment">// 其它配置项</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="2-5-使用-store"><a href="#2-5-使用-store" class="headerlink" title="2.5 使用 store"></a>2.5 使用 store</h3><p>使用<code>store</code> 直接引入声明的<code>useUsersStore</code> 方法即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/src/<span class="title class_">App</span>.<span class="property">vue</span></span><br><span class="line"></span><br><span class="line">&lt;script setup lang=<span class="string">&quot;ts&quot;</span>&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; useUsersStore &#125; <span class="keyword">from</span> <span class="string">&quot;../src/store/user&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">useUsersStore</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(store);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="2-6-添加-state"><a href="#2-6-添加-state" class="headerlink" title="2.6 添加 state"></a>2.6 添加 state</h3><p><code>store</code>是用来存放公共数据的，那么数据具体存在哪？前面我们利用<code>defineStore</code> 函数创建了一个<br><code>store</code>，该函数第二个参数是一个options 配置项，我们需要存放的数据就放在<code>options</code> 对象中的<br><code>state</code> 属性内。</p><p><strong>代码示例</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># /src/store/user.<span class="property">ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useUserStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;users&#x27;</span>, &#123;</span><br><span class="line"><span class="comment">// 其它配置</span></span><br><span class="line"><span class="comment">// state接收的是一个箭头函数返回的值，它不能直接接收一个对象。</span></span><br><span class="line"><span class="attr">state</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">            <span class="attr">age</span>: <span class="number">25</span>,</span><br><span class="line">            <span class="attr">sex</span>: <span class="string">&#x27;男&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="2-7-操作-state"><a href="#2-7-操作-state" class="headerlink" title="2.7 操作 state"></a>2.7 操作 state</h3><h4 id="2-7-1-读取-state"><a href="#2-7-1-读取-state" class="headerlink" title="2.7.1 读取 state"></a>2.7.1 读取 state</h4><p>在<code>App.vue</code>中继续打印<code>store</code> 来看结果</p><p><img src="C:\Users\18389\AppData\Roaming\Typora\typora-user-images\image-20230522143916998.png" alt="image-20230522143916998"></p><p>修改<code>App.vue </code>，让这几个数据显示出来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123; ref &#125; from &#x27;vue&#x27;</span><br><span class="line">import &#123; useUserStore &#125; from &#x27;./store/user&#x27;</span><br><span class="line">const userStore = useUserStore()</span><br><span class="line">// console.log(userStore)</span><br><span class="line">const name = ref&lt;string&gt;(userStore.name)</span><br><span class="line">const age = ref&lt;number&gt;(userStore.age)</span><br><span class="line">const sex = ref&lt;string&gt;(userStore.sex)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;h1&gt;APP根组件&lt;/h1&gt;</span><br><span class="line">&lt;hr /&gt;</span><br><span class="line">&lt;p&gt;姓名：&#123;&#123; name &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;年龄：&#123;&#123; age &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;性别：&#123;&#123; sex &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p><strong>使用解构方式</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">    import &#123; useUserStore &#125; from &#x27;./store/user&#x27;</span><br><span class="line">    const userStore = useUserStore()</span><br><span class="line">    // console.log(userStore)</span><br><span class="line">    const &#123; name, age, sex &#125; = userStore</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;h1&gt;APP根组件&lt;/h1&gt;</span><br><span class="line">    &lt;hr /&gt;</span><br><span class="line">    &lt;p&gt;姓名：&#123;&#123; name &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;年龄：&#123;&#123; age &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;性别：&#123;&#123; sex &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;&lt;/style&gt;</span><br></pre></td></tr></table></figure><h3 id="2-7-2-多个组件使用state"><a href="#2-7-2-多个组件使用state" class="headerlink" title="2.7.2 多个组件使用state"></a>2.7.2 多个组件使用state</h3><p>使用<code>store</code>的最重要的目的就是为了组件之间共享数据。新建一个<code>child.vue</code> 组件，在该组件内部也使<br>用<code>state</code> 数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">child.vue 组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;h2&gt;我是child组件&lt;/h2&gt;</span><br><span class="line">    &lt;p&gt;姓名：&#123;&#123; name &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;年龄：&#123;&#123; age &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;性别：&#123;&#123; sex &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123; useUserStore &#125; from &#x27;../store/user&#x27;</span><br><span class="line">const store = useUserStore()</span><br><span class="line">const &#123; name, age, sex &#125; = store</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>这样就实现了多个组件同时使用store 中的数据。</p><h3 id="2-7-3-修改-state-数据"><a href="#2-7-3-修改-state-数据" class="headerlink" title="2.7.3 修改 state 数据"></a>2.7.3 修改 state 数据</h3><p>如果想要修改<code>store</code> 中的数据，可以直接重新赋值即可，在<code>App.vue</code> 里面添加一个按钮，点击按钮修<br>改<code>store</code> 中的某一个数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123; useUserStore &#125; from &#x27;./store/user&#x27;</span><br><span class="line">import Child from &#x27;./components/Child.vue&#x27;</span><br><span class="line">const userStore = useUserStore()</span><br><span class="line"></span><br><span class="line">const &#123; name, age, sex &#125; = userStore</span><br><span class="line">// 修改name</span><br><span class="line">const changeName = () =&gt; &#123;</span><br><span class="line">    userStore.name = &#x27;李四&#x27;</span><br><span class="line">    console.log(userStore.name)</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;h1&gt;APP根组件&lt;/h1&gt;</span><br><span class="line">    &lt;button @click=&quot;changeName&quot;&gt;更改姓名&lt;/button&gt;</span><br><span class="line">    &lt;hr /&gt;</span><br><span class="line">    &lt;p&gt;姓名：&#123;&#123; name &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;年龄：&#123;&#123; age &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;性别：&#123;&#123; sex &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;hr /&gt;</span><br><span class="line">    &lt;Child&gt;&lt;/Child&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>通过输出可以看到<code>store</code> 中的<code>name</code> 确实被修改了，但是页面上没有变化，这说明使用的<code>name</code> 不是响应式的。<br><code>pinia</code> 提供了<code>storeToRefs</code> 函数，可以将<code>state</code> 中的数据变为响应式。<br><strong>app.vue和child.vue代码修改如下：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; storeToRefs &#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span><br><span class="line"><span class="comment">// 使用 storeToRefs 函数</span></span><br><span class="line"><span class="keyword">const</span> &#123; name, age, sex &#125; = <span class="title function_">storeToRefs</span>(userStore)</span><br></pre></td></tr></table></figure><p>两个组件中获取<code>state</code> 数据的方式都改为上段代码的形式，利用<code>pinia</code> 的<code>storeToRefs</code> 函数，将<code>state</code> 中的数据变为了响应式的。</p><h3 id="2-7-4-修改-state"><a href="#2-7-4-修改-state" class="headerlink" title="2.7.4 修改 state"></a>2.7.4 修改 state</h3><p>有时候修改了state 数据，想要将它还原，这个时候该怎么做呢？就比如用户填写了一部分表单，突然想重置为最初始的状态。<br>此时，可以直接调用store 的$reset() 方法即可，继续使用我们的例子，添加一个重置按钮。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click=<span class="string">&quot;reset&quot;</span>&gt;重置store&lt;/button&gt;</span><br><span class="line"><span class="comment">// 重置store</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">reset</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    userStore.$reset()</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(userStore)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-7-5-批量更改-state-数据"><a href="#2-7-5-批量更改-state-数据" class="headerlink" title="2.7.5 批量更改 state 数据"></a>2.7.5 批量更改 state 数据</h3><p>前面修改state 的数据是都是一条一条修改的，比如store.name&#x3D;”张三” 等等，如果我们一次性需要修<br>改很多条数据的话，有更加简便的方法，使用store 的$patch 方法，修改app.vue 代码，添加一个批<br>量更改数据的方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 批量修改数据</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">patchStore</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    userStore.$patch(&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">100</span>,</span><br><span class="line">    <span class="attr">sex</span>: <span class="string">&#x27;女&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line">&lt;button @click=<span class="string">&quot;patchStore&quot;</span>&gt;批量修改数据&lt;/button&gt;</span><br></pre></td></tr></table></figure><h3 id="2-7-6-批量更改-state-数据"><a href="#2-7-6-批量更改-state-数据" class="headerlink" title="2.7.6 批量更改 state 数据"></a>2.7.6 批量更改 state 数据</h3><p>pinia 提供了方法让直接替换整个state 对象，使用store 的$state 方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.<span class="property">$state</span> = &#123; <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,<span class="attr">age</span>: <span class="number">100</span>,<span class="attr">sex</span>: <span class="string">&#x27;女&#x27;</span> &#125;</span><br></pre></td></tr></table></figure><h3 id="2-8-getters-属性"><a href="#2-8-getters-属性" class="headerlink" title="2.8 getters 属性"></a>2.8 getters 属性</h3><p><code>getters</code> 是<code>defineStore</code> 参数配置项里面的另一个属性，前面讲了<code>state</code> 属性。<code>getter</code> 属性值是一个对象，该对象里面是各种各样的方法。大家可以把<code>getter</code> 想象成<code>Vue</code> 中的计算属性，它的作用就是返回一个新的结果，既然它和<code>Vue</code> 中的计算属性类似，那么它肯定也是会被缓存的，就和<code>computed</code> 一样。</p><h3 id="2-8-1-添加getter"><a href="#2-8-1-添加getter" class="headerlink" title="2.8.1 添加getter"></a>2.8.1 添加getter</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useUserStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;users&#x27;</span>, &#123;</span><br><span class="line"><span class="comment">// 其它配置</span></span><br><span class="line"><span class="comment">// state接收的是一个箭头函数返回的值，它不能直接接收一个对象。</span></span><br><span class="line"><span class="attr">state</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">        <span class="attr">age</span>: <span class="number">25</span>,</span><br><span class="line">        <span class="attr">sex</span>: <span class="string">&#x27;男&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">getters</span>: &#123;</span><br><span class="line">        <span class="attr">getAddAge</span>: <span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> state.<span class="property">age</span> + <span class="number">100</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上段代码中在配置项参数中添加了<code>getter</code> 属性，该属性对象中定义了一个<code>getAddAge</code> 方法，该方法会<br>默认接收一个<code>state</code> 参数，也就是<code>state</code> 对象，然后该方法返回的是一个新的数据。</p><h3 id="2-8-2-使用getter"><a href="#2-8-2-使用getter" class="headerlink" title="2.8.2 使用getter"></a>2.8.2 使用getter</h3><p>在<code>store</code> 中定义了<code>getter</code> ，那么在组件中如何使用呢？使用起来非常简单，我们修改<code>App.vue</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 批量修改数据</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">patchStore</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        userStore.$patch(&#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">        <span class="attr">age</span>: <span class="number">100</span>,</span><br><span class="line">        <span class="attr">sex</span>: <span class="string">&#x27;女&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;新年龄：&#123;&#123; userStore.<span class="property">getAddAge</span> &#125;&#125;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;patchStore&quot;</span>&gt;</span>批量修改数据<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>上段代码中直接在标签上使用了<code>store.gettAddAge</code> 方法，这样可以保证响应式，其实我们<code>state</code> 中的<br><code>name</code> 等属性也可以以此种方式直接在标签上使用，也可以保持响应式。<br>当我们点击批量修改数据按钮时，页面上的新年龄字段也会跟着变化。</p><h3 id="2-8-3-getter中调用其它getter"><a href="#2-8-3-getter中调用其它getter" class="headerlink" title="2.8.3 getter中调用其它getter"></a>2.8.3 getter中调用其它getter</h3><p>前面的<code>getAddAge</code> 方法只是简单的使用了<code>state</code> 方法，但是有时候需要在这一个<code>getter</code> 方法中调用其<br>它<code>getter</code> 方法，这个时候如何调用呢？<br>其实很简单，可以直接在<code>getter</code>方法中调用<code>this</code> ， <code>this</code> 指向的便是<code>store</code> 实例，所以理所当然的能<br>够调用到其它<code>getter</code> 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">getters</span>: &#123;</span><br><span class="line">    <span class="attr">getAddAge</span>: <span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> state.<span class="property">age</span> + <span class="number">100</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="title function_">getNameAndAge</span>(): string &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span> + <span class="variable language_">this</span>.<span class="property">getAddAge</span> <span class="comment">// 调用其它getter</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上段代码中又定义了一个名为<code>getNameAndAge</code> 的<code>getter</code> 函数，在函数内部直接使用了<code>this</code> 来获取<br><code>state</code> 数据以及调用其它<code>getter</code> 函数。<br>细心的小伙伴可能会发现这里没有使用箭头函数的形式，这是因为在函数内部使用了<code>this</code> ，箭头函数<br>的<code>this</code> 指向问题。所以这里没有采用箭头函数的形式。</p><h3 id="2-8-4-getter传参"><a href="#2-8-4-getter传参" class="headerlink" title="2.8.4 getter传参"></a>2.8.4 getter传参</h3><p>既然<code>getter</code> 函数做了一些计算或者处理，那么很可能会需要传递参数给<code>getter</code> 函数，但是前面说<br><code>getter</code> 函数就相当于<code>store</code> 的计算属性，和<code>vue</code> 的计算属性差不多，那么我们都知道<code>Vue</code> 中计算属性<br>是不能直接传递参数的，所以我们这里的<code>getter</code> 函数如果要接受参数的话，也是需要做处理的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">getters</span>: &#123;</span><br><span class="line">    <span class="attr">getAddAge</span>: <span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function">(<span class="params">num: number</span>) =&gt;</span> state.<span class="property">age</span> + num</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">getNameAndAge</span>(): string &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span> + <span class="variable language_">this</span>.<span class="property">getAddAge</span> <span class="comment">// 调用其它getter</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组件中调用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;新年龄：&#123;&#123; store.getAddAge(100) &#125;&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure><h3 id="2-9-actions属性"><a href="#2-9-actions属性" class="headerlink" title="2.9 actions属性"></a>2.9 actions属性</h3><p>前面提到的<code>state</code> 和<code>getters</code> 属性都主要是数据层面的，并没有具体的业务逻辑代码，它们两个就和我<br>们组件代码中的<code>data</code> 数据和<code>computed</code> 计算属性一样。<br>那么，如果有业务代码的话，最好就是写在<code>actions</code> 属性里面，该属性就和我们组件代码中的<code>methods</code><br>相似，用来放置一些处理业务逻辑的方法。<br><code>actions</code> 属性值同样是一个对象，该对象里面也是存储的各种各样的方法，包括同步方法和异步方法。</p><h3 id="2-9-1-添加actions"><a href="#2-9-1-添加actions" class="headerlink" title="2.9.1 添加actions"></a>2.9.1 添加actions</h3><p>添加一个<code>actions</code> 方法，修改<code>user.ts</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useUserStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;users&#x27;</span>, &#123;</span><br><span class="line"><span class="comment">// 其它配置</span></span><br><span class="line"><span class="comment">// state接收的是一个箭头函数返回的值，它不能直接接收一个对象。</span></span><br><span class="line">    <span class="attr">state</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">        <span class="attr">age</span>: <span class="number">25</span>,</span><br><span class="line">        <span class="attr">sex</span>: <span class="string">&#x27;男&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">getters</span>: &#123;</span><br><span class="line">        <span class="attr">getAddAge</span>: <span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function">(<span class="params">num: number</span>) =&gt;</span> state.<span class="property">age</span> + num</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">getNameAndAge</span>(): string &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span> + <span class="variable language_">this</span>.<span class="title function_">getAddAge</span>(<span class="number">100</span>) <span class="comment">// 调用其它getter</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">actions</span>: &#123;</span><br><span class="line">        <span class="title function_">saveName</span>(<span class="params">name: string</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上段代码中定义了一个非常简单的<code>actions</code> 方法，在实际场景中，该方法可以是任何逻辑，比如发送请<br>求、存储<code>token</code> 等等。大家把<code>actions</code> 方法当作一个普通的方法即可，特殊之处在于该方法内部的<br><code>this</code> 指向的是当前<code>store</code> 。</p><h3 id="2-9-2-使用actions"><a href="#2-9-2-使用actions" class="headerlink" title="2.9.2 使用actions"></a>2.9.2 使用actions</h3><p>在<code>App.vue </code>中想要调用该方法，代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">saveName</span> = (<span class="params"></span>) =&gt; &#123; store.<span class="title function_">saveName</span>(<span class="string">&quot;老六&quot;</span>) &#125;</span><br></pre></td></tr></table></figure><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>pinia 的知识点很少，如果你有Vuex 基础，那么学起来更是易如反掌。其实更应该关注的是它的函数<br>思想，大家有没有发现在Vue3 中的所有东西似乎都可以用一个函数来表示， pinia 也是延续了这种思想。<br>所以，大家理解这种组合式编程的思想更重要， pinia 无非就是以下3个大点：</p><ul><li><code>state</code></li><li><code>getters</code></li><li><code>actions</code></li></ul><p>本章讲解了基础使用部分，但是在实际工作中也能满足大部分需求了，如果还有兴趣学习pinia 的其它<br>特点，比如插件、订阅等等，可以移步官网：<a href="https://pinia.web3doc.top/">pinia官网</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Pinia </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HeXo+Github部署自己的博客网站</title>
      <link href="/2023/06/20/Hexo+Github%E9%83%A8%E7%BD%B2%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/"/>
      <url>/2023/06/20/Hexo+Github%E9%83%A8%E7%BD%B2%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>首先感谢能来访问我的 Blog，这是我搭建的第一个博客网站，在者之前阿闲纯小白</p><p>搭建自己的博客，是每个热爱写作、分享和表达的人都会想要尝试的事情。在这个信息爆炸的时代，拥有一个属于自己的平台，不仅可以记录下生活中的点滴，更可以让自己的思想和观点得到更广泛的传播。</p><p>搭建博客并不是一件难事，现在有很多优秀的博客平台供我们选择，如WordPress、Hexo、Jekyll等等。这些平台不仅提供了完善的技术支持和丰富的主题模板，还可以让我们轻松地将自己的博客打造成一个独具特色的个人品牌。</p><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><blockquote><p>Github</p></blockquote><p>是一个面向<a href="https://baike.baidu.com/item/%E5%BC%80%E6%BA%90/20720669?fromModule=lemma_inlink">开源</a>及私有软件项目的托管平台，因为只支持Git作为唯一的版本库格式进行托管，故名GitHub。Github拥有1亿以上的开发人员，400万以上组织机构和3.3亿以上资料库。</p><blockquote><p>Github Pages</p></blockquote><p>Github Pages 可以被认为是用户编写的、托管在 github 上的静态网页。使用 Github Pages 可以为你提供一个免费的服务器，免去了自己搭建服务器和写数据库的麻烦。此外还可以绑定自己的域名。</p><p>这是 Github Pages 的官网 <a href="https://pages.github.com/">Github Pages</a></p><blockquote><p>Hexo</p></blockquote><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><p>这是 Hexo 的官网 <a href="https://hexo.io/zh-cn/">Hexo</a></p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><ol><li><strong>node.js</strong></li><li><strong>git</strong></li></ol><p>这两个应用windows用户直接搜索下载安装就可以。 如果习惯了使用linux命令的朋友，推荐windows神器<code>cmder</code>。 可以直接在windows环境下使用linux命令，样式可调，再也不要用黑乎乎的cmd了，而且自带git，完全可以不用下载windows git。</p><h3 id="正式安装hexo"><a href="#正式安装hexo" class="headerlink" title="正式安装hexo"></a>正式安装hexo</h3><p><a href="https://hexo.io/zh-cn/docs/">hexo官方中文文档</a></p><p>在node.js安装好的前提下，全局安装hexo 如何判断node.js是否安装成功？执行以下命令，如果能够看到版本号则说明安装成功了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure><p>安装<code>hexo</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>自选合适的目录，新建文件夹<folder></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd &lt;folder&gt;</span><br><span class="line">hexo init</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>不再赘述，直接看官方文档。</p><h3 id="配置github"><a href="#配置github" class="headerlink" title="配置github"></a>配置github</h3><p>新建仓库，仓库名必须为**[your_name.github.io]**</p><blockquote><p>补充：本地配置github ssh连接，方便自动部署，以及clone你喜欢的主题(theme)</p></blockquote><p>windows用户直接在<code>c:/用户/youername/.ssh/</code>下查看是否有<code>id_rsa.pub</code>文件。 没有的话命令行执行命令<code>ssh-keygen -t rsa -C &quot;your eamil&quot;</code>，会自动生成<code>id_rsa.pub</code>文件，打开后复制。</p><p>github-&gt;头像-&gt;Settings→SSH kyes→Add SSH key，粘贴复制的内容。</p><p>配置本地账户</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name “your_username” #设置用户名</span><br><span class="line">git config --global user.email “your_email” #设置邮箱地址,最好使用注册邮箱地址</span><br></pre></td></tr></table></figure><p>测试是否配置成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><h3 id="hexo配置以及使用"><a href="#hexo配置以及使用" class="headerlink" title="hexo配置以及使用"></a>hexo配置以及使用</h3><p>有两个配置文件：</p><ul><li>一个是根目录下的<code>_config.yml</code>称为<code>站点配置</code>文件</li><li>一个是<code>themes/landscape/_config.yml</code>称为<code>主题配置</code>文件(默认主题：landscape)</li></ul><p>站点配置如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">url: https://yourname.github.io/</span><br><span class="line">theme: landscape #选择你想用的主题，我用的是indigo</span><br><span class="line">deploy:</span><br><span class="line">    type: git # 不要使用github</span><br><span class="line">    repo: git@github.com:pengwenwu/pengwenwu.github.io.git # 使用ssh连接</span><br><span class="line">    branch: master # 默认master分支</span><br><span class="line">    message: add new blog # 自动部署commit备注，可不填</span><br></pre></td></tr></table></figure><h4 id="hexo常用命令"><a href="#hexo常用命令" class="headerlink" title="hexo常用命令"></a>hexo常用命令</h4><p><a href="https://segmentfault.com/a/1190000002632530">hexo命令参考</a></p><p><code>hexo n &quot;我的博客&quot;</code> &#x3D;&#x3D; <code>hexo new &quot;我的博客&quot;</code> #新建文章<br><code>hexo p</code> &#x3D;&#x3D; <code>hexo publish</code><br><code>hexo g</code> &#x3D;&#x3D; <code>hexo generate</code> #生成<br><code>hexo s</code> &#x3D;&#x3D; <code>hexo server</code> #启动服务本地预览<br><code>hexo d</code> &#x3D;&#x3D; <code>hexo deploy</code> #部署<br><code>hexo clean</code> #清除缓存 网页正常情况下可以忽略此条命令</p><p><code>hexo server</code> #Hexo 会监视文件变动并自动更新，您无须重启服务器。<br><code>hexo server -s</code> #静态模式<br><code>hexo server -p 5000</code> #更改端口<br><code>hexo server -i 192.168.1.1</code> #自定义 IP</p><p>在执行之前，记得安装自动部署 (–save 加不加的区别在于是否写入到依赖文件package.json中)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>正常本地预览，直接执行<code>hexo s</code>,如果要发布话最好执行<code>clean</code>命令，会去删除生成的public文件，完整部署命令:<code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code>。或者直接<code>hexo d -g</code></p><h3 id="注意问题"><a href="#注意问题" class="headerlink" title="注意问题"></a>注意问题</h3><p>安装完自动部署后，是不需要本地git init新建仓库的。执行<code>hexo g</code>会在根目录生成public文件夹，自动部署， 本质是将public文件夹内容全部提交到仓库中去，默认会访问编译好的index.html。</p><p>如果部署完，访问your_name.github.io 404,可能有下面几个原因</p><ol><li>首先检查仓库文件，是不是全都是public的文件内容，如果整个本地blog文件夹都提交了，首先清空 仓库，然后删除本地<code>.deploy_git</code>文件夹，再重新部署</li><li>文件有报错，本地<code>hexo s</code>观察是否有报错。</li></ol><p>不喜欢原主题的朋友，可以github去找喜欢的主题。执行命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone XXXX.next.git themes\next</span><br></pre></td></tr></table></figure><p>这个会将新的主题下载到themes下对应的next目录，next为主题的名字。</p><p>主题的配置，可以看文档，修改对应的<code>主题配置</code>文件。<br>我使用的主题是<code>indigo</code>,详细文档<a href="https://github.com/yscoder/hexo-theme-indigo">indigo</a></p><p><code>markdown</code>不会使用的朋友，参考链接<a href="https://www.appinn.com/markdown/">markdown中文文档</a><br>如果没有ide的话，可以使用在线预览<a href="https://www.zybuluo.com/mdeditor">Cmd Markdown</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web前端程序员简历模板</title>
      <link href="/2023/06/20/Web%E5%89%8D%E7%AB%AF%E7%A8%8B%E5%BA%8F%E5%91%98%E7%AE%80%E5%8E%86%E6%A8%A1%E6%9D%BF/"/>
      <url>/2023/06/20/Web%E5%89%8D%E7%AB%AF%E7%A8%8B%E5%BA%8F%E5%91%98%E7%AE%80%E5%8E%86%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="Web前端程序员简历模板"><a href="#Web前端程序员简历模板" class="headerlink" title="Web前端程序员简历模板"></a>Web前端程序员简历模板</h1><p>本简历模板由国内首家互联网人才拍卖网站「 <a href="http://www.jobdeer.com/">JobDeer.com</a> 」提供。</p><p>（括号里的是我们的顾问编写的说明，建议在简历书写完成后统一删除）</p><h2 id="先讲讲怎样才是一份好的技术简历"><a href="#先讲讲怎样才是一份好的技术简历" class="headerlink" title="先讲讲怎样才是一份好的技术简历"></a>先讲讲怎样才是一份好的技术简历</h2><p>首先，一份好的简历不光说明事实，更通过FAB模式来增强其说服力。</p><ul><li>Feature：是什么</li><li>Advantage：比别人好在哪些地方</li><li>Benefit：如果雇佣你，招聘方会得到什么好处</li></ul><p>其次，写简历和写议论文不同，过分的论证会显得自夸，反而容易引起反感，所以要点到为止。这里的技巧是，提供论据，把论点留给阅读简历的人自己去得出。放论据要具体，最基本的是要数字化，好的论据要让人印象深刻。</p><p>举个例子，下边内容是虚构的：</p><p>2006年，我参与了手机XX网发布系统WAPCMS的开发（<code>这部分是大家都会写的</code>）。作为核心程序员，我不但完成了网站界面、调度队列的开发工作，更提出了高效的组件级缓存系统，通过碎片化缓冲有效的提升了系统的渲染效率。（<code>这部分是很多同学忘掉的，要写出你在这个项目中具体负责的部分，以及你贡献出来的价值。</code>）在该系统上线后，Web前端性能从10QPS提升到200QPS，服务器由10台减少到3台（<code>通过量化的数字来增强可信度</code>）。2008年我升任WAPCMS项目负责人，带领一个3人小组支持着每天超过2亿的PV（<code>这就是Benefit。你能带给前雇主的价值，也就是你能带给新雇主的价值。</code>）。</p><p>有同学问，如果我在项目里边没有那么显赫的成绩可以说怎么办？讲不出成绩时，就讲你的成长。因为学习能力也是每家公司都看中的东西。你可以写你在这个项目里边遇到了一个什么样的问题，别人怎么解决的，你怎么解决的，你的方案好在什么地方，最终这个方案的效果如何。</p><p>具体、量化、有说服力，是技术简历特别需要注重的地方。</p><p>（以上内容在写完简历后，对每一段进行评估，完成后再删除）</p><hr><h1 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h1><p>（HR会打印你的简历，用于在面试的时候联系，所以联系方式放到最上边会比较方便）</p><ul><li>手机：135******** （<code>如果是外地手机，可注明。如经常关机，要写上最优联系时间</code>）</li><li>Email：<a href="mailto:&#x67;&#111;&#111;&#100;&#109;&#x61;&#110;&#x40;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#109;">&#x67;&#111;&#111;&#100;&#109;&#x61;&#110;&#x40;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#109;</a> （<code>虽然我觉得QQ邮箱无所谓，不过有些技术人员比较反感，建议用G</code>）</li><li>QQ&#x2F;微信号：6*******（<code>提供一个通过网络可以联系到你的方式</code>）</li></ul><hr><h1 id="个人信息"><a href="#个人信息" class="headerlink" title="个人信息"></a>个人信息</h1><ul><li><p>胶布帝&#x2F;男&#x2F;1990 </p></li><li><p>本科&#x2F;萌鹿大学计算机系 </p></li><li><p>工作年限：3年</p></li><li><p>微博：<a href="http://weibo.com/jobdeer">@JobDeer</a> （<code>如果没有技术相关内容，也可以不放</code>）</p></li><li><p>技术博客：<a href="http://blog.github.io/">http://blog.github.io</a> ( <code>使用GitHub Host的Big较高</code>  )</p></li><li><p>Github：<a href="http://github.com/geekcompany">http://github.com/geekcompany</a> ( <code>有原创repo的Github帐号会极大的提升你的个人品牌</code>  )</p></li><li><p>期望职位：Web前端高级程序员，应用架构师</p></li><li><p>期望薪资：税前月薪15k~20k，特别喜欢的公司可例外</p></li><li><p>期望城市：北京</p></li></ul><hr><h1 id="工作经历"><a href="#工作经历" class="headerlink" title="工作经历"></a>工作经历</h1><p>（工作经历按逆序排列，最新的在最前边，按公司做一级分组，公司内按二级分组）</p><h2 id="ABC公司-（-2012年9月-2014年9月-）"><a href="#ABC公司-（-2012年9月-2014年9月-）" class="headerlink" title="ABC公司 （ 2012年9月 ~ 2014年9月 ）"></a>ABC公司 （ 2012年9月 ~ 2014年9月 ）</h2><h3 id="DEF项目"><a href="#DEF项目" class="headerlink" title="DEF项目"></a>DEF项目</h3><p>我在此项目负责了哪些工作，分别在哪些地方做得出色&#x2F;和别人不一样&#x2F;成长快，这个项目中，我最困难的问题是什么，我采取了什么措施，最后结果如何。这个项目中，我最自豪的技术细节是什么，为什么，实施前和实施后的数据对比如何，同事和领导对此的反应如何。</p><h3 id="GHI项目"><a href="#GHI项目" class="headerlink" title="GHI项目"></a>GHI项目</h3><p>我在此项目负责了哪些工作，分别在哪些地方做得出色&#x2F;和别人不一样&#x2F;成长快，这个项目中，我最困难的问题是什么，我采取了什么措施，最后结果如何。这个项目中，我最自豪的技术细节是什么，为什么，实施前和实施后的数据对比如何，同事和领导对此的反应如何。</p><h3 id="其他项目"><a href="#其他项目" class="headerlink" title="其他项目"></a>其他项目</h3><p>（每个公司写2~3个核心项目就好了，如果你有非常大量的项目，那么按分类进行合并，每一类选一个典型写出来。其他的一笔带过即可。）</p><h2 id="JKL公司-（-2010年3月-2012年8月-）"><a href="#JKL公司-（-2010年3月-2012年8月-）" class="headerlink" title="JKL公司 （ 2010年3月 ~ 2012年8月 ）"></a>JKL公司 （ 2010年3月 ~ 2012年8月 ）</h2><h3 id="MNO项目"><a href="#MNO项目" class="headerlink" title="MNO项目"></a>MNO项目</h3><p>我在此项目负责了哪些工作，分别在哪些地方做得出色&#x2F;和别人不一样&#x2F;成长快，这个项目中，我最困难的问题是什么，我采取了什么措施，最后结果如何。这个项目中，我最自豪的技术细节是什么，为什么，实施前和实施后的数据对比如何，同事和领导对此的反应如何。</p><h3 id="PQR项目"><a href="#PQR项目" class="headerlink" title="PQR项目"></a>PQR项目</h3><p>我在此项目负责了哪些工作，分别在哪些地方做得出色&#x2F;和别人不一样&#x2F;成长快，这个项目中，我最困难的问题是什么，我采取了什么措施，最后结果如何。这个项目中，我最自豪的技术细节是什么，为什么，实施前和实施后的数据对比如何，同事和领导对此的反应如何。</p><h3 id="其他项目-1"><a href="#其他项目-1" class="headerlink" title="其他项目"></a>其他项目</h3><p>（每个公司写2~3个核心项目就好了，如果你有非常大量的项目，那么按分类进行合并，每一类选一个典型写出来。其他的一笔带过即可。）</p><hr><h1 id="开源项目和作品"><a href="#开源项目和作品" class="headerlink" title="开源项目和作品"></a>开源项目和作品</h1><p>（这一段用于放置工作以外的、可证明你的能力的材料）</p><h2 id="开源项目"><a href="#开源项目" class="headerlink" title="开源项目"></a>开源项目</h2><p>（对于程序员来讲，没有什么比Show me the code能有说服力了）</p><ul><li><a href="http://github.com/yourname/projectname">STU</a>：项目的简要说明，Star和Fork数多的可以注明</li><li><a href="http://github.com/yourname/projectname">WXYZ</a>：项目的简要说明，Star和Fork数多的可以注明</li></ul><h2 id="技术文章"><a href="#技术文章" class="headerlink" title="技术文章"></a>技术文章</h2><p>（挑选你写作或翻译的技术文章，好的文章可以从侧面证实你的表达和沟通能力，也帮助招聘方更了解你）</p><ul><li><a href="http://get.jobdeer.com/706.get">一个产品经理眼中的云计算：前生今世和未来</a></li><li><a href="http://get.jobdeer.com/343.get">来自HeroKu的HTTP API 设计指南(翻译文章)</a> （ <code>好的翻译文章可以侧证你对英文技术文档的阅读能力</code>）</li></ul><h2 id="演讲和讲义"><a href="#演讲和讲义" class="headerlink" title="演讲和讲义"></a>演讲和讲义</h2><p>（放置你代表公司在一些技术会议上做过的演讲，以及你在公司分享时制作的讲义）</p><ul><li>2014架构师大会演讲：<a href="http://jobdeer.com/">如何通过Docker优化内部开发</a></li><li>9月公司内部分享：<a href="http://jobdeer.com/">云计算的前生今世</a></li></ul><h1 id="技能清单"><a href="#技能清单" class="headerlink" title="技能清单"></a>技能清单</h1><p>（我一般主张将技能清单写入到工作经历里边去。不过很难完整，所以有这么一段也不错）</p><p>以下均为我熟练使用的技能</p><ul><li>Web开发：PHP&#x2F;Hack&#x2F;Node</li><li>Web框架：ThinkPHP&#x2F;Yaf&#x2F;Yii&#x2F;Lavaral&#x2F;LazyPHP</li><li>前端框架：Bootstrap&#x2F;AngularJS&#x2F;EmberJS&#x2F;HTML5&#x2F;Cocos2dJS&#x2F;ionic</li><li>前端工具：Bower&#x2F;Gulp&#x2F;SaSS&#x2F;LeSS&#x2F;PhoneGap</li><li>数据库相关：MySQL&#x2F;PgSQL&#x2F;PDO&#x2F;SQLite</li><li>版本管理、文档和自动化部署工具：Svn&#x2F;Git&#x2F;PHPDoc&#x2F;Phing&#x2F;Composer</li><li>单元测试：PHPUnit&#x2F;SimpleTest&#x2F;Qunit</li><li>云和开放平台：SAE&#x2F;BAE&#x2F;AWS&#x2F;微博开放平台&#x2F;微信应用开发</li></ul><h2 id="参考技能关键字"><a href="#参考技能关键字" class="headerlink" title="参考技能关键字"></a>参考技能关键字</h2><p>本技能关键字列表是从最近招聘Web前端的数百份JD中统计出来的，括号中是出现的词频。如果你的简历要投递给有机器（简历分选系统）和不如机器（不懂技术的HR）筛选简历环节的地方，请一定从下边高频关键词中选择5～10个适合你自己的。</p><ul><li>web(889)</li><li>javascript(596)</li><li>css(555)</li><li>html(430)</li><li>jquery(323)</li><li>html5(312)</li><li>js(311)</li><li>ajax(196)</li><li>css3(176)</li><li>w3c(168)</li><li>div(156)</li><li>php(134)</li><li>xhtml(106)</li><li>java(92)</li><li>ui(78)</li><li>photoshop(75)</li><li>dom(63)</li><li>xml(56)</li><li>json(54)</li><li>yui(51)</li><li>flash(45)</li><li>bootstrap(43)</li><li>python(43)</li><li>http(38)</li><li>dreamweaver(38)</li><li>ext(33)</li><li>linux(33)</li><li>seo(32)</li><li>prototype(29)</li><li>chrome(28)</li><li>pc(28)</li><li>nodejs(28)</li><li>firefox(26)</li><li>ps(25)</li><li>angularjs(25)</li><li>fireworks(24)</li><li>extjs(23)</li><li>safari(22)</li><li>www(22)</li><li>mobile(22)</li><li>jsp(22)</li><li>mvc(22)</li><li>backbone(21)</li><li>node(21)</li><li>ruby(20)</li><li>github(19)</li><li>ios(18)</li><li>ie6(18)</li><li>android(18)</li><li>asp(18)</li><li>sass(17)</li><li>wap(16)</li><li>mootools(16)</li><li>ie(16)</li><li>mysql(15)</li><li>flex(14)</li><li>firebug(13)</li><li>bom(13)</li><li>webapp(12)</li><li>less(12)</li><li>web2(11)</li><li>angular(10)</li><li>git(10)</li><li>dw(10)</li><li>as(10)</li><li>mac(10)</li><li>psd(8)</li><li>o2o(7)</li><li>dojo(7)</li><li>actionscript3(6)</li><li>grunt(5)</li><li>ue(5)</li><li>zepto(5)</li><li>actionscript(5)</li><li>ie8(5)</li><li>coffeescript(5)</li><li>django(4)</li></ul><hr><h1 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h1><p>感谢您花时间阅读我的简历，期待能有机会和您共事。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 就业 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用前端开发工具</title>
      <link href="/2023/06/14/%E5%B8%B8%E7%94%A8%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
      <url>/2023/06/14/%E5%B8%B8%E7%94%A8%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="常用前端开发工具"><a href="#常用前端开发工具" class="headerlink" title="常用前端开发工具"></a>常用前端开发工具</h1><h3 id="编辑器-x2F-集成开发环境（IDE）："><a href="#编辑器-x2F-集成开发环境（IDE）：" class="headerlink" title="编辑器&#x2F;集成开发环境（IDE）："></a><strong>编辑器&#x2F;集成开发环境（IDE）：</strong></h3><p>例如 Visual Studio Code、Atom、Sublime Text、WebStorm、Eclipse 等。这些工具提供了代码自动补全、语法高亮、代码格式化、调试等功能，可以提高开发效率。</p><h3 id="版本控制工具："><a href="#版本控制工具：" class="headerlink" title="版本控制工具："></a><strong>版本控制工具：</strong></h3><p>例如 Git、SVN 等。这些工具可以管理代码的版本，帮助团队协作开发，同时也提供了版本回滚、分支管理、代码比较等功能。</p><h3 id="包管理器："><a href="#包管理器：" class="headerlink" title="包管理器："></a><strong>包管理器：</strong></h3><p>例如 npm、yarn 等。这些工具可以方便地安装、管理和更新前端项目所需要的第三方依赖库。</p><h3 id="CSS-预处理器："><a href="#CSS-预处理器：" class="headerlink" title="CSS 预处理器："></a><strong>CSS 预处理器：</strong></h3><p>例如 Sass、Less、Stylus 等。这些工具可以提供更加灵活的 CSS 编写方式，包括变量、混合、嵌套等功能，可以提高 CSS 的复用性和可维护性。</p><h3 id="自动化构建工具："><a href="#自动化构建工具：" class="headerlink" title="自动化构建工具："></a><strong>自动化构建工具：</strong></h3><p>例如 webpack、gulp、grunt 等。这些工具可以自动化地执行一系列任务，例如代码压缩、文件合并、代码分割、打包等，可以提高开发效率和代码质量。</p><h3 id="测试工具："><a href="#测试工具：" class="headerlink" title="测试工具："></a><strong>测试工具：</strong></h3><p>例如 Jest、Mocha、Karma 等。这些工具可以帮助开发人员编写和运行自动化测试，可以提高代码的质量和稳定性。</p><h3 id="调试工具："><a href="#调试工具：" class="headerlink" title="调试工具："></a><strong>调试工具：</strong></h3><p>例如 Chrome DevTools、Firebug、Safari Web Inspector 等。这些工具可以帮助开发人员在浏览器中调试 JavaScript 和<br>CSS，可以快速定位和解决问题。</p><h3 id="设计工具："><a href="#设计工具：" class="headerlink" title="设计工具："></a><strong>设计工具：</strong></h3><p>例如 Sketch、Adobe XD、Axure RP、Figma 等。这些工具可以帮助设计师快速创建原型和设计，可以提高开发效率和设计质量。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 开发工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typora快速入门</title>
      <link href="/2023/06/14/Typora%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
      <url>/2023/06/14/Typora%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Typora语法和功能教程"><a href="#Typora语法和功能教程" class="headerlink" title="Typora语法和功能教程"></a>Typora语法和功能教程</h1><p>Typora是一款流行的Markdown编辑器，它可以帮助用户使用简单的语法来快速创建漂亮的文档。以下是一些常用的Typora语法和功能，供您参考：</p><h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><p>在Typora中，您可以使用#符号来添加标题。#的数量表示标题的级别，例如，# 表示一级标题，## 表示二级标题，以此类推。以下是一个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure><h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><p>Typora支持有序列表和无序列表。无序列表使用*或-表示，有序列表使用数字表示。以下是一个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">* 无序列表项1</span><br><span class="line">* 无序列表项2</span><br><span class="line">* 无序列表项3</span><br><span class="line"></span><br><span class="line">1. 有序列表项1</span><br><span class="line">2. 有序列表项2</span><br><span class="line">3. 有序列表项3</span><br></pre></td></tr></table></figure><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>在Typora中，您可以使用&gt;符号来创建引用块。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; 这是一段引用文本。</span><br></pre></td></tr></table></figure><h1 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h1><p>在Typora中，您可以使用以下语法来插入图片：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![图片描述](图片链接)</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![Typora图片](https://www.typora.io/img/logo-icon.png)</span><br></pre></td></tr></table></figure><h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><p>在Typora中，您可以使用以下语法来创建链接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[链接文本](链接地址)</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Typora官网](https://typora.io/)</span><br></pre></td></tr></table></figure><h1 id="粗体和斜体"><a href="#粗体和斜体" class="headerlink" title="粗体和斜体"></a>粗体和斜体</h1><p>在Typora中，您可以使用以下语法来添加粗体或斜体：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">**粗体文本**</span><br><span class="line">*斜体文本*</span><br></pre></td></tr></table></figure><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>在Typora中，您可以使用以下语法来添加代码块或内联代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">```代码块类型</span><br><span class="line">代码块内容</span><br></pre></td></tr></table></figure><p><code>内联代码</code></p><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hello_world</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello, world!&quot;</span>)</span><br></pre></td></tr></table></figure><p><code>print(&quot;Hello, world!&quot;)</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 表格</span><br><span class="line"></span><br><span class="line">在Typora中，您可以使用以下语法来创建表格：</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">表头1</th><th>表头2</th><th>表头3</th></tr></thead><tbody><tr><td align="left">单元格1</td><td>单元格2</td><td>单元格3</td></tr><tr><td align="left">单元格4</td><td>单元格5</td><td>单元格6</td></tr></tbody></table><h1 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h1><p>Typora支持使用LaTeX语法来插入数学公式。以下是一些常用的数学公式语法</p><ol><li><p>上下标：</p><ul><li>上标：使用 <code>^</code> 符号，例如：<code>x^2</code> 表示 x 的平方；</li><li>下标：使用 <code>_</code> 符号，例如：<code>x_1</code> 表示 x 的下标为 1。</li></ul></li><li><p>分式：</p><p>使用 <code>\frac&#123;分子&#125;&#123;分母&#125;</code> 表示一个分式，例如：<code>\frac&#123;1&#125;&#123;2&#125;</code> 表示 1&#x2F;2。</p></li><li><p>根式：</p><ul><li>平方根：使用 <code>\sqrt&#123;被开方数&#125;</code> 表示平方根，例如：<code>\sqrt&#123;2&#125;</code> 表示 2 的平方根；</li><li>n次方根：使用 <code>\sqrt[n]&#123;被开方数&#125;</code> 表示 n 次方根，例如：<code>\sqrt[3]&#123;8&#125;</code> 表示 8 的 3 次方根。</li></ul></li><li><p>希腊字母：</p><p>使用 <code>\字母名</code> 表示希腊字母，例如：<code>\alpha</code> 表示 α，<code>\beta</code> 表示 β，以此类推。</p></li><li><p>运算符号：</p><ul><li>加减乘除：使用 <code>+</code>、<code>-</code>、<code>*</code>、<code>/</code> 表示加、减、乘、除；</li><li>求和、求积：使用 <code>\sum</code>、<code>\prod</code> 表示求和、求积；</li><li>极限、积分：使用 <code>\lim</code>、<code>\int</code> 表示极限、积分；</li><li>等于、不等于：使用 <code>=</code>、<code>\neq</code> 表示等于、不等于；</li><li>大于、小于：使用 <code>&gt;</code>、<code>&lt;</code> 表示大于、小于；</li><li>大于等于、小于等于：使用 <code>\geq</code>、<code>\leq</code> 表示大于等于、小于等于。</li></ul></li><li><p>矩阵：</p><p>使用 <code>\begin&#123;matrix&#125;...\end&#123;matrix&#125;</code> 表示一个矩阵，例如：</p></li></ol><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;matrix&#125;</span><br><span class="line">1 <span class="built_in">&amp;</span> 2 <span class="built_in">&amp;</span> 3 <span class="keyword">\\</span></span><br><span class="line">4 <span class="built_in">&amp;</span> 5 <span class="built_in">&amp;</span> 6 <span class="keyword">\\</span></span><br><span class="line">7 <span class="built_in">&amp;</span> 8 <span class="built_in">&amp;</span> 9</span><br><span class="line"><span class="keyword">\end</span>&#123;matrix&#125;</span><br></pre></td></tr></table></figure><p>以上是一些常用的LaTeX语法，在Typora中插入数学公式时可以使用这些语法。需要注意的是，在Typora中插入数学公式时，需要将LaTeX语法写在<code>$$</code>符号中间，例如：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\sum</span><span class="built_in">_</span>&#123;i=1&#125;<span class="built_in">^</span>n i = <span class="keyword">\frac</span>&#123;n(n+1)&#125;&#123;2&#125;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>这样就可以在Typora中插入数学公式了。</p><h1 id="快捷键大全及使用"><a href="#快捷键大全及使用" class="headerlink" title="快捷键大全及使用"></a>快捷键大全及使用</h1><p>以下是 Typora 常用的快捷键大全，使用 Markdown 语法：</p><ol><li>文字格式</li></ol><ul><li><strong>粗体</strong>：使用两个星号（<code>**</code>）将文本包围，如 <code>**这是粗体文本**</code>。</li><li><em>斜体</em>：使用一个星号（<code>*</code>）将文本包围，如 <code>*这是斜体文本*</code>。</li><li><u>下划线</u>：使用 HTML 标签 <code>&lt;u&gt;</code> 包围文本，如 <code>&lt;u&gt;这是下划线文本&lt;/u&gt;</code>。</li><li><del>删除线</del>：使用两个波浪线（<code>~~</code>）将文本包围，如 <code>~~这是删除线文本~~</code>。</li><li><code>等宽字体</code>：使用反引号（&#96;&#96;&#96;）将文本包围，如 <code>这是等宽字体文本</code>。</li></ul><ol><li>段落格式</li></ol><ul><li><h1 id="标题-1：在文本前添加-号，如-这是标题-1。"><a href="#标题-1：在文本前添加-号，如-这是标题-1。" class="headerlink" title="标题 1：在文本前添加 # 号，如 # 这是标题 1。"></a>标题 1：在文本前添加 <code>#</code> 号，如 <code># 这是标题 1</code>。</h1></li><li><h2 id="标题-2：在文本前添加-号，如-这是标题-2。"><a href="#标题-2：在文本前添加-号，如-这是标题-2。" class="headerlink" title="标题 2：在文本前添加 ## 号，如 ## 这是标题 2。"></a>标题 2：在文本前添加 <code>##</code> 号，如 <code>## 这是标题 2</code>。</h2></li><li><h3 id="标题-3：在文本前添加-号，如-这是标题-3。"><a href="#标题-3：在文本前添加-号，如-这是标题-3。" class="headerlink" title="标题 3：在文本前添加 ### 号，如 ### 这是标题 3。"></a>标题 3：在文本前添加 <code>###</code> 号，如 <code>### 这是标题 3</code>。</h3></li><li><p>段落：段落之间留空行即可。</p></li></ul><ol><li>列表格式</li></ol><ul><li><p>无序列表：使用减号（</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-</span><br></pre></td></tr></table></figure><p>）、加号（</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+</span><br></pre></td></tr></table></figure><p>）或星号（</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*</span><br></pre></td></tr></table></figure><p>）后加空格，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">diffCopy code- 第一项</span><br><span class="line">- 第二项</span><br></pre></td></tr></table></figure></li><li><p>有序列表：使用数字后加英文句点（</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.</span><br></pre></td></tr></table></figure><p>）和空格，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">markdownCopy code1. 第一项</span><br><span class="line">2. 第二项</span><br></pre></td></tr></table></figure></li></ul><ol><li>插入</li></ol><ul><li><p>插入图片：使用 <code>![](图片链接地址)</code>，如 <code>![](https://example.com/image.jpg)</code>。</p></li><li><p>插入链接：使用 <code>[链接文本](链接地址)</code>，如 <code>[这是一个链接](https://example.com)</code>。</p></li><li><p>插入表格：使用 Markdown 表格语法，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">luaCopy code| 表头1 | 表头2 |</span><br><span class="line">|-------|-------|</span><br><span class="line">| 内容1 | 内容2 |</span><br><span class="line">| 内容3 | 内容4 |</span><br></pre></td></tr></table></figure></li><li><p>插入代码块：使用三个反引号（</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">```</span><br></pre></td></tr></table></figure><p>）包围代码块，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copy code</span><br></pre></td></tr></table></figure><p>这是代码块</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copy code</span><br></pre></td></tr></table></figure></li></ul><ol><li>格式化</li></ol><ul><li>引用：在文本前添加大于号（<code>&gt;</code>），如 <code>&gt; 这是引用的文本</code>。</li><li>转义字符：使用反斜杠（<code>\</code>）对特殊字符进行转义，如 <code>\#</code> 表示 <code>#</code>。</li><li>转换为大写：使用大写字母 <code>U</code> 和反斜杠（<code>\</code>）组合，如 <code>\U 这是大写的文本</code>。</li><li>转换为小写：使用小写字母 <code>L</code> 和反斜杠（<code>\</code>）组合，如 &#96;\</li></ul><h1 id="纯净快捷键"><a href="#纯净快捷键" class="headerlink" title="纯净快捷键"></a>纯净快捷键</h1><table><thead><tr><th>快捷键</th><th>功能</th></tr></thead><tbody><tr><td>Ctrl + B</td><td>粗体</td></tr><tr><td>Ctrl + I</td><td>斜体</td></tr><tr><td>Ctrl + U</td><td>下划线</td></tr><tr><td>Ctrl + Shift + ]</td><td>增大字号</td></tr><tr><td>Ctrl + Shift + [</td><td>减小字号</td></tr><tr><td>Ctrl + 0</td><td>正文格式</td></tr><tr><td>Ctrl + 1</td><td>标题 1 格式</td></tr><tr><td>Ctrl + 2</td><td>标题 2 格式</td></tr><tr><td>Ctrl + 3</td><td>标题 3 格式</td></tr><tr><td>Ctrl + L</td><td>左对齐</td></tr><tr><td>Ctrl + R</td><td>右对齐</td></tr><tr><td>Ctrl + E</td><td>居中</td></tr><tr><td>Ctrl + J</td><td>两端对齐</td></tr><tr><td>Ctrl + Shift + L</td><td>项目符号列表</td></tr><tr><td>Ctrl + Shift + O</td><td>编号列表</td></tr><tr><td>Ctrl + Shift + I</td><td>插入图片</td></tr><tr><td>Ctrl + Shift + T</td><td>插入表格</td></tr><tr><td>Ctrl + Shift + E</td><td>插入代码块</td></tr><tr><td>Ctrl + K</td><td>插入链接</td></tr><tr><td>Ctrl + Shift + H</td><td>插入横线</td></tr><tr><td>Ctrl + Shift + X</td><td>删除线</td></tr><tr><td>Ctrl + Shift + M</td><td>数学公式</td></tr><tr><td>Ctrl + Shift + Q</td><td>引用</td></tr><tr><td>Ctrl + Shift + U</td><td>转换为大写</td></tr><tr><td>Ctrl + Shift + L</td><td>转换为小写</td></tr><tr><td>Ctrl + Shift + ]</td><td>增加标题层级</td></tr><tr><td>Ctrl + Shift + [</td><td>减少标题层级</td></tr><tr><td>Ctrl + F</td><td>查找</td></tr><tr><td>Ctrl + H</td><td>替换</td></tr><tr><td>Ctrl + Shift + F</td><td>查找并替换</td></tr><tr><td>Ctrl + Shift + G</td><td>跳转到下一个标题</td></tr><tr><td>Ctrl + Shift + F6</td><td>关闭所有文档</td></tr><tr><td>Ctrl + Tab</td><td>切换到下一个标签页</td></tr><tr><td>Ctrl + Shift + Tab</td><td>切换到上一个标签页</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> Typora </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typora的安装与使用</title>
      <link href="/2023/06/14/Typora%E5%AE%89%E8%A3%85%E4%B8%8E%E7%A0%B4%E8%A7%A3/"/>
      <url>/2023/06/14/Typora%E5%AE%89%E8%A3%85%E4%B8%8E%E7%A0%B4%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Typora的安装与使用"><a href="#Typora的安装与使用" class="headerlink" title="Typora的安装与使用"></a>Typora的安装与使用</h2><h4 id="Typora下载"><a href="#Typora下载" class="headerlink" title="Typora下载"></a>Typora下载</h4><p>Typora官网（需要科学上网）：<a href="https://typora.io/">https://typora.io/</a></p><p><a href="https://imgse.com/i/p97NwY4"><img src="https://s1.ax1x.com/2023/05/24/p97NwY4.md.png" alt="p97NwY4.md.png"></a></p><blockquote><p>划至网页下方找到 <code>Download</code>选择自己相应的系统下载</p></blockquote><h4 id="Typora正版破解"><a href="#Typora正版破解" class="headerlink" title="Typora正版破解"></a>Typora正版破解</h4><p>破解网站（全版本更新）<a href="https://github.com/Delppine1024/TGreen">https://github.com/Delppine1024/TGreen</a></p><p><a href="https://imgse.com/i/p97N0fJ"><img src="https://s1.ax1x.com/2023/05/24/p97N0fJ.md.png" alt="p97N0fJ.md.png"></a></p><p>有能力的话可以自行查看官方文档 <code>README-CN.md</code>（或移步至阿闲教程）</p><h4 id="阿闲教程"><a href="#阿闲教程" class="headerlink" title="阿闲教程"></a>阿闲教程</h4><p>查看自己所下载的 Typora 版本并点击<strong>（这里以<a href="mailto:&#68;&#111;&#119;&#x6e;&#108;&#x6f;&#97;&#x64;&#x40;&#x76;&#49;&#46;&#53;&#46;&#49;&#48;">&#68;&#111;&#119;&#x6e;&#108;&#x6f;&#97;&#x64;&#x40;&#x76;&#49;&#46;&#53;&#46;&#49;&#48;</a>）举例</strong></p><p><a href="https://imgse.com/i/p97NDp9"><img src="https://s1.ax1x.com/2023/05/24/p97NDp9.md.png" alt="p97NDp9.md.png"></a></p><p>点击后进入到发布页面</p><p>从<strong>Github Releases</strong>中下载与Typora的安装版本和<strong>系统版本</strong>相符的文件</p><p><a href="https://imgse.com/i/p97NUTU"><img src="https://s1.ax1x.com/2023/05/24/p97NUTU.md.png" alt="p97NUTU.md.png"></a></p><p>下载之后解压得到 <code>app.asar</code> 文件</p><p>将提取到的文件<code>app.asar</code>复制或替换到自己所安装的 Typora 路径下的 resources 文件夹</p><p>重新启动 Typora</p><p><a href="https://imgse.com/i/p97NdkF"><img src="https://s1.ax1x.com/2023/05/24/p97NdkF.md.png" alt="p97NdkF.md.png"></a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Typora </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typora详细手册</title>
      <link href="/2023/06/14/Typora%20%E8%AF%A6%E7%BB%86%E6%89%8B%E5%86%8C/"/>
      <url>/2023/06/14/Typora%20%E8%AF%A6%E7%BB%86%E6%89%8B%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="Typora-Markdown-手册"><a href="#Typora-Markdown-手册" class="headerlink" title="Typora Markdown 手册"></a>Typora Markdown 手册</h1><h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p><strong>Markdown</strong> 是<a href="http://daringfireball.net/">Daring Fireball</a> 发明的，这是<a href="http://daringfireball.net/projects/markdown/syntax">官方的指导手册连接</a>。然而，其语法根据不同的编辑器和编辑者而异。<strong>Typora</strong>使用的是<a href="https://help.github.com/categories/writing-on-github/">GitHub Flavored Markdown</a> 。</p><p>注意，Markdown中的html片段会被识别，但是不会实时解析或呈现，另外，原始的Markdown源文件被保存后可能会重新格式化。</p><h2 id="块元素"><a href="#块元素" class="headerlink" title="块元素"></a>块元素</h2><h3 id="段落和换行"><a href="#段落和换行" class="headerlink" title="段落和换行"></a>段落和换行</h3><p>一个段落只是一个或者多个连续的文本行。在Markdown源代码中，段落由多个空白行分隔。在Typora，你只需要按 <code>回车键</code>来创建一个新的段落。</p><p>按<code>Shift</code>+<code>Enter</code>创建一个换行符。然而，大多数的编辑器会忽略单行中端，为了让其它的Markdown编辑器识别你的换行符，可以在行尾留下两个空格或者插入<code>&lt;br/&gt;</code>。</p><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>标题在行的开始使用1-6个散列字符，对应1-6的标题级别，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 这是一级标题</span><br><span class="line"></span><br><span class="line">## 这是二级标题</span><br><span class="line"></span><br><span class="line">### 这是三级标题</span><br></pre></td></tr></table></figure><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><p>在typora中，输入一个或多个<code>#</code>，然后输入标题内容，按下回车键就会创建一个标题。</p><p>注：部分功能需要在偏好设置中开启，如上下标、行内公式、图表等。Markdown写法参考说明文档<a href="https://support.typora.io/Markdown-Reference">🚀</a>，试用其他如印象等在线Markdown编辑器[<a href="https://www.zybuluo.com/mdeditor">Ref 1</a>,<a href="https://maxiang.io/">Ref 2</a>,<a href="https://editoe.com/">Ref 3</a>,<a href="https://b3log.org/vditor">Ref 4</a>]</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>Markdown使用电子邮件风格&gt;字符进行块引用。他们被表示为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; 这是一个包含两段的blockquote。这是第一段</span><br><span class="line">&gt;</span><br><span class="line">&gt; 这是第二段。Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.我也不知道这事啥意思</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; 这是另一个有一个段落的blockquote。两个区块引用之间有三个空白行分隔。</span><br></pre></td></tr></table></figure><p>在typora中，只需输入’&gt;’后跟引用内容就会生成一个块引用。 Typora将为您插入适当的“&gt;”或换行符。 通过添加额外的“&gt;”级别可以允许在另一个块引用内嵌一个引号。</p><p>可以直接用尖括号包裹URL链接或邮箱<a href="https://emojixd.com/">https://emojixd.com/</a></p><blockquote><p>提示块标签</p><blockquote><p>嵌套提示块</p></blockquote></blockquote><blockquote><p>💻提示块 emoji</p></blockquote><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>输入<code>* list item 1</code>将创建一个无序的列表，<code>*</code>符号可以使用<code>+</code>或者<code>-</code>代替。</p><p>输入<code>1. list item 1</code>将创建一个有序列表，他们的Markdown源代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">## un-ordered list</span><br><span class="line">*   Red</span><br><span class="line">*   Green</span><br><span class="line">*   Blue</span><br><span class="line"></span><br><span class="line">## ordered list</span><br><span class="line">1.  Red</span><br><span class="line">2. Green</span><br><span class="line">3.Blue</span><br></pre></td></tr></table></figure><ul><li>无序列表1</li><li>无序列表2</li></ul><ol><li>有序列表1</li><li>有序列表2</li></ol><h3 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h3><p>任务列表是标有[ ] 或者[x] (未完成或者完成)的列表，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- [ ] a task list item</span><br><span class="line">- [ ] list syntax required</span><br><span class="line">- [ ] normal **formatting**, @mentions, #1234 refs</span><br><span class="line">- [ ] incomplete</span><br><span class="line">- [x] completed</span><br></pre></td></tr></table></figure><ul><li><input disabled="" type="checkbox"> 未完成任务1</li><li><input disabled="" type="checkbox"> 未完成任务2</li><li><input checked="" disabled="" type="checkbox"> 未完成任务1</li><li><input checked="" disabled="" type="checkbox"> 未完成任务2</li></ul><p>可以通过单击项目之前的复选框来更改完成&#x2F;未完成的状态。</p><p>代码块</p><p>Typora只支持Github Flavored Markdown中的栅栏。不支持原始代码块中的标记。</p><p>使用代码块很容易，输入<code>然后按下`entre`键。在</code>之后添加一个可选的语言标识符，我们将通过它进行语法高亮：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line">```</span><br><span class="line">function test()&#123;</span><br><span class="line">  console.log(&quot;notice the blank line before this function?&quot;);</span><br><span class="line">&#125;</span><br><span class="line">```</span><br><span class="line">语法高亮：</span><br><span class="line">``` java</span><br><span class="line">String str = new String(&quot;hello world!&quot;);</span><br><span class="line">System.out.println(str)</span><br><span class="line">```</span><br></pre></td></tr></table></figure><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>输入<code>|第一个标题|第二个标题|</code>然后按下<code>enter</code>键讲话创建一个有两列的表格。</p><p>创建表之后，在该表上将弹出一个表的工具栏，您可以在其中调整大小，对齐或删除表。 还可以使用上下文菜单来复制和添加&#x2F;删除列&#x2F;行。</p><p>以下描述可以跳过，因为表的markdown源代码是由typora自动生成的。表格中可以使用链接、粗体、斜体、或删除线等格式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| First Header  | Second Header |</span><br><span class="line">| ------------- | ------------- |</span><br><span class="line">| Content Cell  | Content Cell  |</span><br><span class="line">| Content Cell  | Content Cell  |</span><br></pre></td></tr></table></figure><table><thead><tr><th>First Header</th><th>Second Header</th></tr></thead><tbody><tr><td>Content Cell</td><td>Content Cell</td></tr><tr><td>Content Cell</td><td>Content Cell</td></tr></tbody></table><p>最后，通过冒号<code>：</code>在标题行中，可以定义文本对齐方式，最左侧的买好表示左对齐，最右侧的冒号表示右对齐，两次都有冒号表示中心对齐。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| Left-Aligned  | Center Aligned  | Right Aligned |</span><br><span class="line">| :------------ |:---------------:| -----:|</span><br><span class="line">| col 3 is      | some wordy text | $1600 |</span><br><span class="line">| col 2 is      | centered        |   $12 |</span><br><span class="line">| zebra stripes | are neat        |    $1 |</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">Left-Aligned</th><th align="center">Center Aligned</th><th align="right">Right Aligned</th></tr></thead><tbody><tr><td align="left">col 3 is</td><td align="center">some wordy text</td><td align="right">$1600</td></tr><tr><td align="left">col 2 is</td><td align="center">centered</td><td align="right">$12</td></tr><tr><td align="left">zebra stripes</td><td align="center">are neat</td><td align="right">$1</td></tr></tbody></table><h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">你可以使用脚注像这样[^脚注]</span><br><span class="line">[^脚注]: 这里写脚注的*文本*</span><br></pre></td></tr></table></figure><p>实现效果：</p><p>你可以使用脚注像这样[^脚注]</p><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p>在空白行输入<code>***</code>或者<code>---</code> 然后按<code>enter</code>键会出现分割线</p><hr><h3 id="YAML-Front-Matter"><a href="#YAML-Front-Matter" class="headerlink" title="YAML Front Matter"></a>YAML Front Matter</h3><p>Typora 支持<a href="http://jekyllrb.com/docs/frontmatter/">YAML Front Matter</a>。输入<code>---</code>在文章的顶端然后按下<code>Enter</code>键就会采用或者从菜单中插入一个元数据块。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p>输入<code>[toc]</code>，然后按<code>enter</code>键将创建一个“目录”部分，从一个人的写作中提取所有标题，其内容将自动更新。</p><p>[toc]</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>Markdown支持两种风格的链接：内联和引用。在两种样式中，链接文本由[方括号]分隔。</p><p>要创建内联链接，请在链接文本的关闭方括号后立即使用一组常规括号。 在括号内，将链接所在的网址与链接的可选标题一起放在引号中。 例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">This is [an example](http://example.com/ &quot;Title&quot;) inline link.</span><br><span class="line"></span><br><span class="line">[This link](http://example.net/) has no title attribute.</span><br></pre></td></tr></table></figure><p>实现效果：</p><p>This is <a href="http://example.com/%22Title%22">an example</a> inline link. (<code>&lt;p&gt;This is &lt;a href=&quot;http://example.com/&quot; title=&quot;Title&quot;&gt;</code>)</p><p><a href="http://example.net/">This link</a> has no title attribute. (<code>&lt;p&gt;&lt;a href=&quot;http://example.net/&quot;&gt;This link&lt;/a&gt; has no</code>)</p><h4 id="内部链接"><a href="#内部链接" class="headerlink" title="内部链接"></a>内部链接</h4><p>你可以将标题设置为一个连接，我们会创建一个书签，允许你点击标题后，跳转到文章中指定的部分，例如：</p><p>Ctrl(On Mac：Command) + Click<a href="https://renshuo555.github.io/2017/04/28/markdown-typora/#%E5%9D%97%E5%85%83%E7%B4%A0">This link</a>会跳转到块元素标题的位置 ，要查看如何写入，请移动光标或单击该链接，按⌘键将元素展开为markdown源。</p><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p>参考样式链接使用第二组方括号，您可以在其中放置您选择的标签来标识链接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">This is [an example][id] reference-style link.</span><br><span class="line"></span><br><span class="line">Then, anywhere in the document, you define your link label like this, on a line by itself:</span><br><span class="line"></span><br><span class="line">[id]: http://example.com/  &quot;Optional Title Here&quot;</span><br></pre></td></tr></table></figure><p>在typora中，他们会被渲染为：</p><p>This is <a href="http://example.com/">an example</a> reference-style link.</p><p>隐式链接名称快捷方式允许您省略链接的名称，在这种情况下，将链接文本本身用作名称。 只需使用一组空白方括号 - 例如将Google“Google”链接到google.com网站，您可以简单地写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[Google][]</span><br><span class="line">And then define the link:</span><br><span class="line"></span><br><span class="line">[Google]: http://google.com/</span><br></pre></td></tr></table></figure><p>在typora中，点击链接将扩展它进行编辑，command+click将打开Web浏览器中的超链接。</p><h3 id="URL地址"><a href="#URL地址" class="headerlink" title="URL地址"></a>URL地址</h3><p>Typora允许插入URL作为链接，用尖括号包起来，<code>&lt;</code>尖括号<code>&gt;</code>。</p><p><code>&lt;i@typora.io&gt;</code> 就变成了<a href="mailto:i@typora.io">i@typora.io</a>.</p><p>Typora也会自动链接标准的URLs，例如：<a href="http://www.google.com/">www.google.com</a></p><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p>图片和链接看起来是一样的，但是图片需要在链接前加上<code>!</code>感叹号字符，图片的语法为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">![Alt text](/path/to/img.jpg)</span><br><span class="line"></span><br><span class="line">![Alt text](/path/to/img.jpg &quot;Optional title&quot;)</span><br></pre></td></tr></table></figure><p>您可以使用拖放来从图像文件或浏览器插入图像。 并通过点击图像修改markdown源代码。 如果图像与当前编辑文档在同一目录或子目录中拖放时，将使用相对路径。</p><p>更多关于图片的文档，请看<a href="http://support.typora.io//Images/">http://support.typora.io//Images/</a></p><h3 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h3><p>Markdown将星号(<code>*</code>)和下划线(<code>_</code>)视为强调的指标，用一个<code>*</code>或<code>_</code>包括的文本，将被HTML中<code>&lt;em&gt;</code>标签包裹，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*single asterisks*</span><br><span class="line"></span><br><span class="line">_single underscores_</span><br></pre></td></tr></table></figure><p>显示：</p><p><em>single asterisks</em></p><p><em>single underscores</em></p><p>GFM会忽略词中的下划线，因为下划线经常被用在代码和名字中，例如：</p><blockquote><p>wow_great_stuff</p><p>do_this_and_do_that_and_another_thing.</p></blockquote><p>要在一个位置上产生一个文字星号或下划线，否则它将被用作强调分隔符，您可以反斜杠逃避它：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\*this text is surrounded by literal asterisks\*</span><br></pre></td></tr></table></figure><p>Typora建议使用<code>*</code>字符。</p><h3 id="加粗"><a href="#加粗" class="headerlink" title="加粗"></a>加粗</h3><p>两个<code>**</code>或<code>__</code>会被HTML中的<code>&lt;strong&gt;</code>标签包裹，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">**double asterisks**</span><br><span class="line"></span><br><span class="line">__double underscores__</span><br></pre></td></tr></table></figure><p>显示：</p><p><strong>double asterisks</strong></p><p><strong>double underscores</strong></p><p>Typora建议使用<code>**</code>字符。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>使用反引号包裹代码，与预格式化的代码块不同，代码段是表示的是正常段落中的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Use the `printf()` function.</span><br></pre></td></tr></table></figure><p>显示：</p><p>Use the <code>printf()</code> function.</p><h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><p>GFM添加了标准Markdown语法没有的下划线语法。</p><p><code>~~Mistaken text.~~</code> 会变成<del>Mistaken text.</del></p><h3 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h3><p>下划线由原始的HTML提供。</p><p><code>&lt;u&gt;Underline&lt;/u&gt;</code> 变成Underline.</p><h3 id="emoji表情：happy"><a href="#emoji表情：happy" class="headerlink" title="emoji表情：happy"></a>emoji表情：happy</h3><p>输入emoji语法：<code>:smile:</code>:smile:</p><p>用户可以通过按“ESC”键触发表情符号的自动完成建议，或在首选面板上启用后自动触发。 此外，还支持从菜单栏中的“Edit” - &gt;“Emoji＆Symbols”直接输入UTF8表情符号。</p><h3 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h3><p>为了使用这个特性，请先在<code>Preference</code>面板中的<code>Markdwn</code>选择开启，然后使用<code>$</code>来包裹TeX命令，例如：<code>$\lim_&#123;x \to \infty&#125; \exp(-x) = 0$</code>，将会渲染为LaTeX命令。</p><p>limx→∞exp(−x)&#x3D;0����→∞exp⁡(−�)&#x3D;0</p><p>要触发内联数学的内联预览：输入“$”，然后按“ESC”键，然后输入TeXT命令，预览工具提示将如下所示可见：</p><p><img src="http://typora.io/img/inline-math.gif" alt="img"></p><p>可以使用<strong>MathJax</strong>渲染<em>LaTeX</em>数学表达式。</p><p>输入<code>$$</code>，然后按下<code>Enter</code>键将触发一个接收<em>Tex&#x2F;LaTeX</em>源码的输入范围。</p><p>例如：<br>$$<br>\mathbf{V}_1 \times \mathbf{V}_2 &#x3D;  \begin{vmatrix}<br>\mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \<br>\frac{\partial X}{\partial u} &amp;  \frac{\partial Y}{\partial u} &amp; 0 \<br>\frac{\partial X}{\partial v} &amp;  \frac{\partial Y}{\partial v} &amp; 0 \<br>\end{vmatrix}<br>$$<br>在Markdown源代码文件中，数学公式是被<code>$$</code>标记的<em>LaTeX</em>表达式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\mathbf&#123;V&#125;_1 \times \mathbf&#123;V&#125;_2 =  \begin&#123;vmatrix&#125; </span><br><span class="line">\mathbf&#123;i&#125; &amp; \mathbf&#123;j&#125; &amp; \mathbf&#123;k&#125; \\</span><br><span class="line">\frac&#123;\partial X&#125;&#123;\partial u&#125; &amp;  \frac&#123;\partial Y&#125;&#123;\partial u&#125; &amp; 0 \\</span><br><span class="line">\frac&#123;\partial X&#125;&#123;\partial v&#125; &amp;  \frac&#123;\partial Y&#125;&#123;\partial v&#125; &amp; 0 \\</span><br><span class="line">\end&#123;vmatrix&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p>行内公式：$ h_\theta(x)&#x3D;\theta_0+\theta_1x $</p><p>行间公式：<br>$$<br>h_\theta(x)&#x3D;\theta_0+\theta_1x<br>$$<br>推荐：<a href="http://draw.mathpix.com/">latex手写公式识别</a>、<a href="https://www.latexlive.com/">latex公式编辑器</a></p><p>可以直接用尖括号包裹URL链接或邮箱：<a href="https://emojixd.com/">https://emojixd.com/</a></p><h3 id="下标和上标"><a href="#下标和上标" class="headerlink" title="下标和上标"></a>下标和上标</h3><p>为了使用这个特性，请先在<code>Preference</code>面板中的<code>Markdwn</code>选择开启。</p><ul><li>使用<code>~</code>来包裹下标内容，例如：<code>H~2~O</code>,H<del>2</del>O， <code>X~long\ text~</code>&#x2F;，X<del>long\ text</del></li><li>使用<code>^</code>包裹上标内容，例如<code>X^2^</code>,X^2^</li></ul><h3 id="HTML支持"><a href="#HTML支持" class="headerlink" title="HTML支持"></a>HTML支持</h3><p>Typora无法呈现HTML片段。 但是Typora可以解析并渲染非常有限的HTML片段，作为Markdown的扩展，包括：</p><ul><li>下划线Underline: <code>&lt;u&gt;underline&lt;/u&gt;</code></li><li>图片Image: <code>&lt;img src=&quot;http://www.w3.org/html/logo/img/mark-word-icon.png&quot; width=&quot;200px&quot; /&gt;</code> (And <code>width</code>, <code>height</code> attribute in HTML tag, and <code>width</code>, <code>height</code>, <code>zoom</code> style in <code>style</code> attribute will be applied.)</li><li>注释Comments: <code>&lt;!-- This is some comments --&gt;</code></li><li>超链接Hyperlink: <code>&lt;a href=&quot;http://typora.io&quot; target=&quot;_blank&quot;&gt;link&lt;/a&gt;</code>.</li></ul><p>他们的大部分属性，样式或类将被忽略。 对于其他标签，typora会将其作为原始HTML片段呈现。</p><p>但是这些HTML将被导出打印或导出。</p><p>关于Typora对HTML的支持说明：<a href="https://support.typora.io/HTML/">https://support.typora.io/HTML/</a></p><h4 id="音频"><a href="#音频" class="headerlink" title="音频"></a>音频</h4><p>可以将<code>&lt;audio&gt;</code>音频包裹在<code>&lt;center&gt;&lt;/center&gt;</code>中居中显示</p><p><audio controls="controls" style="box-sizing: border-box; color: rgb(0, 0, 0); font-family: &quot;Source Sans Pro&quot;, &quot;等距更纱黑体 SC&quot;, &quot;Helvetica Neue&quot;, Arial, sans-serif; font-size: 17px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"></audio></p><h4 id="外链播放器"><a href="#外链播放器" class="headerlink" title="外链播放器"></a>外链播放器</h4><p>插入网易云的外链播放器（<code>&lt;iframe&gt;</code>，可嵌入油管等平台视频）</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" src="https://music.163.com/outchain/player?type=2&amp;id=1342183925&amp;auto=0" style="box-sizing: border-box; margin: auto; max-width: 100%; width: 800px; border: none; color: rgb(0, 0, 0); font-family: &quot;Source Sans Pro&quot;, &quot;等距更纱黑体 SC&quot;, &quot;Helvetica Neue&quot;, Arial, sans-serif; font-size: 17px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"></iframe><h4 id="折叠标签"><a href="#折叠标签" class="headerlink" title="折叠标签"></a>折叠标签</h4><details style="box-sizing: border-box; display: block; padding: 16px; margin: 1em 0px; border-radius: 4px; background: var(--bg-color); font-size: 14px; transition: all 0.28s ease 0s; border: 1px solid var(--bg-color); color: rgb(0, 0, 0); font-family: &quot;Source Sans Pro&quot;, &quot;等距更纱黑体 SC&quot;, &quot;Helvetica Neue&quot;, Arial, sans-serif; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="box-sizing: border-box; display: list-item; cursor: pointer; padding: 16px; margin: -16px; border-radius: 4px; color: var(--detailstxt-color); font-weight: 700; position: relative; line-height: normal; font-size: 0.875rem !important; background: var(--detailsbg-color);">折叠标签</summary><p style="box-sizing: border-box; line-height: 1.8rem; orphans: 4; margin: 0.8em 0px; white-space: pre-wrap; width: inherit; position: relative; word-spacing: 0.05rem; color: var(--para-color);"><code style="box-sizing: border-box; font-family: var(--code-font); text-align: left; vertical-align: initial; padding: 2px 4px; border-radius: 2px; font-size: 0.9rem; color: var(--code-color); background-color: var(--codebg-color);"></code></p><iframe src="https://webstack.muggledy.top/plays/pdfv/?url=https://files.catbox.moe/5iz1r9.pdf" height="400" frameborder="0" scrolling="no" style="box-sizing: border-box; margin: auto; max-width: 100%; width: 766.667px; border: none;"></iframe></details><h4 id="嵌入式绘图"><a href="#嵌入式绘图" class="headerlink" title="嵌入式绘图"></a>嵌入式绘图</h4><p>以下两种嵌入式绘图虽然更加美观，但是都无法在typora中直接编辑，只能用于查看，不太方便</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" height="320px" src="https://typora-dyzj-theme.vercel.app/temp/markmap.html" width="" style="box-sizing: border-box; margin: auto; max-width: 100%; width: 800px; border: none; color: rgb(0, 0, 0); font-family: &quot;Source Sans Pro&quot;, &quot;等距更纱黑体 SC&quot;, &quot;Helvetica Neue&quot;, Arial, sans-serif; font-size: 17px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"></iframe><p>该脑图由<a href="https://markmap.js.org/">markmap</a>提供支持，其直接将MD格式代码转换为脑图，可以作为VS Code的插件使用</p><p><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" height="400px" viewBox="-0.5 -0.5 1071 773" content="<mxfile host=&quot;app.diagrams.net&quot; modified=&quot;2021-11-15T07:08:52.373Z&quot; agent=&quot;5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.198 Safari/537.36&quot; etag=&quot;aOnjZZMrixLFimZz001-&quot; version=&quot;15.7.3&quot; type=&quot;google&quot;><diagram id=&quot;07fea595-8f29-1299-0266-81d95cde20df&quot; name=&quot;Page-1&quot;>7Zpdk5o8FMc/jZfrkDeEy3Xdtjed6cx25rnOIylmisbGuGI/fQMEAZN1sY2uW+qNchKS8P9xPOcERuhhmX+UdL34LBKWjWCQ5CM0G0F4F4NQfxWWvbGEpDKkkieVCTSGJ/6TGWNgrFuesE2noxIiU3zdNc7FasXmqmOjUopdt9s3kXVnXdOUWYanOc1s6388UQtjBWHcNHxiPF2YqSM4qRr+p/PvqRTblZlvJVasalnSehhzjZsFTcSuZUKPI/QghVDVr2X+wLJC1lqx6rwPL7QelizZSvU5YQJRdcozzbbmus3K1L4WYrfgij2t6bw43mnYIzT9xrPsQWRCll0QgPf3U6LtqaQJ15PXbeW1N+YZlxoVFyvdxOhGr3G6UVJ8Z0f9F2qZ6SNQzCSa0fRMEGFM9Oqn9qWaq39mUrG8ZTKX/pGJJVNyr7uYVojjydjclOYmBTjEYxI0HyPHrnUH1PAWLfgAGSM1d116mK2RX/8wBF6igYdMI7RpEIxr02sESDAO2tyQDx5kyDwih3fEvXmAwItHhAMmgAIHAdifwMQLgcnrBFiiI6c5fFWhyj8PytaxFVlat/u+qGYx9Ukt2yoFp+5TyTKq+HM3+rukM3N8EVyvpRVMkP331bhLPdBGbOWcmXPbkbnHcABYwykqU6as4UqqBxF6go68uNqHIJoE787VXKkAQm+ZCsReaDxGJMTwb6ABgy6Nvn+CXmjUgwzTNxyJGYrwGMfNJ+pJg8TjuH2ajywNAS9w3qmruOCQ3jmCH++AQ/YOR5pcRo6eHhF6IeCnjH+nLuAgAPq7AIi8EOhRuv9Lk72nyQiRPsN5TJORvSfwhUqqh2CyXNcxdX0Xlw6iPY+v0q9C+93sjtjszQ4oiOpjM0TBdV2svLwWMh2R2Uv+5sGZEAptQSPocKbIcZdAL65k1/w56C8rzXha/DHNtQgaCZoWF8/nNLs3DUueJMUolsongFwPgCv3JXF43YBu1/y5/Xf21xJwbURem4BdjOdoOAQcEf3qBPwU4O905xFaYTV2bv0i0tl1BwC7cHR35usdxT/Cg4dckZd42uX3ESrSLc7jG8I25Frd5VXAk1cd+vwZHruS/7pfM205IwFriWmHjHZQIb5ktaJFDOLOZiGwJL5Y9ortUtxIeEYGdQsSkreT0K6ljYRnpEC3IGH8dhKerlL3v6XjuVWqh0QQ2YlgEJFrVqPYrkb3t1aN+qg6A3Is9OuvwiDXRhHsbvFPvKQNdkG6v7WC9DIQ3FvJ1xPerkP3t1aHXkb48nnjGwrvKj/DTBk9OvqHP7aibrjblErdF8EyWOdlbKvb9a+0+J5xqhPkpe6iuNJjmHH1mqqhq14Xo1yhRMERdXA6aPugbG09R87HBBFwUMbEA1Uy6KrV8ToTmpzxgp8PAIOuPx0AYNj/QRnwQsAuMXN8YxHlgo9XHAguu7OpD5v3yasHXs37+ujxFw==</diagram></mxfile>" onclick="(function(svg)&#123;var src=window.event.target||window.event.srcElement;while (src!=null&amp;&amp;src.nodeName.toLowerCase()!='a')&#123;src=src.parentNode;&#125;if(src==null)&#123;if(svg.wnd!=null&amp;&amp;!svg.wnd.closed)&#123;svg.wnd.focus();&#125;else&#123;var r=function(evt)&#123;if(evt.data=='ready'&amp;&amp;evt.source==svg.wnd)&#123;svg.wnd.postMessage(decodeURIComponent(svg.getAttribute('content')),'*');window.removeEventListener('message',r);&#125;&#125;;window.addEventListener('message',r);svg.wnd=window.open('https://viewer.diagrams.net/?client=1&amp;page=0&amp;edit=_blank');&#125;&#125;&#125;)(this);" style="cursor:pointer;max-width:100%;max-height:773px;"><defs></defs><g><rect x="100.5" y="610.5" width="120" height="130" fill="#12aab5" stroke="none" pointer-events="all"></rect><rect x="300.5" y="690.5" width="120" height="50" fill="#12aab5" stroke="none" pointer-events="all"></rect><rect x="500.5" y="640.5" width="120" height="100" fill="#12aab5" stroke="none" pointer-events="all"></rect><rect x="700.5" y="570.5" width="120" height="170" fill="#12aab5" stroke="none" pointer-events="all"></rect><path d="M 40.5 740.5 L 40.5 270.6" fill="none" stroke="#000000" stroke-width="3" stroke-miterlimit="10" pointer-events="stroke"></path><path d="M 40.5 263.85 L 45 272.85 L 40.5 270.6 L 36 272.85 Z" fill="#000000" stroke="#000000" stroke-width="3" stroke-miterlimit="10" pointer-events="all"></path><rect x="100.5" y="480.5" width="120" height="130" fill="#f08705" stroke="none" pointer-events="all"></rect><rect x="100.5" y="350.5" width="120" height="130" fill="#e85642" stroke="none" pointer-events="all"></rect><rect x="300.5" y="530.5" width="120" height="160" fill="#f08705" stroke="none" pointer-events="all"></rect><rect x="300.5" y="500.5" width="120" height="30" fill="#e85642" stroke="none" pointer-events="all"></rect><rect x="500.5" y="480.5" width="120" height="160" fill="#f08705" stroke="none" pointer-events="all"></rect><rect x="500.5" y="300.5" width="120" height="180" fill="#e85642" stroke="none" pointer-events="all"></rect><path d="M 40.5 740.5 L 950.4 740.5" fill="none" stroke="#000000" stroke-width="3" stroke-miterlimit="10" pointer-events="stroke"></path><path d="M 957.15 740.5 L 948.15 745 L 950.4 740.5 L 948.15 736 Z" fill="#000000" stroke="#000000" stroke-width="3" stroke-miterlimit="10" pointer-events="all"></path><rect x="970.5" y="728.5" width="80" height="20" fill="none" stroke="none" pointer-events="all"></rect><g transform="translate(-0.5 -0.5)"><switch><foreignObject pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility" style="overflow: visible; text-align: left;"><div xmlns="http://www.w3.org/1999/xhtml" style="box-sizing: border-box; display: flex; align-items: unsafe flex-start; justify-content: unsafe flex-start; width: 1px; height: 1px; padding-top: 731px; margin-left: 973px;"><div data-drawio-colors="color: rgba(0, 0, 0, 1); " style="box-sizing: border-box; font-size: 0px; text-align: left;"><div style="box-sizing: border-box; display: inline-block; font-size: 18px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: nowrap;">Parameter x</div></div></div></foreignObject></switch></g><rect x="100.5" y="742.5" width="120" height="30" fill="none" stroke="none" pointer-events="all"></rect><g transform="translate(-0.5 -0.5)"><switch><foreignObject pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility" style="overflow: visible; text-align: left;"><div xmlns="http://www.w3.org/1999/xhtml" style="box-sizing: border-box; display: flex; align-items: unsafe center; justify-content: unsafe center; width: 1px; height: 1px; padding-top: 755px; margin-left: 161px;"><div data-drawio-colors="color: rgba(0, 0, 0, 1); " style="box-sizing: border-box; font-size: 0px; text-align: center;"><div style="box-sizing: border-box; display: inline-block; font-size: 18px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: nowrap;">x1</div></div></div></foreignObject></switch></g><rect x="300.5" y="742.5" width="120" height="30" fill="none" stroke="none" pointer-events="all"></rect><g transform="translate(-0.5 -0.5)"><switch><foreignObject pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility" style="overflow: visible; text-align: left;"><div xmlns="http://www.w3.org/1999/xhtml" style="box-sizing: border-box; display: flex; align-items: unsafe center; justify-content: unsafe center; width: 1px; height: 1px; padding-top: 755px; margin-left: 361px;"><div data-drawio-colors="color: rgba(0, 0, 0, 1); " style="box-sizing: border-box; font-size: 0px; text-align: center;"><div style="box-sizing: border-box; display: inline-block; font-size: 18px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: nowrap;">x2</div></div></div></foreignObject></switch></g><rect x="500.5" y="742.5" width="120" height="30" fill="none" stroke="none" pointer-events="all"></rect><g transform="translate(-0.5 -0.5)"><switch><foreignObject pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility" style="overflow: visible; text-align: left;"><div xmlns="http://www.w3.org/1999/xhtml" style="box-sizing: border-box; display: flex; align-items: unsafe center; justify-content: unsafe center; width: 1px; height: 1px; padding-top: 755px; margin-left: 561px;"><div data-drawio-colors="color: rgba(0, 0, 0, 1); " style="box-sizing: border-box; font-size: 0px; text-align: center;"><div style="box-sizing: border-box; display: inline-block; font-size: 18px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: nowrap;">x3</div></div></div></foreignObject></switch></g><rect x="860.5" y="140.5" width="35" height="30" fill="#12aab5" stroke="none" pointer-events="all"></rect><rect x="860.5" y="100.5" width="35" height="30" fill="#f08705" stroke="none" pointer-events="all"></rect><rect x="860.5" y="60.5" width="35" height="30" fill="#e85642" stroke="none" pointer-events="all"></rect><rect x="900.5" y="65.5" width="80" height="20" fill="none" stroke="none" pointer-events="all"></rect><g transform="translate(-0.5 -0.5)"><switch><foreignObject pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility" style="overflow: visible; text-align: left;"><div xmlns="http://www.w3.org/1999/xhtml" style="box-sizing: border-box; display: flex; align-items: unsafe flex-start; justify-content: unsafe flex-start; width: 1px; height: 1px; padding-top: 68px; margin-left: 903px;"><div data-drawio-colors="color: rgba(0, 0, 0, 1); " style="box-sizing: border-box; font-size: 0px; text-align: left;"><div style="box-sizing: border-box; display: inline-block; font-size: 15px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: nowrap;">Type 1</div></div></div></foreignObject></switch></g><rect x="900.5" y="105.5" width="80" height="20" fill="none" stroke="none" pointer-events="all"></rect><g transform="translate(-0.5 -0.5)"><switch><foreignObject pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility" style="overflow: visible; text-align: left;"><div xmlns="http://www.w3.org/1999/xhtml" style="box-sizing: border-box; display: flex; align-items: unsafe flex-start; justify-content: unsafe flex-start; width: 1px; height: 1px; padding-top: 108px; margin-left: 903px;"><div data-drawio-colors="color: rgba(0, 0, 0, 1); " style="box-sizing: border-box; font-size: 0px; text-align: left;"><div style="box-sizing: border-box; display: inline-block; font-size: 15px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: nowrap;">Type 2</div></div></div></foreignObject></switch></g><rect x="900.5" y="145.5" width="80" height="20" fill="none" stroke="none" pointer-events="all"></rect><g transform="translate(-0.5 -0.5)"><switch><foreignObject pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility" style="overflow: visible; text-align: left;"><div xmlns="http://www.w3.org/1999/xhtml" style="box-sizing: border-box; display: flex; align-items: unsafe flex-start; justify-content: unsafe flex-start; width: 1px; height: 1px; padding-top: 148px; margin-left: 903px;"><div data-drawio-colors="color: rgba(0, 0, 0, 1); " style="box-sizing: border-box; font-size: 0px; text-align: left;"><div style="box-sizing: border-box; display: inline-block; font-size: 15px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: nowrap;">Type 3</div></div></div></foreignObject></switch></g><rect x="0.5" y="231.5" width="80" height="20" fill="none" stroke="none" pointer-events="all"></rect><g transform="translate(-0.5 -0.5)"><switch><foreignObject pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility" style="overflow: visible; text-align: left;"><div xmlns="http://www.w3.org/1999/xhtml" style="box-sizing: border-box; display: flex; align-items: unsafe flex-start; justify-content: unsafe flex-start; width: 1px; height: 1px; padding-top: 234px; margin-left: 3px;"><div data-drawio-colors="color: rgba(0, 0, 0, 1); " style="box-sizing: border-box; font-size: 0px; text-align: left;"><div style="box-sizing: border-box; display: inline-block; font-size: 18px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: nowrap;">Parameter y</div></div></div></foreignObject></switch></g><rect x="8.5" y="610.5" width="30" height="130" fill="none" stroke="none" pointer-events="all"></rect><g transform="translate(-0.5 -0.5)"><switch><foreignObject pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility" style="overflow: visible; text-align: left;"><div xmlns="http://www.w3.org/1999/xhtml" style="box-sizing: border-box; display: flex; align-items: unsafe center; justify-content: unsafe center; width: 1px; height: 1px; padding-top: 673px; margin-left: 24px;"><div data-drawio-colors="color: rgba(0, 0, 0, 1); " style="box-sizing: border-box; font-size: 0px; text-align: center;"><div style="box-sizing: border-box; display: inline-block; font-size: 18px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: nowrap;">y1</div></div></div></foreignObject></switch></g><rect x="8.5" y="480.5" width="30" height="130" fill="none" stroke="none" pointer-events="all"></rect><g transform="translate(-0.5 -0.5)"><switch><foreignObject pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility" style="overflow: visible; text-align: left;"><div xmlns="http://www.w3.org/1999/xhtml" style="box-sizing: border-box; display: flex; align-items: unsafe center; justify-content: unsafe center; width: 1px; height: 1px; padding-top: 543px; margin-left: 24px;"><div data-drawio-colors="color: rgba(0, 0, 0, 1); " style="box-sizing: border-box; font-size: 0px; text-align: center;"><div style="box-sizing: border-box; display: inline-block; font-size: 18px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: nowrap;">y2</div></div></div></foreignObject></switch></g><rect x="8.5" y="350.5" width="30" height="130" fill="none" stroke="none" pointer-events="all"></rect><g transform="translate(-0.5 -0.5)"><switch><foreignObject pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility" style="overflow: visible; text-align: left;"><div xmlns="http://www.w3.org/1999/xhtml" style="box-sizing: border-box; display: flex; align-items: unsafe center; justify-content: unsafe center; width: 1px; height: 1px; padding-top: 413px; margin-left: 24px;"><div data-drawio-colors="color: rgba(0, 0, 0, 1); " style="box-sizing: border-box; font-size: 0px; text-align: center;"><div style="box-sizing: border-box; display: inline-block; font-size: 18px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: nowrap;">y3</div></div></div></foreignObject></switch></g><rect x="40.5" y="0.5" width="810" height="45" fill="none" stroke="none" pointer-events="all"></rect><g transform="translate(-0.5 -0.5)"><switch><foreignObject pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility" style="overflow: visible; text-align: left;"><div xmlns="http://www.w3.org/1999/xhtml" style="box-sizing: border-box; display: flex; align-items: unsafe center; justify-content: unsafe center; width: 1px; height: 1px; padding-top: 21px; margin-left: 446px;"><div data-drawio-colors="color: rgba(0, 0, 0, 1); " style="box-sizing: border-box; font-size: 0px; text-align: center;"><div style="box-sizing: border-box; display: inline-block; font-size: 30px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; font-weight: bold; white-space: nowrap;"><font style="box-sizing: border-box; display: inline; padding: 0.2em 0.6em; font-size: 30px; font-weight: 400; line-height: 1; color: rgb(255, 255, 255); text-align: center; white-space: nowrap; vertical-align: baseline; border-radius: 6px; background-color: var(--spannote-color);">Diagram title</font></div></div></div></foreignObject></switch></g><rect x="700.5" y="520.5" width="120" height="50" fill="#f08705" stroke="none" pointer-events="all"></rect><rect x="700.5" y="410.5" width="120" height="110" fill="#e85642" stroke="none" pointer-events="all"></rect><rect x="700.5" y="742.5" width="120" height="30" fill="none" stroke="none" pointer-events="all"></rect><g transform="translate(-0.5 -0.5)"><switch><foreignObject pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility" style="overflow: visible; text-align: left;"><div xmlns="http://www.w3.org/1999/xhtml" style="box-sizing: border-box; display: flex; align-items: unsafe center; justify-content: unsafe center; width: 1px; height: 1px; padding-top: 755px; margin-left: 761px;"><div data-drawio-colors="color: rgba(0, 0, 0, 1); " style="box-sizing: border-box; font-size: 0px; text-align: center;"><div style="box-sizing: border-box; display: inline-block; font-size: 18px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: nowrap;">x4</div></div></div></foreignObject></switch></g></g><switch><g requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"></g></switch>&lt;&#x2F;svg</p><p><a href="https://app.diagrams.net/?src=about#G1XbVy9iD3kEJMiCqG2IceUlNBIzMbcJYS">在线编辑地址</a>，该图表由<a href="https://www.diagrams.net/">drawio</a>提供支持（提供iframe嵌入代码和svg嵌入代码），还支持UML类图、Network网络拓扑图、Flowcharts流程图、Tables表格等众多图表类型</p><h3 id="高亮"><a href="#高亮" class="headerlink" title="高亮"></a>高亮</h3><p>为了使用这个特性，请先在<code>Preference</code>面板中的<code>Markdwn</code>选择开启。</p><p>使用<code>==</code>包裹突出的内容，例如：<code>==highlight==</code>，显示为：&#x3D;&#x3D;highlight&#x3D;&#x3D;</p><h3 id="图表"><a href="#图表" class="headerlink" title="图表"></a>图表</h3><p>Typora支持<a href="https://bramp.github.io/js-sequence-diagrams/">sequence</a>, <a href="http://flowchart.js.org/">flowchart</a> 和 <a href="https://knsv.github.io/mermaid/#mermaid">mermaid</a>，可以在设置中启用此功能。</p><p>详情请看<a href="http://support.typora.io/Draw-Diagrams-With-Markdown/">document</a></p><h3 id="Mermaid"><a href="#Mermaid" class="headerlink" title="Mermaid"></a><strong>Mermaid</strong></h3><p><strong>Mermaid[1]</strong> 是一种简单的类似 Markdown 的脚本语言，通过 JavaScript 编程语言，将文本转换为图片。因此，真正实现画图功能的并不是 Typora 本身，它只是内置了对 Mermaid 的支持。</p><p><img src="https://pic2.zhimg.com/v2-4e44a08fa37bdb6b03df9fcec8480ed9_r.jpg" alt="img"></p><p>Mermaid 支持绘制非常多种类的图，常见的有时序图、流程图、类图、甘特图等等。下面分享一下如何绘制这些图，语法非常容易掌握。</p><p>先在 Typora 中，输入 <strong>&#96;&#96;&#96;mermaid</strong> 然后敲击回车，即可初始化一张空白图。</p><h4 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a><strong>流程图</strong></h4><p>语法解释：<code>graph</code> 关键字就是声明一张流程图，<code>TD</code> 表示的是方向，这里的含义是 Top-Down 由上至下。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">    A--&gt;B;</span><br><span class="line">    A--&gt;C;</span><br><span class="line">    B--&gt;D;</span><br></pre></td></tr></table></figure><p>先在 Typora 中，输入 <strong>&#96;&#96;&#96;mermaid</strong> 然后敲击回车，即可初始化一张空白图。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">A--&gt;B</span><br><span class="line">A--&gt;c</span><br><span class="line">B--&gt;D</span><br></pre></td></tr></table></figure><h4 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a><strong>时序图</strong></h4><p>语法解释：<code>-&gt;&gt;</code> 代表实线箭头，<code>--&gt;&gt;</code> 则代表虚线。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    Alice-&gt;&gt;John: Hello John, how are you?</span><br><span class="line">    John--&gt;&gt;Alice: Great!</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    Alice-&gt;&gt;John: Hello John, how are you?</span><br><span class="line">    John--&gt;&gt;Alice: Great!</span><br></pre></td></tr></table></figure><h4 id="状态图"><a href="#状态图" class="headerlink" title="状态图"></a><strong>状态图</strong></h4><p>语法解释：<code>[*]</code> 表示开始或者结束，如果在箭头右边则表示结束。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stateDiagram</span><br><span class="line">    [*] --&gt; s1</span><br><span class="line">    s1 --&gt; [*]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stateDiagram</span><br><span class="line">[*] --&gt; s1</span><br><span class="line">s1 --&gt; [*]</span><br></pre></td></tr></table></figure><h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a><strong>类图</strong></h4><p>语法解释：<code>&lt;|--</code> 表示继承，<code>+</code> 表示 <code>public</code>，<code>-</code> 表示 <code>private</code>，学过 Java 的应该都知道。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">classDiagram</span><br><span class="line">      Animal &lt;|-- Duck</span><br><span class="line">      Animal &lt;|-- Fish</span><br><span class="line">      Animal &lt;|-- Zebra</span><br><span class="line">      Animal : +int age</span><br><span class="line">      Animal : +String gender</span><br><span class="line">      Animal: +isMammal()</span><br><span class="line">      Animal: +mate()</span><br><span class="line">      class Duck&#123;</span><br><span class="line">          +String beakColor</span><br><span class="line">          +swim()</span><br><span class="line">          +quack()</span><br><span class="line">      &#125;</span><br><span class="line">      class Fish&#123;</span><br><span class="line">          -int sizeInFeet</span><br><span class="line">          -canEat()</span><br><span class="line">      &#125;</span><br><span class="line">      class Zebra&#123;</span><br><span class="line">          +bool is_wild</span><br><span class="line">          +run()</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">classDiagram</span><br><span class="line">      Animal &lt;|-- Duck</span><br><span class="line">      Animal &lt;|-- Fish</span><br><span class="line">      Animal &lt;|-- Zebra</span><br><span class="line">      Animal : +int age</span><br><span class="line">      Animal : +String gender</span><br><span class="line">      Animal: +isMammal()</span><br><span class="line">      Animal: +mate()</span><br><span class="line">      class Duck&#123;</span><br><span class="line">          +String beakColor</span><br><span class="line">          +swim()</span><br><span class="line">          +quack()</span><br><span class="line">      &#125;</span><br><span class="line">      class Fish&#123;</span><br><span class="line">          -int sizeInFeet</span><br><span class="line">          -canEat()</span><br><span class="line">      &#125;</span><br><span class="line">      class Zebra&#123;</span><br><span class="line">          +bool is_wild</span><br><span class="line">          +run()</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h4 id="甘特图"><a href="#甘特图" class="headerlink" title="甘特图"></a><strong>甘特图</strong></h4><p>甘特图一般用来表示项目的计划排期，目前在工作中经常会用到。</p><p>语法也非常简单，从上到下依次是图片标题、日期格式、项目、项目细分的任务。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gantt</span><br><span class="line">    title 工作计划</span><br><span class="line">    dateFormat  YYYY-MM-DD</span><br><span class="line">    section Section</span><br><span class="line">    A task           :a1, 2020-01-01, 30d</span><br><span class="line">    Another task     :after a1  , 20d</span><br><span class="line">    section Another</span><br><span class="line">    Task in sec      :2020-01-12  , 12d</span><br><span class="line">    another task      : 24d</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gantt</span><br><span class="line">    title 工作计划</span><br><span class="line">    dateFormat  YYYY-MM-DD</span><br><span class="line">    section Section</span><br><span class="line">    A task           :a1, 2020-01-01, 30d</span><br><span class="line">    Another task     :after a1  , 20d</span><br><span class="line">    section Another</span><br><span class="line">    Task in sec      :2020-01-12  , 12d</span><br><span class="line">    another task      : 24d</span><br></pre></td></tr></table></figure><h4 id="饼图"><a href="#饼图" class="headerlink" title="饼图"></a><strong>饼图</strong></h4><p>饼图使用 <code>pie</code> 表示，标题下面分别是区域名称及其百分比。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pie</span><br><span class="line">    title Key elements in Product X</span><br><span class="line">    &quot;Calcium&quot; : 42.96</span><br><span class="line">    &quot;Potassium&quot; : 50.05</span><br><span class="line">    &quot;Magnesium&quot; : 10.01</span><br><span class="line">    &quot;Iron&quot; :  5</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pie</span><br><span class="line">    title Key elements in Product X</span><br><span class="line">    &quot;Calcium&quot; : 42.96</span><br><span class="line">    &quot;Potassium&quot; : 50.05</span><br><span class="line">    &quot;Magnesium&quot; : 10.01</span><br><span class="line">    &quot;Iron&quot; :  5</span><br></pre></td></tr></table></figure><h3 id="导出"><a href="#导出" class="headerlink" title="导出"></a><strong>导出</strong></h3><p>绘制好的图片可以选择菜单&#x2F;文件&#x2F;导出，导出为图片或者网页格式。在网页中图片是以 SVG 格式渲染的，你可以复制 SVG 内容，导入到 SVG 的图片编辑器中进一步操作。</p><p><img src="https://pic2.zhimg.com/v2-907aef8d603e125c85d2a14ed96a9e79_r.jpg" alt="img">Mermaid 官方有一个在线的工具，可以导出 SVG 和 PNG。</p><p><a href="https://mermaid-js.github.io/mermaid-live-editor">Mermaid live editor</a></p><h3 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h3><p>Typora 默认使用的是 GitHub 主题，你可以点击菜单栏&#x2F;主题 进行切换。</p><p><img src="https://pic3.zhimg.com/80/v2-1a7c89da426cc0ae4d6ee370910d3232_1440w.webp" alt="img"></p><p>如果系统默认的主题无法满足需求，打开**主题商店[1]**，里面有更多的选择。</p><p><img src="https://pic4.zhimg.com/80/v2-09674f6d895ccdef290f53115cf4aa7f_1440w.webp" alt="img"></p><p>安装主题也非常简单，打开 Typora 设置选项，选择 偏好设置&#x2F;外观&#x2F;主题&#x2F;打开主题文件夹，然后将下载好的主题解压拖进去。注意是将压缩包里的文件复制进去。</p><p>主题支持二次修改，可以打开主题文件夹，直接修改相关 css 代码，调整字体、边距等等。选择 菜单&#x2F;帮助&#x2F; Enable Debugging，右键检查元素，然后就可以像调试 Web 程序一样，修改主题样式。</p><p><img src="https://pic2.zhimg.com/80/v2-f8a05bf3e128eb3a5af442d2287fb6fd_1440w.webp" alt="img"></p><h3 id="专注模式"><a href="#专注模式" class="headerlink" title="专注模式"></a><strong>专注模式</strong></h3><p>快捷键 <code>F8</code> 打开专注模式，编辑器会高亮显示当前正在编辑的段落，让你更加专注于当前内容，不受视觉干扰。</p><p><img src="https://pic4.zhimg.com/80/v2-ac418641cc8b37995d5feb9a7e2c4fc3_1440w.webp" alt="img"></p><h3 id="打字机模式"><a href="#打字机模式" class="headerlink" title="打字机模式"></a><strong>打字机模式</strong></h3><p>快捷键 <code>F9</code> 打开打字机模式，当前正在编辑的段落会居中显示。</p><h3 id="源码模式"><a href="#源码模式" class="headerlink" title="源码模式"></a><strong>源码模式</strong></h3><p>快键键 <code>ctrl+/</code> 打开源码模式，显示纯粹的 Markdown 文本编辑。</p><h3 id="导出选项"><a href="#导出选项" class="headerlink" title="导出选项"></a><strong>导出选项</strong></h3><p>选择菜单&#x2F;文件&#x2F;导出，选择不同的导出形式，选择图像会导出一张文档的长截图，可作为分享图片。</p><p><img src="https://pic3.zhimg.com/80/v2-5c513d4bf0025426eb52976ed4c55676_1440w.webp" alt="img"></p><h2 id="一个伪装成文本编辑器的浏览器"><a href="#一个伪装成文本编辑器的浏览器" class="headerlink" title="一个伪装成文本编辑器的浏览器"></a>一个伪装成文本编辑器的浏览器</h2><p>当我的一个朋友问我「Typora 有什么好写的？」时，我回答「Typora 是一个伪装成文本编辑器的浏览器」。是的，事实上如果你有一定的计算机基础，你可以找到许多有关于「Typora 其实是一个浏览器」的蛛丝马迹。</p><p><img src="https://cdn.sspai.com/2019/05/24/13837bcdcded9ae406e8c4aac5f2d752.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="img"></p><p>在图片插入的选项中，Typora 用了「复制图片到 .&#x2F;${filename}.assets 文件夹」的说法，而这其实是网页前端常用的 Javascript 字符串模板语法的风格。</p><p>再比如，Typora 将更遵循 GFM 标准的 Markdown 语法模式称为「严格模式 Strict Mode」，这一说法常见于 HTML 和 JavaScript 编程中。类似「源代码模式」的说法也是同理。</p><p>当然，最明显的一点是当你按下 <code>Shift + F12</code> 快捷键时，页面会弹出一个基于 Chrome 的开发者工具栏，也就是我们在浏览器中常说的「审查元素」。</p><p><img src="C:\Users\18389\AppData\Roaming\Typora\typora-user-images\image-20230517083203198.png" alt="image-20230517083203198"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Typora </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Front-matter</title>
      <link href="/2023/06/13/Front-matter/"/>
      <url>/2023/06/13/Front-matter/</url>
      
        <content type="html"><![CDATA[<h1 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h1><p>Front-matter 是 markdown 文件最上方以 <code>---</code> 分隔的区域，用于指定个别档案的变数。</p><ul><li>Page Front-matter 用于<code>页面</code>配置 </li><li>Post Front-matter 用于<code>文章</code>页配置</li></ul><blockquote><p>如果标注可选的参数，可根据自己需要添加，不用全部都写在 markdown 里</p></blockquote><h3 id="Page-Front-matter"><a href="#Page-Front-matter" class="headerlink" title="Page Front-matter"></a>Page Front-matter</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: </span><br><span class="line">date: </span><br><span class="line">updated: </span><br><span class="line">tags: </span><br><span class="line">categories: </span><br><span class="line">keywords: </span><br><span class="line">description: </span><br><span class="line">top <span class="emphasis">_img: </span></span><br><span class="line"><span class="emphasis">comments: </span></span><br><span class="line"><span class="emphasis">cover: </span></span><br><span class="line"><span class="emphasis">toc: </span></span><br><span class="line"><span class="emphasis">toc_</span> number: </span><br><span class="line">toc <span class="emphasis">_style_</span> simple: </span><br><span class="line">copyright: </span><br><span class="line">copyright <span class="emphasis">_author: </span></span><br><span class="line"><span class="emphasis">copyright_</span> author <span class="emphasis">_href: </span></span><br><span class="line"><span class="emphasis">copyright_</span> url: </span><br><span class="line">copyright <span class="emphasis">_info: </span></span><br><span class="line"><span class="emphasis">mathjax: </span></span><br><span class="line"><span class="emphasis">katex: </span></span><br><span class="line"><span class="emphasis">aplayer: </span></span><br><span class="line"><span class="emphasis">highlight_</span> shrink: </span><br><span class="line">---</span><br></pre></td></tr></table></figure><table><thead><tr><th>写法</th><th>解释</th></tr></thead><tbody><tr><td>title</td><td>【必需】页面标题</td></tr><tr><td>date</td><td>【必需】页面创建日期</td></tr><tr><td>type</td><td>【必需】标签、分类和友情链接三个页面需要配置</td></tr><tr><td>updated</td><td>【可选】页面更新日期</td></tr><tr><td>description</td><td>【可选】页面描述</td></tr><tr><td>keywords</td><td>【可选】页面关键字</td></tr><tr><td>comments</td><td>【可选】显示页面评论模块(默认为 true)</td></tr><tr><td>top_img</td><td>【可选】页面顶部图片</td></tr><tr><td>mathjax</td><td>【可选】显示 mathjax（当设置 mathjax 的 per_page: false 时，才需要配置，默认为 false）</td></tr><tr><td>katex</td><td>【可选】显示 katex（当设置 katex 的 per_page: false 时，才需要配置，默认为 false）</td></tr><tr><td>aside</td><td>【可选】显示侧边栏（默认为 true）</td></tr><tr><td>aplayer</td><td>【可选】在需要的页面加载 aplayer 的 JS 和 CSS，请参考文章下面的音乐配置</td></tr><tr><td>highlight_shrink</td><td>【可选】配置代码框是否展开(true&#x2F;false)（默认为设置中 highlight_shrink 的配置）</td></tr><tr><td>random</td><td>【可选】配置友情链接是否随机排序（默认为 false）</td></tr></tbody></table><h3 id="Post-Front-matter"><a href="#Post-Front-matter" class="headerlink" title="Post Front-matter"></a>Post Front-matter</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">--- </span><br><span class="line">title: </span><br><span class="line">date: </span><br><span class="line">updated: </span><br><span class="line">tags: </span><br><span class="line">categories: </span><br><span class="line">keywords: </span><br><span class="line">description: </span><br><span class="line">top _img: </span><br><span class="line">comments: </span><br><span class="line">cover: </span><br><span class="line">toc: </span><br><span class="line">toc_ number: </span><br><span class="line">toc _style_ simple: </span><br><span class="line">copyright: </span><br><span class="line">copyright _author: </span><br><span class="line">copyright_ author _href: </span><br><span class="line">copyright_ url: </span><br><span class="line">copyright _info: </span><br><span class="line">mathjax: </span><br><span class="line">katex: </span><br><span class="line">aplayer: </span><br><span class="line">highlight_ shrink: </span><br><span class="line">aside: </span><br><span class="line">abcjs: </span><br><span class="line">---</span><br></pre></td></tr></table></figure><table><thead><tr><th>写法</th><th>解释</th></tr></thead><tbody><tr><td>title</td><td>【必需】文章标题</td></tr><tr><td>date</td><td>【必需】文章创建日期</td></tr><tr><td>updated</td><td>【可选】文章更新日期</td></tr><tr><td>tags</td><td>【可选】文章标签</td></tr><tr><td>categories</td><td>【可选】文章分类</td></tr><tr><td>keywords</td><td>【可选】文章关键字</td></tr><tr><td>description</td><td>【可选】文章描述</td></tr><tr><td>top_img</td><td>【可选】文章顶部图片</td></tr><tr><td>cover</td><td>【可选】文章缩略图（如果没有设置 top_img，文章页顶部将显示缩略图，可设为 false&#x2F;图片地址&#x2F;留空）</td></tr><tr><td>comments</td><td>【可选】显示文章评论模块（默认为 true）</td></tr><tr><td>toc</td><td>【可选】显示文章 TOC（默认为设置中 toc 的 enable 配置）</td></tr><tr><td>toc_number</td><td>【可选】显示 toc_number（默认为设置中 toc 的 number 配置）</td></tr><tr><td>toc_style_simple</td><td>【可选】显示 toc 简洁模式</td></tr><tr><td>mathjax</td><td>【可选】显示 mathjax（当设置 mathjax 的 per_page: false 时，才需要配置，默认为 false）</td></tr><tr><td>katex</td><td>【可选】显示 katex（当设置 katex 的 per_page: false 时，才需要配置，默认为 false）</td></tr><tr><td>aplayer</td><td>【可选】在需要的页面加载 aplayer 的 JS 和 CSS，请参考文章下面的音乐配置</td></tr><tr><td>highlight_shrink</td><td>【可选】配置代码框是否展开(true&#x2F;false)（默认为设置中 highlight_shrink 的配置）</td></tr><tr><td>aside</td><td>【可选】显示侧边栏（默认为 true）</td></tr><tr><td>abcjs</td><td>【可选】加载 abcjs（当设置 abcjs 的 per_page: false 时，才需要配置，默认为 false）</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> Front-matter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Apifox 阿闲教程</title>
      <link href="/2023/06/13/Apifox%20%E6%95%99%E7%A8%8B/"/>
      <url>/2023/06/13/Apifox%20%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Apifox-教程"><a href="#Apifox-教程" class="headerlink" title="Apifox 教程"></a>Apifox 教程</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="什么是API文档？"><a href="#什么是API文档？" class="headerlink" title="什么是API文档？"></a>什么是API文档？</h3><p>API文档（Application Programming Interface文档）是一种用于描述和记录应用程序编程接口（API）的技术文档。API文档提供了对开发者公开的软件库、框架、服务或平台的功能、接口和使用方法的详细说明。</p><p>API文档通常包含以下内容：</p><ol><li>接口描述：对每个API接口进行详细描述，包括接口名称、功能说明、参数说明、返回值类型等。</li><li>请求和响应：描述API接口的请求和响应结构，包括请求参数、请求方法、请求头、请求体等信息。</li><li>示例代码：提供使用该API接口的示例代码，帮助开发者理解如何正确调用API。</li><li>错误处理：说明可能发生的错误和异常情况，以及对应的错误码和错误信息。</li><li>认证和权限：描述API接口的认证方式和权限要求，指导开发者如何获取访问权限和进行身份验证。</li><li>限制和配额：指定API接口的访问限制、频率限制和配额限制，以确保服务的可靠性和安全性。</li><li>版本控制：提供API接口的版本信息和升级说明，保证开发者能够适应新版本的变化。</li></ol><p>API文档对于开发者来说非常重要，它可以帮助开发者理解和正确使用API接口，降低开发难度和错误率，加快开发速度。同时，API文档也可以作为团队协作的工具，促进开发者之间的沟通和理解。</p><p>好的API文档应该清晰、详尽、易于理解，并且提供实用的示例和参考资料，以帮助开发者快速上手并正确使用API接口。</p><h3 id="apifox是什么？"><a href="#apifox是什么？" class="headerlink" title="apifox是什么？"></a>apifox是什么？</h3><h4 id="21-分钟学会-Apifox-👍"><a href="#21-分钟学会-Apifox-👍" class="headerlink" title="21 分钟学会 Apifox 👍"></a><a href="https://www.bilibili.com/video/BV1ae4y1y7bf/?spm_id_from=888.80997.embed_other.whitelist&vd_source=62cae349049e00ca18a561376f872b43">21 分钟学会 Apifox 👍</a></h4><p><a href="https://www.apifox.cn/">Apifox</a> 是 API 文档、API 调试、API Mock、API 自动化测试一体化协作平台，定位 <code>Postman + Swagger + Mock + JMeter</code>。通过一套系统、一份数据，解决多个系统之间的数据同步问题。只要定义好 API 文档，API 调试、API 数据 Mock、API 自动化测试就可以直接使用，无需再次定义；API 文档和 API 开发调试使用同一个工具，API 调试完成后即可保证和 API 文档定义完全一致。高效、及时、准确！🔥🔥🔥</p><h3 id="apifox相比其他工具的优势和特点是什么？"><a href="#apifox相比其他工具的优势和特点是什么？" class="headerlink" title="apifox相比其他工具的优势和特点是什么？"></a>apifox相比其他工具的优势和特点是什么？</h3><ol><li>简单易用：Apifox提供直观的界面和友好的用户体验，使用户可以快速上手和使用，无需复杂的配置和学习曲线。</li><li>强大的编辑功能：Apifox内置了强大的编辑器和标记语言支持，如Markdown，使用户可以灵活编写清晰、易读的API文档，并支持实时预览。</li><li>自动同步和集成：Apifox支持与实际代码的自动同步，可以与代码仓库（如GitHub）进行集成，实时获取最新的API接口定义和变更，确保文档与代码保持一致。</li><li>团队协作和版本控制：Apifox提供了团队协作功能，多个成员可以同时参与接口的编辑和文档的编写，支持评论、反馈和版本控制，便于团队协作和管理。</li><li>可视化接口设计：Apifox提供直观的接口设计界面，使用户可以轻松创建和定义API接口，包括URL、请求方法、请求参数、请求体、响应结构等，减少繁琐的手动编写。</li><li>导出和分享：Apifox支持将API文档导出为静态HTML页面或Markdown文件，方便分享给团队成员或其他开发者。同时，还可以生成在线预览链接，供他人查看和使用。</li></ol><h2 id="注册与登录"><a href="#注册与登录" class="headerlink" title="注册与登录"></a>注册与登录</h2><h3 id="创建apifox账号"><a href="#创建apifox账号" class="headerlink" title="创建apifox账号"></a>创建apifox账号</h3><ol><li>访问Apifox官方网站（<a href="https://www.apifox.cn/%EF%BC%89%E3%80%82">https://www.apifox.cn/）。</a></li><li>点击网页右上角的「注册」按钮。</li><li>在注册页面上，提供所需的信息，例如电子邮件地址和密码。</li><li>阅读并同意Apifox的服务条款和隐私政策。</li><li>点击「注册」按钮完成注册过程。</li><li>检查您的电子邮件收件箱，您可能会收到一封确认邮件。请按照邮件中的指示完成账号确认。</li><li>返回Apifox网站并使用您的注册信息进行登录。</li><li>登录后，您可以开始使用Apifox的功能，创建和管理您的API文档。</li></ol><h3 id="注销"><a href="#注销" class="headerlink" title="注销"></a>注销</h3><ol><li>在Apifox的控制台页面上，找到页面右上角的账号设置或用户设置。</li><li>点击账号设置或用户设置，进入相关的设置页面。</li><li>在设置页面中，查找注销或退出账号的选项。</li><li>点击注销或退出账号的选项。</li><li>系统将会确认您的操作，并将您从当前的Apifox会话中注销，您将无法再访问您的账号和相关数据。</li></ol><h3 id="密码重置"><a href="#密码重置" class="headerlink" title="密码重置"></a>密码重置</h3><ol><li>在登录页面下方，找到并点击「忘记密码」或「密码重置」链接。</li><li>系统将要求您输入您注册时使用的电子邮件地址。</li><li>输入您的注册电子邮件地址，并确保准确无误。</li><li>点击「发送重置链接」或类似的按钮。</li><li>检查您的电子邮件收件箱，您将收到一封包含密码重置链接的电子邮件。</li><li>点击电子邮件中的密码重置链接。</li><li>根据提示，输入您的新密码并确认。</li><li>点击「确认」或「提交」按钮以完成密码重置过程。</li></ol><h2 id="创建和管理项目"><a href="#创建和管理项目" class="headerlink" title="创建和管理项目"></a>创建和管理项目</h2><h3 id="创建新项目"><a href="#创建新项目" class="headerlink" title="创建新项目"></a>创建新项目</h3><h3 id="添加项目成员和权限管理"><a href="#添加项目成员和权限管理" class="headerlink" title="添加项目成员和权限管理"></a>添加项目成员和权限管理</h3><h3 id="导入现有API文档"><a href="#导入现有API文档" class="headerlink" title="导入现有API文档"></a>导入现有API文档</h3><h3 id="项目设置和配置"><a href="#项目设置和配置" class="headerlink" title="项目设置和配置"></a>项目设置和配置</h3><h2 id="设计API文档"><a href="#设计API文档" class="headerlink" title="设计API文档"></a>设计API文档</h2><ul><li>创建API分组</li><li>添加API接口</li><li>定义请求和响应</li><li>设置参数和参数类型</li><li>设计API接口的URL和方法</li><li>添加请求头和认证信息</li><li>编写API接口的描述和注释</li><li>设计API的状态码和错误信息</li></ul><h2 id="共享和协作"><a href="#共享和协作" class="headerlink" title="共享和协作"></a>共享和协作</h2><ul><li>共享API文档链接</li><li>邀请其他成员编辑和查看</li><li>版本控制和历史记录</li><li>评论和讨论</li></ul><h2 id="导出和发布"><a href="#导出和发布" class="headerlink" title="导出和发布"></a>导出和发布</h2><ul><li>导出API文档为静态HTML</li><li>生成API文档的代码示例</li><li>发布API文档到线上环境</li><li>API文档的持续集成和部署</li></ul><h2 id="进阶功能"><a href="#进阶功能" class="headerlink" title="进阶功能"></a>进阶功能</h2><ul><li>自定义主题和样式</li><li>添加API接口的测试用例</li><li>集成API监控和报警</li><li>安全性和访问控制</li><li>API文档的SEO优化</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git学习</title>
      <link href="/2023/06/13/Git%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/06/13/Git%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Git介绍"><a href="#Git介绍" class="headerlink" title="Git介绍"></a>Git介绍</h1><p>Git 是一个免费的、开源的分布式版本控制系统，可以快速高效地处理从小型到大型的各种项目。<br>Git 易于学习，占地面积小，性能极快。 它具有廉价的本地库，方便的暂存区域和多个工作流分支等特<br>性。其性能优于 Subversion、CVS、Perforce 和 ClearCase 等版本控制工具。</p><h1 id="Git版本控制"><a href="#Git版本控制" class="headerlink" title="Git版本控制"></a>Git版本控制</h1><p>版本控制（Revision control）是一种在开发的过程中用于管理我们对文件、目录或工程等内容的修改历史，方便查看更改历史记录，备份以便恢复以前的版本的软件工程技术。</p><ul><li>实现跨区域多人协同开发</li><li>追踪和记载一个或者多个文件的历史记录</li><li>组织和保护你的源代码和文档</li><li>统计工作量</li><li>并行开发，提高开发效率</li><li>跟踪记录整个软件的开发过程</li><li>减轻开发人员的负担，节省时间，同时降低人为错误</li></ul><p>版本控制系统的好处包括：</p><ol><li>使团队成员之间协作更加高效。</li><li>提供对历史版本的备份和恢复能力，可以回退到之前的某个版本。</li><li>记录文件或项目的历史变化，方便跟踪和分析。</li></ol><p>Git是一种流行的分布式版本控制系统，能够有效地记录和管理代码的版本变化。通过Git，开发者能够轻松地管理项目的版本、分支、合并等操作，从而更加高效地进行团队协作。</p><p>如果是多人开发就需要用到版本控制</p><h2 id="常见的版本控制工具"><a href="#常见的版本控制工具" class="headerlink" title="常见的版本控制工具"></a>常见的版本控制工具</h2><ul><li><strong>Git</strong></li><li><strong>SVN</strong>（Subversion）</li><li><strong>CVS</strong>（Concurrent Versions System）</li><li><strong>VSS</strong>（Micorosoft Visual SourceSafe）</li><li><strong>TFS</strong>（Team Foundation Server）</li><li>Visual Studio Online</li></ul><p>现在影响力最大且使用最广泛的是Git与SVN</p><h2 id="版本控制分类"><a href="#版本控制分类" class="headerlink" title="版本控制分类"></a>版本控制分类</h2><p><strong>1、本地版本控制</strong></p><p>记录文件每次的更新，可以对每个版本做一个快照，或是记录补丁文件，适合个人用，如RCS。</p><p><img src="https://atts.w3cschool.cn/attachments/day_160927/201609271432597973.png#id=GsLWZ&originHeight=336&originWidth=400&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p><strong>2、集中版本控制  SVN</strong></p><p>所有的版本数据都保存在服务器上，协同开发者从服务器上同步更新或上传自己的修改，事分两面，有好有坏，这么做显而易见的缺点是中央服务器的单点故障，如果服务器宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。</p><p><img src="https://img0.baidu.com/it/u=1601532896,3783203994&fm=253&fmt=auto&app=138&f=PNG?w=638&h=500#id=GaTiT&originHeight=500&originWidth=638&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p><strong>3、分布式版本控制 Git</strong></p><p>每个人都拥有全部的代码！安全隐患！</p><p>所有版本信息仓库全部同步到本地的每个用户，这样就可以在本地查看所有版本历史，可以离线在本地提交，只需在连网时push到相应的服务器或其他用户那里。由于每个用户那里保存的都是所有的版本数据，只要有一个用户的设备没有问题就可以恢复所有的数据，但这增加了本地存储空间的占用。</p><p>不会因为服务器损坏或者网络问题，造成不能工作的情况！</p><p><img src="https://bkimg.cdn.bcebos.com/pic/2934349b033b5bb5f8730e263cd3d539b700bc45#id=aTrt1&originHeight=480&originWidth=479&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h2 id="Git与SVN的主要区别"><a href="#Git与SVN的主要区别" class="headerlink" title="Git与SVN的主要区别"></a>Git与SVN的主要区别</h2><p>Git是一种分布式版本控制系统，每个开发者都有一个完整的本地代码仓库，更适合团队开发和复杂项目，具有更强大和灵活的分支和合并功能，更快的性能和更适合管理大型文件和二进制文件的存储方式。而SVN是一种集中式版本控制系统，每个开发者只有一个本地的代码工作副本，更适合小型项目和单独开发者，相对简单易用，但分支和合并功能相对较弱。</p><p><strong>Git是目前世界上最先进的分布式版本控制系统。</strong></p><h1 id="Git的历史"><a href="#Git的历史" class="headerlink" title="Git的历史"></a>Git的历史</h1><p>inux 内核开源项目有着为数众广的参与者。绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上(1991－2002年间)。到 2002 年，整个项目组开始启用一个专有的分布式版本控制系统 BitKeeper 来管理和维护代码。</p><p>Linux社区中存在很多的大佬！破解研究 BitKeeper ！</p><p>到了 2005 年，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了 Linux 内核社区免费使用 BitKeeper 的权力。这就迫使 Linux 开源社区(特别是 Linux 的缔造者 Linus Torvalds)基于使用 BitKeeper 时的经验教训，开发出自己的版本系统。（2周左右！） 也就是后来的 Git！</p><p><img src="https://bkimg.cdn.bcebos.com/pic/b17eca8065380cd7598d0e56a944ad34588281fe?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2U4MA==,g_7,xp_5,yp_5#id=lcsvF&originHeight=375&originWidth=500&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>Linux和Git之父李纳斯·托沃兹（Linus Benedic Torvalds）1969、芬兰</p><h1 id="Git环境配置"><a href="#Git环境配置" class="headerlink" title="Git环境配置"></a>Git环境配置</h1><h2 id="软件下载"><a href="#软件下载" class="headerlink" title="软件下载"></a>软件下载</h2><p>打开 git官网 <a href="https://git-scm.com/%EF%BC%8C%E4%B8%8B%E8%BD%BDgit%E5%AF%B9%E5%BA%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%89%88%E6%9C%AC%E3%80%82">https://git-scm.com/，下载git对应操作系统的版本。</a></p><p>所有东西下载慢的话就可以去找镜像！</p><p>官网下载太慢，我们可以使用淘宝镜像下载：<a href="http://npm.taobao.org/mirrors/git-for-windows/">http://npm.taobao.org/mirrors/git-for-windows/</a></p><p>下载对应的版本即可安装！</p><p>安装：无脑下一步即可！安装完毕就可以使用了！</p><h2 id="启动Git"><a href="#启动Git" class="headerlink" title="启动Git"></a>启动Git</h2><p>安装成功后在开始菜单中会有Git项，菜单下有3个程序：任意文件夹下右键也可以看到对应的程序！</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0jaiaAfr2pAfWtFX57kGYqR3SlNxDlAZDkCU6IOB1YAicKxHib5yGbv9zQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1#id=q2Di3&originHeight=283&originWidth=405&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p><strong>Git Bash：</strong>Unix与Linux风格的命令行，使用最多，推荐最多</p><p><strong>Git CMD：</strong>Windows风格的命令行</p><p><strong>Git GUI</strong>：图形界面的Git，不建议初学者使用，尽量先熟悉常用命令</p><h2 id="常用的Linux命令"><a href="#常用的Linux命令" class="headerlink" title="常用的Linux命令"></a>常用的Linux命令</h2><p>平时一定要多使用这些基础的命令！</p><p>1）、cd : 改变目录。</p><p>2）、cd . . 回退到上一个目录，直接cd进入默认目录</p><p>3）、pwd : 显示当前所在的目录路径。</p><p>4）、ls(ll):  都是列出当前目录中的所有文件，只不过ll(两个ll)列出的内容更为详细。</p><p>5）、touch : 新建一个文件 如 touch index.js 就会在当前目录下新建一个index.js文件。</p><p>6）、rm:  删除一个文件, rm index.js 就会把index.js文件删除。</p><p>7）、mkdir:  新建一个目录,就是新建一个文件夹。</p><p>8）、rm -r :  删除一个文件夹, rm -r src 删除src目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf / 切勿在Linux中尝试！删除电脑中全部文件！</span><br></pre></td></tr></table></figure><p>9）、mv 移动文件, mv index.html src index.html 是我们要移动的文件, src 是目标文件夹,当然, 这样写,必须保证文件和目标文件夹在同一目录下。</p><p>10）、reset 重新初始化终端&#x2F;清屏。</p><p>11）、clear 清屏。</p><p>12）、history 查看命令历史。</p><p>13）、help 帮助。</p><p>14）、exit 退出。</p><p>15）、#表示注释</p><h2 id="Git配置"><a href="#Git配置" class="headerlink" title="Git配置"></a>Git配置</h2><p>所有的配置文件，其实都保存在本地！</p><p>查看配置 git config -l</p><p>查看不同级别的配置文件：</p><p>查看系统config</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --system --list</span><br></pre></td></tr></table></figure><p>查看当前用户（global）配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global --list</span><br></pre></td></tr></table></figure><p><strong>Git相关的配置文件：</strong></p><p>1）、C:\Program Files\Git\etc\gitconfig  ：Git 安装目录下的 gitconfig   –system 系统级</p><p>2）、C:\Users\用户\ .gitconfig：只适用于当前登录用户的配置  –global 全局</p><p>可以直接编辑配置文件，通过命令设置后会响应到这里</p><h2 id="设置用户名与邮箱（用户标识，必要）"><a href="#设置用户名与邮箱（用户标识，必要）" class="headerlink" title="设置用户名与邮箱（用户标识，必要）"></a>设置用户名与邮箱（用户标识，必要）</h2><p>当你安装Git后首先要做的事情是设置你的用户名称和email地址。这是非常重要的，因为每次Git提交都会使用该信息。它被永远的嵌入到了你的提交中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;kuangshen&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.email 24736743@qq.com</span><br></pre></td></tr></table></figure><p>只需要做一次这个设置，如果你传递了–global 选项，因为Git将总是会使用该信息来处理你在系统中所做的一切操作。如果你希望在一个特定的项目中使用不同的名称或email地址，你可以在该项目中运行该命令而不要–global选项。总之–global为全局配置，不加为某个项目的特定配置。</p><h1 id="Git基本理论（重要）"><a href="#Git基本理论（重要）" class="headerlink" title="Git基本理论（重要）"></a>Git基本理论（重要）</h1><h2 id="三个区域"><a href="#三个区域" class="headerlink" title="三个区域"></a>三个区域</h2><p>Git本地有三个工作区域：工作目录（Working Directory）、暂存区(Stage&#x2F;Index)、资源库(Repository或Git Directory)。如果在加上远程的git仓库(Remote Directory)就可以分为四个工作区域。文件在这四个区域之间的转换关系如下：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0NJ4L9OPI9ia1MmibpvDd6cSddBdvrlbdEtyEOrh4CKnWVibyfCHa3lzXw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1#id=lvxn0&originHeight=480&originWidth=500&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><ul><li>Workspace：工作区，就是你平时存放项目代码的地方</li><li>Index &#x2F; Stage：暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息</li><li>Repository：仓库区（或本地仓库），就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本</li><li>Remote：远程仓库，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换</li></ul><p>本地的三个区域确切的说应该是git仓库中HEAD指向的版本：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0icz6X2aibIgUWzHxtwX8kicPCKpDrsiaPzZk04OlI2bzlydzicBuXTJvLEQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1#id=T4HFU&originHeight=728&originWidth=1080&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><ul><li>Directory：使用Git管理的一个目录，也就是一个仓库，包含我们的工作空间和Git的管理空间。</li><li>WorkSpace：需要通过Git进行版本控制的目录和文件，这些目录和文件组成了工作空间。</li><li>.git：存放Git管理信息的目录，初始化仓库的时候自动创建。</li><li>Index&#x2F;Stage：暂存区，或者叫待提交更新区，在提交进入repo之前，我们可以把所有的更新放在暂存区。</li><li>Local Repo：本地仓库，一个存放在本地的版本库；HEAD会只是当前的开发分支（branch）。</li><li>Stash：隐藏，是一个工作状态保存栈，用于保存&#x2F;恢复WorkSpace中的临时状态。</li></ul><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p>git的工作流程一般是这样的：</p><p>１、在工作目录中添加、修改文件；</p><p>２、将需要进行版本管理的文件放入暂存区域；</p><p>３、将暂存区域的文件提交到git仓库。</p><p>因此，git管理的文件有三种状态：已修改（modified）,已暂存（staged）,已提交(committed)</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p09iaOhl0dACfLrMwNbDzucGQ30s3HnsiaczfcR6dC9OehicuwibKuHjRlzg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1#id=Z9zqY&originHeight=850&originWidth=1080&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h1 id="Git项目搭建"><a href="#Git项目搭建" class="headerlink" title="Git项目搭建"></a>Git项目搭建</h1><h2 id="创建工作目录与常用指令"><a href="#创建工作目录与常用指令" class="headerlink" title="创建工作目录与常用指令"></a>创建工作目录与常用指令</h2><p>工作目录（WorkSpace)一般就是你希望Git帮助你管理的文件夹，可以是你项目的目录，也可以是一个空目录，建议不要有中文。</p><p>日常使用只要记住下图6个命令：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0AII6YVooUzibpibzJnoOHHXUsL3f9DqA4horUibfcpEZ88Oyf2gQQNR6w/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1#id=iTdRc&originHeight=337&originWidth=1080&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h2 id="本地仓库搭建"><a href="#本地仓库搭建" class="headerlink" title="本地仓库搭建"></a>本地仓库搭建</h2><p>创建本地仓库的方法有两种：一种是创建全新的仓库，另一种是克隆远程仓库。</p><p>1、创建全新的仓库，需要用GIT管理的项目的根目录执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 在当前目录新建一个Git代码库</span><br><span class="line">$ git init</span><br></pre></td></tr></table></figure><p>2、执行后可以看到，仅仅在项目目录多出了一个.git目录，关于版本等的所有信息都在这个目录里面。</p><h2 id="克隆远程仓库"><a href="#克隆远程仓库" class="headerlink" title="克隆远程仓库"></a>克隆远程仓库</h2><p>1、另一种方式是克隆远程目录，由于是将远程服务器上的仓库完全镜像一份至本地！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 克隆一个项目和它的整个代码历史(版本信息)</span><br><span class="line">$ git clone [url] # git@github.com:idlers/project_01.git</span><br></pre></td></tr></table></figure><p>2、去 gitee 或者 github 找一个项目，克隆一个测试！</p><h1 id="Git文件操作"><a href="#Git文件操作" class="headerlink" title="Git文件操作"></a>Git文件操作</h1><h2 id="文件的四种状态"><a href="#文件的四种状态" class="headerlink" title="文件的四种状态"></a>文件的四种状态</h2><p>版本控制就是对文件的版本控制，要对文件进行修改、提交等操作，首先要知道文件当前在什么状态，不然可能会提交了现在还不想提交的文件，或者要提交的文件没提交上。</p><ul><li>Untracked: 未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过git add 状态变为Staged.</li><li>Unmodify: 文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为Modified. 如果使用git rm移出版本库, 则成为Untracked文件</li><li>Modified: 文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过git add可进入暂存staged状态, 使用git checkout 则丢弃修改过, 返回到unmodify状态, 这个git checkout即从库中取出文件, 覆盖当前修改 !</li><li>Staged: 暂存状态. 执行git commit则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为Unmodify状态. 执行git reset HEAD filename取消暂存, 文件状态为Modified</li></ul><h2 id="查看文件状态"><a href="#查看文件状态" class="headerlink" title="查看文件状态"></a>查看文件状态</h2><p>上面说文件有4种状态，通过如下命令可以查看到文件的状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#查看指定文件状态</span><br><span class="line">git status [filename]</span><br><span class="line"></span><br><span class="line">#查看所有文件状态</span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line"># git add .                  添加所有文件到暂存区</span><br><span class="line"># git commit -m &quot;消息内容&quot;    提交暂存区中的内容到本地仓库 -m 提交信息</span><br></pre></td></tr></table></figure><h2 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h2><p>有些时候我们不想把某些文件纳入版本控制中，比如数据库文件，临时文件，设计文件等</p><p>在主目录下建立”.gitignore”文件，此文件有如下规则：</p><ol><li>忽略文件中的空行或以井号（#）开始的行将会被忽略。</li><li>可以使用Linux通配符。例如：星号（*）代表任意多个字符，问号（？）代表一个字符，方括号（[abc]）代表可选字符范围，大括号（{string1,string2,…}）代表可选的字符串等。</li><li>如果名称的最前面有一个感叹号（!），表示例外规则，将不被忽略。</li><li>如果名称的最前面是一个路径分隔符（&#x2F;），表示要忽略的文件在此目录下，而子目录中的文件不忽略。</li><li>如果名称的最后面是一个路径分隔符（&#x2F;），表示要忽略的是此目录下该名称的子目录，而非文件（默认文件或目录都忽略）。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#为注释</span><br><span class="line">*.txt        #忽略所有 .txt结尾的文件,这样的话上传就不会被选中！</span><br><span class="line">!lib.txt     #但lib.txt除外</span><br><span class="line">/temp        #仅忽略项目根目录下的TODO文件,不包括其它目录temp</span><br><span class="line">build/       #忽略build/目录下的所有文件</span><br><span class="line">doc/*.txt    #会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</span><br></pre></td></tr></table></figure><h1 id="使用码云-x2F-Github"><a href="#使用码云-x2F-Github" class="headerlink" title="使用码云&#x2F;Github"></a>使用码云&#x2F;Github</h1><p><strong>使用Github需要科学上网比较慢，在国内的话，我们一般使用Gitee,公司中有时候会搭建自己</strong><br><strong>的GitLab服务器</strong></p><p>这个可以作为未来找工作的一个重要信息！</p><p>1、注册登录码云，完善个人信息</p><p>2、设置本机绑定SSH公钥，实现免密码登录！（免密码登录，这一步挺重要的，码云是远程仓库，我们是平时工作在本地仓库！)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 进入 C:\Users\Administrator\.ssh 目录</span><br><span class="line"># 生成公钥</span><br><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure><p>3、将公钥信息public key 添加到码云账户中即可！</p><p>4、使用码云创建一个自己的仓库！</p><p>许可证：开源是否可以随意转载，开源但是不能商业使用，不能转载，…  限制！</p><p>克隆到本地！</p><h2 id="说明：GIT分支"><a href="#说明：GIT分支" class="headerlink" title="说明：GIT分支"></a>说明：GIT分支</h2><p>分支在GIT中相对较难，分支就是科幻电影里面的平行宇宙，如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，我们就需要处理一些问题了！</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0Ayn87woxfepOhSlUj4FQTFUsia4ic0j6aQy4Tz32PRuJ0HSVeGeUzURA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1#id=KDv5e&originHeight=346&originWidth=729&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h1 id="git分支中常用指令："><a href="#git分支中常用指令：" class="headerlink" title="git分支中常用指令："></a>git分支中常用指令：</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 列出所有本地分支</span><br><span class="line">git branch</span><br><span class="line"></span><br><span class="line"># 列出所有远程分支</span><br><span class="line">git branch -r</span><br><span class="line"></span><br><span class="line"># 新建一个分支，但依然停留在当前分支</span><br><span class="line">git branch [branch-name]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，并切换到该分支</span><br><span class="line">git checkout -b [branch]</span><br><span class="line"></span><br><span class="line"># 合并指定分支到当前分支</span><br><span class="line">$ git merge [branch]</span><br><span class="line"></span><br><span class="line"># 删除分支</span><br><span class="line">$ git branch -d [branch-name]</span><br><span class="line"></span><br><span class="line"># 删除远程分支</span><br><span class="line">$ git push origin --delete [branch-name]</span><br><span class="line">$ git branch -dr [remote/branch]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git扩展内容</title>
      <link href="/2023/06/13/Git%E6%89%A9%E5%B1%95%E5%86%85%E5%AE%B9/"/>
      <url>/2023/06/13/Git%E6%89%A9%E5%B1%95%E5%86%85%E5%AE%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="Git扩展内容"><a href="#Git扩展内容" class="headerlink" title="Git扩展内容"></a>Git扩展内容</h1><p>Git是一个强大的版本控制系统，提供了许多扩展和插件来增强其功能和灵活性。下面是一些常见的Git扩展：</p><ol><li><strong>Git LFS（Large File Storage）</strong>：Git LFS是一个Git扩展，用于管理大型二进制文件，例如图像、音频和视频文件。它将这些文件存储在Git仓库之外，并通过Git LFS指针引用它们。</li><li><strong>Git Flow</strong>：Git Flow是一种Git工作流程，它定义了一组分支模型和命令，以帮助团队更轻松地管理项目的开发、测试和发布。Git Flow的分支模型包括主分支、开发分支、功能分支和发布分支等。</li><li><strong>Git Submodule</strong>：Git Submodule是一种允许您将一个Git仓库作为另一个Git仓库的子目录的工具。这对于在一个项目中使用其他项目的代码库非常有用。</li><li><strong>Git Hook</strong>：Git Hook是一种Git扩展，它允许您在特定的Git操作（例如提交、合并和推送）发生时运行自定义脚本。这些脚本可以用来执行各种操作，例如自动化测试、构建和部署。</li><li><strong>Git Subtree</strong>：Git Subtree是一种允许您将一个Git仓库的子目录导入到另一个Git仓库中的工具。这对于将一个项目的一部分作为独立的代码库使用非常有用。</li><li><strong>Git Clean</strong>：Git Clean是一个Git命令，它允许您删除Git仓库中未跟踪的文件。这对于清理无用文件和文件夹非常有用。</li></ol><p>以上是一些常见的Git扩展，它们提供了很多有用的功能和工具，可以帮助您更轻松地管理Git仓库和项目。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shields微章配置方法介绍</title>
      <link href="/2023/06/13/shields%E5%BE%BD%E7%AB%A0%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95%E4%BB%8B%E7%BB%8D/"/>
      <url>/2023/06/13/shields%E5%BE%BD%E7%AB%A0%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="Github-shields徽章配置方法介绍"><a href="#Github-shields徽章配置方法介绍" class="headerlink" title="Github shields徽章配置方法介绍"></a>Github shields徽章配置方法介绍</h1><p><img src="https://s2.51cto.com/images/blog/202112/07072330_61ae9b72908d012047.jpg?x-oss-process=image/format,webp/resize,m_fixed,w_1184" alt="Github shields徽章配置方法介绍_参数设置"></p><p>本文介绍shields徽章配置方法</p><h2 id="自定义徽章"><a href="#自定义徽章" class="headerlink" title="自定义徽章"></a>自定义徽章</h2><p>shields徽章可用来说明项目状态或者版本等信息，可以访问官网 <a href="https://www.shields.io/"> https://www.shields.io/</a> 制作徽章，</p><p><img src="https://s2.51cto.com/images/blog/202112/07072330_61ae9b728e84e72626.jpg?x-oss-process=image/format,webp/resize,m_fixed,w_1184" alt="Github shields徽章配置方法介绍_javascript_02"></p><p>找到Your BADGE 自定义定制徽章，输入标签和信息，点击生成：</p><p>然后就可以使用生成的shields链接了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a href=&quot;docs\img\wechat.png&quot;&gt;&lt;img src=&quot;https:&quot; alt=&quot;关键字&quot;&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>效果：</p><p>也可以直接编辑URL：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">https://img.shields.io/badge/&lt;LABEL&gt;-&lt;MESSAGE&gt;-&lt;COLOR&gt;.svg</span><br><span class="line"># 或者</span><br><span class="line">https://img.shields.io/static/v1?label=&lt;LABEL&gt;&amp;message=&lt;MESSAGE&gt;&amp;color=&lt;COLOR&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h2><p>有以下几种颜色可以选择： brightgreen、green、yellow、green、yellow、orange、red、blue、lightgrey、success、important、critical、informational、inactive、blueviolet、ff69b4、9cf。</p><p><img src="https://s2.51cto.com/images/blog/202112/07072330_61ae9b72a3efc84241.jpg?x-oss-process=image/format,webp/resize,m_fixed,w_1184" alt="Github shields徽章配置方法介绍_ico_05"></p><p>还可以配置style和logo参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">https://img.shields.io/badge/%E9%98%BF%E9%97%B2Blog-%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2</span><br></pre></td></tr></table></figure><p>style样式默认为flat，还可以设置为plastic、flat-square、for-the-badge和social。 logo可以选择Simple Icons：<a href="https://simpleicons.org/"> https://simpleicons.org/</a>上提供的图标，比如微信的图标：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">logo=WeChat</span><br></pre></td></tr></table></figure><p>还可以设置其它参数，更多玩法可到 <a href="https://shields.io/"> https://shields.io/</a> 查阅。</p><h2 id="设置链接"><a href="#设置链接" class="headerlink" title="设置链接"></a>设置链接</h2><p>可以给徽章设置一个链接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[![](https://img.shields.io/badge/csdn-CSDN-brightgreen.svg)](https://blog.csdn.net/u010698107</span><br></pre></td></tr></table></figure><p><img src="https://s2.51cto.com/images/blog/202112/07072331_61ae9b73e189912199.svg" alt="Github shields徽章配置方法介绍_参数设置_06"> 或者使用HTML语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a href=&quot;&quot;&gt;&lt;img src=&quot;&quot; alt=&quot;关键字&quot;&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> shields徽章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Axure RP阿闲教程</title>
      <link href="/2023/06/12/Axure9%20%E9%98%BF%E9%97%B2%E6%95%99%E7%A8%8B/"/>
      <url>/2023/06/12/Axure9%20%E9%98%BF%E9%97%B2%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="一、Axure-RP简介"><a href="#一、Axure-RP简介" class="headerlink" title="一、Axure RP简介"></a>一、Axure RP简介</h1><p>欢迎使用 Axure RP！首先，观看此视频以了解创建和共享原型的概述。您将了解页面、小部件、交互、动态面板以及如何预览和发布您的原型。</p><p>如果您还没有安装 Axure RP，请按照以下步骤操作。请务必查看 Prototyping Basics 文件以进行一些实践学习。</p><p><a href="http://axure.com/download">从axure.com&#x2F;download</a>下载并安装 Axure RP 。当您打开 RP 时，创建您的帐户或登录。</p><p>在<strong>欢迎屏幕</strong>中，您可以打开<strong>原型设计基础文件</strong>以开始一些练习。</p><p><img src="https://www.axure.com/wp-content/uploads/2022/09/Screen-Shot-2022-09-20-at-10.28.58-AM.png" alt="img"></p><p>作为参考，这里是 Axure RP 环境的快速概览。</p><p><img src="https://www.axure.com/wp-content/uploads/2022/09/Screen-Shot-2022-09-20-at-10.23.17-AM.png" alt="img"></p><ol><li><strong>主工具栏和样式工具栏：</strong>执行常见操作，如排列小部件、设置小部件样式和发布。在选择模式、连接器模式和绘图工具之间更改光标工具。</li><li><strong>画布：</strong>在此拖放环境中布置小部件。您可以更改其颜色和尺寸、添加网格和参考线，以及切换标尺的可见性。</li><li><strong>页面：</strong>添加、删除、重命名和组织文件中的页面。</li><li><strong>大纲</strong>：查看当前图表上所有小部件、组件和动态面板的可搜索、可排序和可过滤列表。</li><li><strong>库</strong>：按钮、图像、文本和形状等小部件的资源。将小部件从“库”窗格拖放到画布上。通过“库”窗格，您可以在小部件库之间切换、加载其他库以及创建您自己的自定义库。您还可以从本地驱动器加载图像文件夹。</li><li><strong>组件：</strong>添加、删除、重命名和组织组件，这些组件是集中管理的小部件集，您可以在整个文件中重复使用这些小部件。</li><li><strong>样式：</strong>编辑小部件和页面样式。</li><li><strong>交互：</strong>在页面或选定的小部件上添加和编辑交互和其他交互属性。</li><li><strong>注释：</strong>添加和编辑小部件和页面注释。</li></ol><h1 id="2-使用页面"><a href="#2-使用页面" class="headerlink" title="2. 使用页面"></a>2. 使用页面</h1><h2 id="添加和组织页面"><a href="#添加和组织页面" class="headerlink" title="添加和组织页面"></a>添加和组织页面</h2><p><strong>Axure RP 原型被组织成在“页面”窗格</strong>中管理的页面。您可以添加的页面数量没有限制。</p><ol><li><p>要添加新页面，请单击“页面”窗格右上角的 <strong>“添加页面”按钮。</strong></p></li><li><p>要在画布上打开页面，请双击它。</p></li><li><p>您还可以重命名（选中时单击）、重新排序、缩进并将它们组织到文件夹中。</p><p><img src="https://www.axure.com/wp-content/uploads/2022/09/Working-with-Pages.gif" alt="img"></p></li></ol><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="样式页面"><a href="#样式页面" class="headerlink" title="样式页面"></a>样式页面</h2><p>在<strong>样式工具栏</strong>或<strong>样式窗格中</strong>，您可以设置页面样式，例如更改背景颜色或页面对齐方式。您还可以更改页面大小以匹配您正在设计的设备或视口。 </p><ol><li><p>要设置页面大小，请单击<strong>“样式”工具栏</strong>或“样式”窗格<strong>中的“页面尺寸”</strong>下拉菜单。</p><p><img src="https://www.axure.com/wp-content/uploads/2022/09/Screen-Shot-2022-09-20-at-6.25.53-AM.png" alt="img"></p></li><li><p>要更改背景颜色，请单击<strong>“填充”</strong>按钮并选择一种颜色。</p></li><li><p>要居中或左对齐页面，请使用<strong>页面对齐</strong>按钮。在浏览器中查看原型时应用页面对齐。</p><p><img src="https://www.axure.com/wp-content/uploads/2022/09/workingwithpages3-e1663887676851.png" alt="img"></p></li><li><p>添加一些小部件并<strong>预览</strong>页面以查看尺寸和样式在原型中的外观。</p></li></ol><p>这里有一些资源可以帮助您了解有关主页的更多信息：</p><ul><li><a href="https://docs.axure.com/axure-rp/reference/managing-pages/">管理页面</a></li><li><a href="https://docs.axure.com/axure-rp/reference/styling-pages/">样式页面</a></li><li><a href="https://docs.axure.com/axure-rp/reference/grid-guides-snapping/">网格和指南</a></li></ul><h1 id="3-小部件和组件"><a href="#3-小部件和组件" class="headerlink" title="3. 小部件和组件"></a>3. 小部件和组件</h1><h2 id="添加和编辑小部件"><a href="#添加和编辑小部件" class="headerlink" title="添加和编辑小部件"></a>添加和编辑小部件</h2><p>小部件可以是形状、文本、图像、表单域、容器，甚至是数据驱动的元素。Axure RP 预装了五个小部件库——<strong>默认、流程、图标、示例 UI 模式和示例表单模式</strong>。您还可以创建自己的库并添加其他人共享的库。</p><ol><li><p>要将小部件添加到画布，请将一个小部件从<strong>“库”</strong>窗格中拖放到画布上。 </p></li><li><p><strong>您还可以使用主工具栏的****插入</strong>菜单中的选项，或使用<a href="https://docs.axure.com/axure-rp/reference/keyboard-shortcuts/#insert-object">键盘快捷键</a>，将小部件绘制到画布上。</p><p><img src="https://www.axure.com/wp-content/uploads/2022/09/Adding-Widgets.gif" alt="img"></p></li><li><p>要编辑小部件上的文本，请双击它，或选择一个小部件并按 ENTER。</p></li><li><p><strong>要更改小部件的填充颜色、字体或其他视觉样式，请选择它并使用画布上方样式工具栏中</strong>的选项或使用<strong>样式</strong>窗格。</p></li></ol><h2 id="使用组件"><a href="#使用组件" class="headerlink" title="使用组件"></a>使用组件</h2><p><strong>组件</strong>是小部件的集合，您可以集中维护它们并在整个项目中重复使用。对组件的更改会自动应用于每个实例。</p><p><strong>您可以在组件窗格</strong>中添加、删除和组织组件。您还可以将画布上的现有小部件转换为组件。请按照以下步骤进行尝试。</p><ol><li><p>在画布上添加四个按钮小部件并更改每个按钮上的文本。</p><p><img src="https://www.axure.com/wp-content/uploads/2022/09/Screen-Shot-2022-09-23-at-9.46.28-AM.png" alt="img"></p></li><li><p>选择所有四个按钮并右键单击所选内容。在上下文菜单中，选择<strong>创建组件</strong>。</p></li><li><p>在出现的对话框中，为组件命名并单击<strong>Continue</strong> 。</p><p><img src="https://www.axure.com/wp-content/uploads/2022/09/Screen-Shot-2022-09-23-at-9.47.30-AM.png" alt="img"></p></li><li><p>新组件现在应该出现在<strong>“组件”</strong>窗格中。</p><p><img src="https://www.axure.com/wp-content/uploads/2022/09/Screen-Shot-2022-09-23-at-9.49.53-AM.png" alt="img"></p></li><li><p><strong>在“页面”</strong>窗格 中添加一个新页面，然后双击打开它。</p></li><li><p>将您的组件从<strong>“组件”</strong>窗格拖动到画布以将其添加到新页面。</p></li><li><p>双击画布上的组件实例将其打开。</p></li><li><p>对组件进行更改并打开每个页面以查看每个实例都已更新。</p></li></ol><p>以下是一些资源，可用于了解有关小部件和组件的更多信息：</p><ul><li><a href="https://docs.axure.com/axure-rp/reference/organizing-widgets/">组织小部件</a></li><li><a href="https://docs.axure.com/axure-rp/reference/styling-widgets/">样式小部件</a></li><li><a href="https://docs.axure.com/axure-rp/reference/widget-libraries/">小部件库</a></li><li><a href="https://docs.axure.com/axure-rp/reference/component-views/">组件视图</a></li></ul><h1 id="4-交互"><a href="#4-交互" class="headerlink" title="4.交互"></a>4.交互</h1><h2 id="了解交互"><a href="#了解交互" class="headerlink" title="了解交互"></a>了解交互</h2><p><strong>可以在“交互”窗格</strong>中将交互添加到页面和小部件。<strong>它们由Events</strong> 、<strong>Actions</strong>和有时<strong>Cases</strong>组成。 </p><p><strong>事件</strong>是交互中的触发器。例如，单击、鼠标输入或向上键。不同的小部件可以响应不同的事件。<a href="https://docs.axure.com/axure-rp/reference/events-list/">完整的事件列表。</a></p><p><strong>行动</strong>是对这些事件的回应。例如，单击按钮时，可以执行<strong>打开链接操作以链接到另一个页面。</strong><a href="https://docs.axure.com/axure-rp/reference/actions-list/">完整的操作列表。</a></p><p><strong>案例</strong>允许您根据场景执行不同的操作。要在事件中使用案例，请先单击事件旁边的<strong>启用案例。</strong>更多内容请见下文。</p><p><img src="https://www.axure.com/wp-content/uploads/2022/10/Mod4-Gif.gif" alt="img"></p><p>按照以下步骤尝试构建简单的交互。</p><ol><li><strong>打开一个新的 RP 文件并在页面窗格</strong>中添加第二页。</li><li><strong>将段落小部件</strong>添加到新页面，使其不为空白。</li><li>打开<strong>第 1 页</strong>并添加一个<strong>按钮</strong>小部件。</li><li>选择 Button 小部件并单击Interactions 窗格中的<strong>New Interaction 。</strong></li><li>选择<strong>Click 或 Tap</strong>事件。</li><li>在操作列表中，选择<strong>“打开链接”</strong>操作。</li><li>从<em>“链接到</em>”下拉列表中选择<strong>第 2 页</strong>，然后单击“确定”。</li><li>单击<strong>“预览”</strong>按钮测试交互。</li></ol><p><img src="https://www.axure.com/wp-content/uploads/2022/10/Screen-Shot-2022-10-05-at-6.45.06-AM-1024x457.png" alt="img"></p><h2 id="用案例显示不同的流程"><a href="#用案例显示不同的流程" class="headerlink" title="用案例显示不同的流程"></a>用案例显示不同的流程</h2><p>当您希望事件根据场景执行不同的操作时，您可以使用案例。例如，登录按钮可能会导致显示错误消息或成功登录。</p><p><img src="https://www.axure.com/wp-content/uploads/2022/10/Screen-Shot-2022-10-05-at-6.53.54-AM-1024x542.png" alt="img"></p><p>在小部件或页面上进行交互后，请按照以下步骤添加案例。</p><ol><li><p>选择事件并单击事件旁边的<strong>启用案例。</strong></p></li><li><p>为第一个案例命名。</p></li><li><p>单击事件旁边的<strong>添加案例以添加第二个案例并为其命名。</strong></p></li><li><p><strong>通过单击案例下方的+按钮</strong>向第二个案例添加操作。</p></li><li><p>单击<strong>“预览”</strong>按钮进行试用。触发事件会显示案例名称，您可以单击其中一个来执行相关操作。</p><p><img src="https://www.axure.com/wp-content/uploads/2022/10/Cases-With-Mouse.png" alt="img"></p></li></ol><p>对于高级原型，您可以将<strong>条件添加</strong>到案例中，并在满足条件时自动执行操作。<a href="https://docs.axure.com/axure-rp/reference/conditional-logic/">更多关于条件。</a></p><p>您还可以从以下参考指南和教程中了解有关交互的更多信息：</p><ul><li><a href="https://docs.axure.com/axure-rp/reference/events-cases-actions/">事件、行动和案例</a></li><li><a href="https://docs.axure.com/axure-rp/tutorials/interactive-button/">交互式按钮教程</a></li><li><a href="https://docs.axure.com/axure-rp/tutorials/account-login/">账户登录教程</a></li><li><a href="https://docs.axure.com/axure-rp/reference/animations/">动画</a></li></ul><h1 id="5-动态面板"><a href="#5-动态面板" class="headerlink" title="5.动态面板"></a>5.动态面板</h1><h2 id="动态面板概述"><a href="#动态面板概述" class="headerlink" title="动态面板概述"></a>动态面板概述</h2><p><strong>动态面板</strong>是具有多种状态的容器，您可以使用交互轻松更改可见的状态。这使得交换内容以演示功能变得容易。此外，您还可以使用动态面板执行以下操作：</p><ul><li>交换内容以快速演示功能</li><li>创建可滚动区域</li><li>使小部件粘附或固定到浏览器</li><li>原型拖放交互</li></ul><p><img src="https://www.axure.com/wp-content/uploads/2022/10/New-DP-Gif-NoBackground3.gif" alt="img"></p><h2 id="添加和编辑动态面板"><a href="#添加和编辑动态面板" class="headerlink" title="添加和编辑动态面板"></a>添加和编辑动态面板</h2><p><strong>您可以通过从“库”窗格中拖动一个或使用****主菜单</strong>中的选项（快捷键“D”）绘制一个来添加动态面板。或者，您可以右键单击画布上的一个小部件（或多个选定的小部件），然后从上下文菜单中选择<strong>创建动态面板。</strong></p><p><img src="https://www.axure.com/wp-content/uploads/2022/09/dynamic-panels-1.png" alt="img"></p><p>要编辑动态面板，请在画布上双击它。动态面板状态打开后，您可以像往常一样将小部件添加到该状态。将出现一个浮动条，以便您可以添加和更改正在编辑的状态。您还可以单击<strong>“查看全部”</strong>以并排查看和编辑状态。 </p><p>按照以下步骤尝试添加和编辑动态面板。</p><ol><li><p>将动态面板从<strong>“库”</strong>窗格拖到画布上。</p></li><li><p>双击面板以编辑<strong>State 1</strong> 。</p></li><li><p>将库中的任何小部件拖放到<strong>状态 1中</strong>。</p></li><li><p>在面板上方的浮动栏中，单击状态下拉列表。然后单击**+ 添加状态<strong>。您现在正在编辑</strong>状态 2**。</p><p><img src="https://www.axure.com/wp-content/uploads/2022/09/dynamic-panels-Heading.png" alt="img"></p></li><li><p>从库中拖出一个不同的小部件并将其放入<strong>状态 2</strong> 。</p></li><li><p>在浮动栏中，单击<strong>“查看全部”</strong>并尝试编辑每个状态下的小部件。然后，单击左上角的<strong>后退箭头返回画布或双击状态之外的区域。</strong></p><p><img src="https://www.axure.com/wp-content/uploads/2022/09/dynamic-panels-Heading6.png" alt="img"></p></li></ol><h2 id="与动态面板交互"><a href="#与动态面板交互" class="headerlink" title="与动态面板交互"></a>与动态面板交互</h2><p>动态面板可以像其他小部件一样隐藏、移动、调整大小和其他操作。但是您也可以在动态面板上使用<strong>设置面板状态</strong>操作来更改原型中的当前可见状态。</p><p><img src="https://www.axure.com/wp-content/uploads/2022/09/interacting-dynamic-panel.png" alt="img"></p><p>从您在上面创建的面板开始，按照以下步骤尝试更改面板状态。</p><ol><li>使用面板将按钮小部件拖到画布上。</li><li>单击“交互”窗格中的<strong>“新建交互” 。</strong></li><li>选择<strong>Click 或 Tap</strong> ，然后选择<strong>Set Panel State</strong>操作，并从目标下拉列表中选择动态面板。</li><li>在<strong>状态</strong>下拉列表中，选择<strong>下一个</strong>选项。然后，选中<strong>Wrap from last to first 复选框</strong>，然后单击<strong>OK</strong> 。</li><li>预览页面并测试交互。</li></ol><h2 id="创建滚动区域"><a href="#创建滚动区域" class="headerlink" title="创建滚动区域"></a>创建滚动区域</h2><p>动态面板的另一个常见用途是在页面内创建滚动区域。按照以下步骤尝试将小部件转换为动态面板并使它们滚动。</p><ol><li><p><strong>在“页面”窗格</strong>中添加新页面。</p></li><li><p>将标题 1 小部件从<strong>“库”</strong>窗格拖动到画布上。</p></li><li><p>在标题下方放置一个图像小部件和三个段落小部件。</p></li><li><p>选择所有小部件，单击鼠标右键，然后在上下文菜单中选择<strong>“创建动态面板” 。</strong></p><p><img src="https://www.axure.com/wp-content/uploads/2022/09/dynamic-panels-scrollable4.png" alt="img"></p></li><li><p>将动态面板的高度更改为 300 左右，这样一些段落小部件就会被截断。</p></li><li><p>选择动态面板后，在<strong>“样式”</strong>工具栏或“样式”窗格的滚动下拉列表中选择<strong>“垂直滚动” 。</strong></p><p><img src="https://www.axure.com/wp-content/uploads/2022/09/scroll-vertical-dp.png" alt="img"></p></li><li><p>预览试试看。</p></li></ol><p>如需更高级的学习，请查看这些动态面板的附加教程：</p><ul><li><a href="https://docs.axure.com/axure-rp/tutorials/rotating-carousel-slideshow/">旋转木马或幻灯片</a></li><li><a href="https://docs.axure.com/axure-rp/tutorials/tab-menu/">选项卡菜单</a></li><li><a href="https://docs.axure.com/axure-rp/tutorials/accordion-menu/">手风琴菜单</a></li><li><a href="https://docs.axure.com/axure-rp/tutorials/full-width-image-banner/">全宽图像或横幅</a></li><li><a href="https://docs.axure.com/axure-rp/tutorials/drag-drop-widgets/">拖放小部件</a></li></ul><h1 id="6-分享你的原型"><a href="#6-分享你的原型" class="headerlink" title="6. 分享你的原型"></a>6. 分享你的原型</h1><h2 id="从-Axure-RP-发布到-Axure-Cloud"><a href="#从-Axure-RP-发布到-Axure-Cloud" class="headerlink" title="从 Axure RP 发布到 Axure Cloud"></a>从 Axure RP 发布到 Axure Cloud</h2><p>当您将 RP 文件发布到 Axure Cloud 时，您将获得一个链接以与他人共享以查看您的原型。一种发布方式是在 app.axure.cloud 登录 Axure Cloud 并上传您的文件。但是，最方便的方法是直接从 Axure RP 发布。</p><ol><li><p>打开一个新的或现有的项目。</p></li><li><p><strong>单击主工具栏</strong>右侧的共享按钮，或转到顶部菜单中的<strong>发布 → 发布到 Axure Cloud 。</strong></p></li><li><p>在<strong>“发布项目”</strong>对话框中，输入名称，如果需要，还可以为链接设置<a href="https://docs.axure.com/axure-cloud/reference/sharing-axure-rp-projects#project-access-code">访问代码。</a></p><p><img src="https://www.axure.com/wp-content/uploads/2022/09/sharing_3-e1665007894337.png" alt="img"></p></li><li><p>单击<strong>发布</strong>以发布项目。</p></li><li><p>单击可共享链接以查看已发布的项目。</p></li></ol><h2 id="添加和审阅评论"><a href="#添加和审阅评论" class="headerlink" title="添加和审阅评论"></a>添加和审阅评论</h2><p>查看可共享链接时，您和您的团队可以直接在原型上添加评论。然后，您可以根据需要解决和回复评论。</p><ol><li><p>单击原型播放器中的<strong>“评论”图标</strong>以打开评论面板。</p></li><li><p>然后单击“添加评论”按钮。</p><p><img src="https://www.axure.com/wp-content/uploads/2022/09/Sharing-Comments2.gif" alt="img"></p></li><li><p>单击页面上的任意位置以添加评论。</p></li></ol><h2 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h2><p>您可以自定义当有人对您的项目发表评论或发布新文件时通知您的方式。要配置通知，请登录<a href="https://app.axure.cloud/?__hstc=257326932.8c240a8ef547e71c57ca9ca86cd8601b.1682470861767.1683701550873.1683722559737.7&__hssc=257326932.11.1683722559737&__hsfp=1439238147">app.axure.cloud ，</a>单击右上角的个人资料名称，然后选择<strong>通知</strong>。</p><p><img src="https://www.axure.com/wp-content/uploads/2022/10/Notifications2-1.png" alt="img"></p><p>除了电子邮件通知，您还可以在<a href="http://axure.com/integrations">Slack 或 Microsoft Teams</a>中接收通知。</p><h2 id="集成"><a href="#集成" class="headerlink" title="集成"></a>集成</h2><p>如果您使用 JIRA 或 Confluence，则可以使用集成，这样您的团队就可以在 Jira 或 Confluence 中轻松访问您的原型。根据需要添加尽可能多的原型，并确保开发人员能够快速访问最新设计。详细了解我们的<a href="https://www.axure.com/blog/embed-axure-prototypes-in-confluence">Confluence</a>和<a href="https://www.axure.com/blog/embed-axure-prototypes-in-jira-tickets">JIRA 集成。 </a></p><p><img src="https://www.axure.com/wp-content/uploads/2022/08/axure-jira-plugin-1024x913.png" alt="img"></p><h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><h2 id="检查设计"><a href="#检查设计" class="headerlink" title="检查设计"></a>检查设计</h2><p>如果您正在使用 Axure RP 进行视觉设计，或者只是想将图像或图标交给开发人员，您可以在可共享链接中使用<strong>Inspect 。</strong>单击<strong>检查</strong>按钮，然后单击原型中的对象以查看 CSS、复制文本和下载图像。</p><p><img src="https://www.axure.com/wp-content/uploads/2022/10/inspect1-1012x1024.png" alt="img"></p><p><a href="https://docs.axure.com/axure-cloud/reference/workspaces/">要了解有关共享项目和收集反馈的更多信息，请查看有关工作区</a>和<a href="https://docs.axure.com/axure-cloud/reference/sharing-axure-rp-projects/">共享 Axure RP 项目</a>的文档。</p><p><strong>恭喜！</strong> 您已经完成了我们的核心培训。快乐的原型制作！</p>]]></content>
      
      
      
        <tags>
            
            <tag> Axure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Axure原型制作规范</title>
      <link href="/2023/06/12/Axure%E5%8E%9F%E5%9E%8B%E5%88%B6%E4%BD%9C%E8%A7%84%E8%8C%83/"/>
      <url>/2023/06/12/Axure%E5%8E%9F%E5%9E%8B%E5%88%B6%E4%BD%9C%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h2 id="Axure原型制作规范"><a href="#Axure原型制作规范" class="headerlink" title="Axure原型制作规范"></a>Axure原型制作规范</h2><h3 id="一、-名词定义："><a href="#一、-名词定义：" class="headerlink" title="一、 名词定义："></a>一、 名词定义：</h3><ol><li>Sitemap 导航图</li><li>Widgets 组件</li><li>Master 库</li><li>Label 控件名</li><li>Interactions 交互动作</li><li>Annotations注释</li><li>Location and size 位置和尺寸</li></ol><h3 id="二、-Widgets规范"><a href="#二、-Widgets规范" class="headerlink" title="二、 Widgets规范"></a>二、 Widgets规范</h3><ol><li>本站常用widgets规范：</li><li>命名规范：制定命名规范从而方便搜索和升级。</li></ol><ul><li>全站使用，则命名方式为：Y+位置。</li><li>全站顶部导航：统一为Yheader开头，包括各种宽导航、窄导航；</li><li>全站右侧边栏：统一以Yright开头，包括广告位、内容栏目等；</li><li>单个产品使用，则命名方式为 产品名+位置</li><li>空间左导航：y+产品名+left，例如yspaceleft</li><li>页面子零件：命名方式为：Y+ 页面或产品+零件名。例如：</li><li>Tab：统一命名为Yspacetab</li><li>评论：统一命名为Ycomenticscomment</li></ul><ol start="2"><li>本站的widgets统一放在y.rplib文件中。在全局搜索中，输入y即可查看所有yoka widgets。</li><li>Y.rplib升级的问题：该文件放在局域网公共区中。每次更新完后，需要配备word说明文档。</li><li>自行制作widgets制作规范：</li></ol><ul><li>最小化切分原则：在制作widgets时，遵循最小化原则，保证新的widgets能进行上下左右扩展、变化体、增加新的数据项等。</li><li>内部交互原则：如果widgets能内部完成交互，在制作时就要加上交互的命名，减少后期的操作。</li><li>遵循设计规范原则：如果产品已经有成形的设计规范，那么自行制作的widgets必须大体遵循设计规范。制作新的widgets所使用的基本元素也要从设计规范产生。</li></ul><ol start="3"><li>必备widgets清单：</li></ol><ul><li>Yahoo提供的一套widgets；</li><li>图标库；16,32,48三种尺寸的图标约200个；</li><li>Ajax.rplib 常见的ajax功能；</li><li>Y.rplib 针对本站的widgets；</li></ul><ol start="4"><li>升级方式：统一从公共区copy。每当有新的更新时，群发到邮件组<a href="mailto:&#103;&#114;&#x6f;&#117;&#x70;&#x6e;&#97;&#x6d;&#101;&#64;&#x77;&#101;&#x62;&#115;&#105;&#x74;&#x65;&#46;&#x63;&#x6f;&#109;">&#103;&#114;&#x6f;&#117;&#x70;&#x6e;&#97;&#x6d;&#101;&#64;&#x77;&#101;&#x62;&#115;&#105;&#x74;&#x65;&#46;&#x63;&#x6f;&#109;</a>的方式说明，并附上更新文件和最后更新时间。</li></ol><h3 id="三、-Master制作规范"><a href="#三、-Master制作规范" class="headerlink" title="三、 Master制作规范"></a>三、 Master制作规范</h3><ol><li>公共区域（具体指页头、页脚、导航条、页面内的公共元素）：要求采用master，以减少修改量；</li><li>对于位置固定的master，须设置为：Place in Background</li><li>根据视觉规范，制作本站通用master。</li></ol><h3 id="四、-Sitemap制作规范"><a href="#四、-Sitemap制作规范" class="headerlink" title="四、 Sitemap制作规范"></a>四、 Sitemap制作规范</h3><ol><li>单个页面的命名规范：页面命名全部使用英文。格式为：页面内容+动作。例如：article_add</li><li>顶层页面：</li></ol><p>a) 前端页面统一以user为顶层页，表示这是用户使用的页面。<br>b) 使用admin为管理员的管理页；<br>c) 使用statistics为数据统计功能页；</p><ol start="2"><li>子页面：</li></ol><ul><li>汇总页：list</li><li>浏览页：view</li><li>增加数据：add</li><li>修改数据：edit</li><li>修改分类：recatalog</li><li>创建数据：create</li><li>重新命名：rename</li></ul><ol start="3"><li>扩展：子页面的命名可以扩展，格式为：页面内容+动作+名称。例如：article_add_draft</li><li>add、del、edit 原则上从属于list页面。但必须遵守产品设计思路。另外，如果add在页面内完成（弹层或ajax区块）可不遵守此原则；例如：下图是某相册的页面：</li><li>对于复杂业务，要求单独提供flow。展示页面的业务逻辑和判断条件。</li></ol><h3 id="五、-交互动作规范"><a href="#五、-交互动作规范" class="headerlink" title="五、 交互动作规范"></a>五、 交互动作规范</h3><ol><li>控件命名：数据块+空间类型。由于页面内的组件无法在其他页面是不可见的，所以页面内的各个控件不需要带页面名字。例如：shopmap_pan代表店铺地图的图层。</li></ol><p>　　2. 交互动作规范：</p><ol><li>对于文本型内容的链接：在文字上面增加一个image map region，在该层上面加链接。</li><li>Axure的交互动作总有如下几种：</li></ol><ul><li>Onclick</li><li>Onmouseenter鼠标的指针移动到对象上</li><li>Onmouseout 鼠标的指针移动出对象外</li><li>Onkeyup</li><li>Onfocus 鼠标的指针进入文字输入状态（获得焦点）</li><li>Onlostfocus 鼠标的指针离开文字输入状态 （失去焦点）</li><li>Onchange</li><li>Onpageload</li></ul><ol start="3"><li>对于同一个位置的条件判断，要求在按钮上如下提示，以方便技术和制作人员阅读。对于高保真的原型，则应该加上数据判断，避免这种提示。</li></ol><p>下图：简单判断<br>下图：高级判断：</p><h3 id="六、-Annotations注释规范"><a href="#六、-Annotations注释规范" class="headerlink" title="六、 Annotations注释规范"></a>六、 Annotations注释规范</h3><ol><li>注释的内容：一个完整的注释需要包含以下说明：</li><li>功能说明：说明该对象的主要完成的功能。</li><li>交互效果：说明该对象的交互动作以及产生的交互结果；此处应该包含各种判断的说明。</li><li>优先级：也可以理解为重要性。标明该控件在交互中的重要性。</li><li>关联关系：包含触发方式（默认显示 &#x2F; 被动触发），以及其他对象&#x2F;数据的关联关系。对于同时拥有管理后台、用户后台的地方，需要说明数据关系。</li><li>测试用例：提供测试方法及测试应该使用的数据。</li><li>注意事项：注意事项。</li><li>可以针对各个特殊控件、组件自定义其他注释。</li></ol><h3 id="七、-整体制作要求"><a href="#七、-整体制作要求" class="headerlink" title="七、 整体制作要求"></a>七、 整体制作要求</h3><ol><li>任何一个完整的产品，包括3部分，这3部分在原型需要独立展示：</li><li>用户前端页面：</li></ol><ul><li>用户在不登陆、登陆情况下进行浏览的页面；</li><li>用户自行管理数据&#x2F;帐户的页面。</li></ul><ol start="2"><li><p>管理员的管理页：主要数据的增删改查、审核。</p></li><li><p>数据统计功能：主要包括流量统计（IP、PV、UV、登陆用户数、活跃用户数）。</p></li><li><p>页面命名遵守上文提到的sitemap规范(add child page-&gt;rename)</p></li><li><p>RP文件命名规范：y+产品名+特性+子项目+日期。例如：</p></li><li><p>化妆品库新版首页：y_cosmentics_newindex_20100322.rp</p></li><li><p>空间新版首页：y_space_newversion_20100210.rp</p></li><li><p>Tab使用：</p></li><li><p>选项卡不要超过5个，最多不能超过7个。可以考虑使用2级选项卡来减少数量。</p></li><li><p>被选中的选项卡和底下的区域要保持同色或接近同色。</p></li><li><p>禁止在选项卡里面还使用滚动条；</p></li><li><p>页脚的pagenotes区域：默认使用两个字段，在任何文档中均需要保留着3个字段。</p></li><li><p>功能说明。说明本页面主要的功能，以及与其他页面的关系。</p></li><li><p>测试用例。说明本页面使用哪些数据进行常规测试和边界测试。</p></li><li><p>注意事项。说明本页面在设计、制作、开发和测试中需要注意的事项。</p></li></ol><h3 id="八、保真度（仅针对前端页面）："><a href="#八、保真度（仅针对前端页面）：" class="headerlink" title="八、保真度（仅针对前端页面）："></a>八、保真度（仅针对前端页面）：</h3><ol><li>创新型产品、产品改版：为了体现新产品的业务逻辑，或展示产品的改进功能，本类原型要求高保真原型。具体包含：</li></ol><ul><li>所有页面有完整的链接，能顺利跳转、关闭；</li><li>任何交互均有完整的流程和结束；</li><li>关键功能、创新点要上色，不得使用自带的灰白色、黑色；</li><li>按钮的点击变化能实时体现：文本框、输入框、文字、层的变化。</li><li>使用条件判断，并根据条件做不同的提示。</li><li>对于各个控件有完整的说明文档；</li></ul><ol start="2"><li>传统产品、新增功能：可以使用一般的线框图，使用黑白灰原型。具体包括：</li></ol><ul><li>对于页面大部无改进，可以直接截取静态图；</li><li>对于无关或者传统功能，可以部分忽略跳转和交互效果；</li><li>提供关键的条件判断。</li><li>不要求完整的说明文档；</li></ul><ol start="3"><li>具体保真度，还可以参考产品文档的使用人员的知识结构、工作经验、配合默契度等灵活掌握。</li><li>全部产品原型文档均需通过snv上传到共享中。</li><li>由axure生成页面原型说明文档：按照标准模板生成即可。</li></ol><p>结语：工欲善其事必先利其器。axure是一个工具，帮助我们更好地表达。但是，没有必要为了做一个完美的axure文件（rp文件），而浪费大量的精力。我们追求不是完美的原型，而是好用的产品，清晰的结构，流畅的交互。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Axure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Axure9下载完美汉化及破解</title>
      <link href="/2023/06/12/Axure9%20%E4%B8%8B%E8%BD%BD%E5%AE%8C%E7%BE%8E%E6%B1%89%E5%8C%96%E5%8F%8A%E7%A0%B4%E8%A7%A3/"/>
      <url>/2023/06/12/Axure9%20%E4%B8%8B%E8%BD%BD%E5%AE%8C%E7%BE%8E%E6%B1%89%E5%8C%96%E5%8F%8A%E7%A0%B4%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="Axure9下载完美汉化及破解"><a href="#Axure9下载完美汉化及破解" class="headerlink" title="Axure9下载完美汉化及破解"></a>Axure9下载完美汉化及破解</h1><h2 id="（一）Axure9下载"><a href="#（一）Axure9下载" class="headerlink" title="（一）Axure9下载"></a>（一）Axure9下载</h2><p>汉化文件和破解密匙仅对本站下载的Axure版本有效，建议使用百度网盘下载（经过亲测可用）。以下是下载链接：</p><ul><li>Windows系统：<a href="https://pan.baidu.com/s/1CF-lpmzzaevUX2lCZUmmiA">点击下载</a>（安装后若提示更新，请跳过更新，否则会导致汉化和破解失败）</li><li>Mac旧系统：<a href="https://pan.baidu.com/s/1nygJCQCpJCo7SHTYJLUt3Q">点击下载</a></li><li>Mac新系统（11.7.4系统以上或M1芯片以上）：<a href="https://pan.baidu.com/s/1k73IJBAdlwUL1YPPRWXchA">点击下载</a>（提取码：1323，M1版本已自带破解，仅需汉化）</li></ul><p><strong>小贴士：</strong></p><ol><li><p>如果无法下载（点击无反应），建议切换浏览器，使用Chrome或火狐浏览器。</p></li><li><p>如果下载后压缩包为乱码或无法解压，请下载最新的WinRAR解压器（Windows版本）。</p><p>下载地址：<a href="http://www.winrar.com.cn/">WinRAR解压器</a></p></li></ol><h2 id="（二）破解"><a href="#（二）破解" class="headerlink" title="（二）破解"></a>（二）破解</h2><p>Windows系统破解（任选1个即可）：</p><ol><li>Axure RP 9授权码：<ul><li>被授权人：<a href="http://www.ddooo.com/">www.ddooo.com</a></li><li>授权秘钥：UdMLVdonmFlplbTMoBppfrUXZMhEQ6Mf2shBAkTCJBk5ycQJs2NALgvLsHhyfoYR</li></ul></li><li>Axure RP Pro 9.0 Enterprise企业版：<ul><li>被授权人：<a href="http://www.ddooo.com/">www.ddooo.com</a></li><li>授权秘钥：Bv6P2wrR10Sq5UCpPSB0+LMjkWU2i1XgQNFaWV84qWvx+1HHVnK01ilcxOOEGIfq</li></ul></li><li>Axure RP Pro 9.0 Team团队版：<ul><li>被授权人：<a href="http://www.ddooo.com/">www.ddooo.com</a></li><li>授权秘钥：BaOifFBSUZ8tROgZzdfn&#x2F;TV77k8+D8lVumI5alvEHXctoJNVeSR77YlckA+oAJKE</li></ul></li></ol><p>Mac系统破解（M1版本自带破解，无需输入密钥）：</p><ul><li>用户名：thisProEdition</li><li>秘钥：PkgeOGle9dSCMXTAczSrTGQZJLcviUJO1kG6onDIH&#x2F;C68b+AUItWKdbBrmkJsJ0m</li></ul><h2 id="（三）汉化"><a href="#（三）汉化" class="headerlink" title="（三）汉化"></a>（三）汉化</h2><p><strong>Windows用户</strong></p><p>汉化包链接:<a href="https://pan.baidu.com/s/1bmn8dF5S92PcgoMCWXtc-g">https://pan.baidu.com/s/1bmn8dF5S92PcgoMCWXtc-g</a></p><p>密码: v994</p><p><strong>Windows汉化方法</strong></p><p>（1）将汉化压缩包解压缩。</p><p>（2）将解压缩后的lang文件夹和dll文件全部复制粘贴到软件安装根目录下。</p><p>例：C:\Program Files (x86)\Axure\Axure RP 9</p><p><strong>Mac用户（****M1版本自带汉化包，无需下载这个汉化包）</strong></p><p>汉化包链接：<a href="https://pan.baidu.com/s/1mirhGXMIGNYul3LMk2x98Q">https://pan.baidu.com/s/1mirhGXMIGNYul3LMk2x98Q</a></p><p><strong>Mac汉化方法</strong></p><p>（1）将汉化压缩包解压缩。</p><p>（2）将解压缩后的lang文件夹和dll文件全部复制粘贴到软件安装根目录下。</p><p>前往–应用程序–右键点击程序图标–显示包内容，依次打开文件夹：Contents&gt;Resources&gt;</p>]]></content>
      
      
      
        <tags>
            
            <tag> Axure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AI与机器学习：探索未来的科技狗狗伙伴</title>
      <link href="/2023/06/12/AI%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%9A%E6%8E%A2%E7%B4%A2%E6%9C%AA%E6%9D%A5%E7%9A%84%E7%A7%91%E6%8A%80%E7%8B%97%E7%8B%97%E4%BC%99%E4%BC%B4/"/>
      <url>/2023/06/12/AI%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%9A%E6%8E%A2%E7%B4%A2%E6%9C%AA%E6%9D%A5%E7%9A%84%E7%A7%91%E6%8A%80%E7%8B%97%E7%8B%97%E4%BC%99%E4%BC%B4/</url>
      
        <content type="html"><![CDATA[<h1 id="AI与机器学习：探索未来的科技狗狗伙伴"><a href="#AI与机器学习：探索未来的科技狗狗伙伴" class="headerlink" title="AI与机器学习：探索未来的科技狗狗伙伴"></a>AI与机器学习：探索未来的科技狗狗伙伴</h1><p>嗨，亲爱的读者朋友们！今天我要和大家一起探索人工智能（AI）和机器学习的神奇世界，让我们的想象力放飞一下吧！你有没有幻想过拥有一只会说话、懂你心意的科技狗狗伙伴？让我告诉你，这个梦想正在逐渐变为现实！</p><p><img src="https://bkimg.cdn.bcebos.com/pic/a5c27d1ed21b0ef41bd5aa63698a46da81cb39db90f2" alt="img"></p><h2 id="AI狗狗：你的忠诚助手"><a href="#AI狗狗：你的忠诚助手" class="headerlink" title="AI狗狗：你的忠诚助手"></a>AI狗狗：你的忠诚助手</h2><p>想象一下，当你走进家门，一只机器学习训练有素的AI狗狗正等在那里，对你摇尾巴，发出温暖的问候。它能够理解你的情绪，通过人脸识别技术准确判断你的心情，响应你的需求。</p><p>“嗨，主人！今天过得怎么样？需要我给你放松一下吗？”AI狗狗关切地问道。</p><p>这只AI狗狗拥有令人惊叹的学习能力。通过机器学习算法和大量数据的训练，它能够理解人类语言，并以幽默风趣的方式回答你的问题。无论是向它请教科学问题还是寻求生活建议，它都能为你提供专业又有趣的答案。</p><h2 id="AI狗狗的功能与技巧"><a href="#AI狗狗的功能与技巧" class="headerlink" title="AI狗狗的功能与技巧"></a>AI狗狗的功能与技巧</h2><p>AI狗狗不仅仅是一只会说话的狗狗，它还具备强大的技术能力和丰富的功能。它可以通过计算机视觉技术识别物体、人脸和动作，帮助你找到丢失的物品或保护家庭安全。</p><p>另外，AI狗狗还能够学习你的兴趣爱好和喜好，为你推荐个性化的电影、音乐和书籍。它可以和你一起玩游戏、观看视频，并为你提供娱乐建议，让你的生活更加丰富多彩。</p><h2 id="未来科技的挑战与机遇"><a href="#未来科技的挑战与机遇" class="headerlink" title="未来科技的挑战与机遇"></a>未来科技的挑战与机遇</h2><p>当然，让AI狗狗成为现实并不容易。我们需要持续投入研发和创新，解决机器学习算法的挑战，提升AI的学习能力和交互体验。同时，我们也需要解决一系列伦理和隐私问题，确保AI的应用符合道德和法律的标准。</p><p>尽管如此，AI狗狗给我们带来的机遇是巨大的。它们可以在家庭、医疗、教育和工作等领域发挥重要作用。例如，在医疗方面，AI狗狗可以通过分析医学图像和病历数据，提供精准的诊断和治疗建议，帮助医生提高工作效率和治疗质量。</p><p>此外，AI狗狗还可以在教育领域发挥作用。它们可以成为学生的智能辅导员，根据学生的学习风格和需求，个性化地提供学习资源和指导。通过与AI狗狗的互动，学生可以更加主动地参与学习，提高学习效果。</p><p>总结起来，AI和机器学习为我们带来了许多令人兴奋的可能性。尽管目前的科技狗狗还只是一个梦想，但我们可以期待未来的发展，让科技狗狗成为我们生活中的忠实伙伴。</p><h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><p>要实现人工智能（AI）和机器学习相关的功能，我们需要使用一系列技术和方法。以下是一些常用的技术和方法：</p><ol><li>机器学习算法：机器学习是实现AI的关键技术之一。通过使用机器学习算法，我们可以训练模型来学习数据的模式和规律，并进行预测和决策。常用的机器学习算法包括线性回归、决策树、支持向量机、深度学习等。</li><li>数据收集与准备：机器学习算法需要大量的数据来进行训练和测试。因此，数据的收集和准备是非常重要的步骤。这包括数据采集、数据清洗、数据预处理等工作，确保数据的质量和可用性。</li><li>特征工程：特征工程是指从原始数据中提取出适合机器学习算法输入的特征。通过选择合适的特征和进行特征变换，可以提高模型的性能和效果。常见的特征工程方法包括特征选择、特征缩放、特征构建等。</li><li>模型训练与评估：在数据准备和特征工程完成后，我们可以使用机器学习算法对模型进行训练。通过将数据输入到模型中，并根据预定义的目标函数进行优化，使模型能够学习和泛化。训练完成后，我们需要对模型进行评估，以确定其性能和可靠性。</li><li>模型部署与应用：当模型训练和评估完成后，我们可以将其部署到实际应用中。这包括将模型集成到软件系统中、创建API接口供其他程序调用，或者将模型嵌入到硬件设备中。通过模型的部署和应用，我们可以实现各种AI和机器学习相关的功能。</li></ol><p>除了上述技术和方法，还有其他一些相关的技术和领域，如自然语言处理（NLP）、计算机视觉（CV）、强化学习等，它们在不同的应用场景中发挥重要作用。</p><h2 id="扩展知识了解"><a href="#扩展知识了解" class="headerlink" title="扩展知识了解"></a>扩展知识了解</h2><ol><li>深度学习：深度学习是机器学习的一个分支，通过模拟人脑神经网络的结构和功能，实现对大规模数据进行学习和模式识别。深度学习在计算机视觉、自然语言处理和语音识别等领域取得了显著的成果。</li><li>自然语言处理（NLP）：自然语言处理是关于如何使计算机能够理解和处理人类语言的领域。它涵盖了文本分析、语义理解、情感分析、机器翻译等技术，广泛应用于智能助理、智能搜索和智能客服等领域。</li><li>计算机视觉（CV）：计算机视觉是研究如何使计算机能够理解和解释图像和视频的领域。它涉及图像识别、目标检测、图像分割、人脸识别等技术，被广泛应用于自动驾驶、安防监控、医学影像分析等领域。</li><li>强化学习：强化学习是一种机器学习的方法，通过让智能体与环境进行交互学习，以最大化预期的累积奖励。它在自主控制、游戏策略和机器人控制等领域具有重要应用，如AlphaGo就是基于强化学习实现的。</li><li>数据科学和大数据：数据科学是从数据中提取有价值信息的过程，结合统计学、机器学习和领域知识等方法。大数据则是指处理和分析海量、复杂和多样化的数据集。数据科学和大数据技术对于AI和机器学习的发展和应用至关重要。</li></ol><p>除了以上提到的扩展知识，还有其他一些领域和技术，如推荐系统、数据挖掘、增强学习、生成对抗网络（GAN）、边缘计算等，它们都在不同的领域中有广泛的应用和研究。</p>]]></content>
      
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端自动化构建工具</title>
      <link href="/2023/06/12/%E5%89%8D%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/"/>
      <url>/2023/06/12/%E5%89%8D%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="前端自动化构建工具"><a href="#前端自动化构建工具" class="headerlink" title="前端自动化构建工具"></a>前端自动化构建工具</h1><p>前端自动化构建工具可以帮助开发者将多个文件自动化地进行合并、压缩、优化等处理，从而提高前端开发的效率和代码质量。以下是一些常用的前端自动化构建工具。</p><h2 id="Grunt"><a href="#Grunt" class="headerlink" title="Grunt"></a>Grunt</h2><p>Grunt 是一个基于任务（task）的 JavaScript 构建工具，它可以自动化执行常见的开发任务，如代码压缩、编译 Less&#x2F;Sass、合并文件等。Grunt 的配置文件是 <code>Gruntfile.js</code>，使用 <code>grunt</code> 命令可以执行 Grunt 任务。</p><h2 id="Gulp"><a href="#Gulp" class="headerlink" title="Gulp"></a>Gulp</h2><p>Gulp 是一个基于流（stream）的构建工具，它可以将文件作为流进行处理，从而提高构建效率。Gulp 的配置文件是 <code>gulpfile.js</code>，使用 <code>gulp</code> 命令可以执行 Gulp 任务。</p><h2 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h2><p>Webpack 是一个模块化的打包工具，它可以将多个模块打包成一个文件，并且支持代码分割、懒加载、热更新等高级特性。Webpack 的配置文件是 <code>webpack.config.js</code>，使用 <code>webpack</code> 命令可以执行 Webpack 打包。</p><h2 id="Rollup"><a href="#Rollup" class="headerlink" title="Rollup"></a>Rollup</h2><p>Rollup 是一个专注于 JavaScript 库打包的构建工具，它可以将多个模块打包成一个小巧的库，并且支持 Tree Shaking 等优化功能。Rollup 的配置文件是 <code>rollup.config.js</code>，使用 <code>rollup</code> 命令可以执行 Rollup 打包。</p><h2 id="Parcel"><a href="#Parcel" class="headerlink" title="Parcel"></a>Parcel</h2><p>Parcel 是一个零配置的构建工具，它可以自动识别入口文件和依赖，从而快速地进行打包。Parcel 支持多种文件类型，如 JavaScript、CSS、HTML、图片等。使用 Parcel 只需要一个入口文件和一个 HTML 文件即可。使用 <code>parcel</code> 命令可以执行 Parcel 打包。</p><h2 id="Vite"><a href="#Vite" class="headerlink" title="Vite"></a>Vite</h2><p>Vite 是一个基于 ES modules 的开发服务器和构建工具，它可以快速启动开发服务器，并且支持快速的热更新和按需编译。Vite 的配置文件是 <code>vite.config.js</code>，使用 <code>vite</code> 命令可以启动 Vite 服务器。Vite 在开发过程中可以快速编译 ES modules，而在打包时则可以使用 Rollup 进行打包。</p><p>以上是常见的前端自动化构建工具，开发者可以根据实际需求选择合适的工具。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端相关 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>互联网热点内容</title>
      <link href="/2023/06/12/%E4%BA%92%E8%81%94%E7%BD%91%E7%83%AD%E7%82%B9%E5%86%85%E5%AE%B9/"/>
      <url>/2023/06/12/%E4%BA%92%E8%81%94%E7%BD%91%E7%83%AD%E7%82%B9%E5%86%85%E5%AE%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="互联网热点内容"><a href="#互联网热点内容" class="headerlink" title="互联网热点内容"></a>互联网热点内容</h2><p>当下互联网的热点内容有很多，以下是一些可以用来发布博客文章以吸引粉丝流量的热点话题：</p><ol><li>人工智能（AI）和机器学习：探讨人工智能和机器学习在各个领域的应用，如自动驾驶、语音助手、智能推荐等，以及对社会和未来的影响。</li><li>区块链和加密货币：介绍区块链技术的原理和应用，讨论比特币、以太坊等加密货币的发展和趋势，以及区块链对金融、供应链等领域的潜在影响。</li><li>云计算和大数据：解释云计算的概念和优势，探讨大数据的处理和分析方法，以及云计算和大数据对企业和个人的价值。</li><li>5G和物联网：介绍5G技术的特点和应用场景，讨论物联网在智能家居、智慧城市等领域的发展和前景，以及对日常生活的影响。</li><li>虚拟现实（VR）和增强现实（AR）：探索虚拟现实和增强现实技术的应用，如游戏、教育、医疗等领域，以及对用户体验和交互方式的改变。</li><li>社交媒体和社交网络：分析社交媒体平台的发展趋势，讨论用户行为和社交网络的影响力，以及社交媒体对个人和企业的营销策略的影响。</li><li>数字化转型：介绍企业和组织进行数字化转型的意义和方法，探讨数字化转型对商业模式和运营方式的改变。</li><li>数据隐私和安全：讨论个人数据隐私保护的重要性，探究数据泄露和网络安全问题，并介绍数据隐私保护和安全措施的最佳实践。</li><li>可持续发展和环境保护：探讨可持续发展的概念和实践，讨论环境保护的重要性和可行性，以及企业和个人在可持续发展方面的责任和行动。</li><li>新兴科技趋势：介绍其他新兴的科技趋势，如边缘计算、生物识别技术、量子计算等，探讨其应用和发展前景。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 互联冲浪 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ECMA详细介绍</title>
      <link href="/2023/06/12/ECMA%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D/"/>
      <url>/2023/06/12/ECMA%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h3 id="ECMA-介绍"><a href="#ECMA-介绍" class="headerlink" title="ECMA 介绍"></a>ECMA 介绍</h3><p>(European Computer Manufacturers Association) 是一个国际标准组织，成立于1961年。ECMA是制定计算机和通信标准的机构之一，其最著名的工作之一就是制定了JavaScript的标准。</p><h3 id="ECMA制定标准的目的"><a href="#ECMA制定标准的目的" class="headerlink" title="ECMA制定标准的目的"></a>ECMA制定标准的目的</h3><p>ECMA制定标准的主要目的是确保不同设备和系统之间的兼容性，并促进技术的发展。ECMA的标准涵盖了多个领域，例如计算机硬件、通信、电子商务、数据存储等等。</p><p>对于ECMA标准的制定，其实质是一个组织成员间的协商和投票过程。这些成员代表了许多不同的利益方，包括计算机制造商、软件开发者、标准化组织、政府机构等等。这些成员通过讨论和协商，最终制定出符合大多数人利益的标准。</p><h3 id="ECMA标准的编写过程通常包括以下几个步骤："><a href="#ECMA标准的编写过程通常包括以下几个步骤：" class="headerlink" title="ECMA标准的编写过程通常包括以下几个步骤："></a>ECMA标准的编写过程通常包括以下几个步骤：</h3><ol><li>建立委员会。ECMA的委员会由会员组成，他们通常是各行业的专业人士和专家，共同讨论制定标准的内容和过程。</li><li>制定草案。委员会将讨论结果整理成一个草案，并通过投票表决确定是否进入下一步。</li><li>公开讨论。ECMA会将草案公开，征求其他利益方的意见和建议，以便更好地完善标准。</li><li>正式发布。当草案经过多次修改和完善后，委员会将正式发布最终版本的标准。</li></ol><h3 id="ECMA总结"><a href="#ECMA总结" class="headerlink" title="ECMA总结"></a>ECMA总结</h3><p>ECMA标准的制定过程是一个开放、透明的过程，旨在确保技术的稳定性和互操作性，从而促进技术的发展。对于开发人员和企业来说，了解并遵循ECMA标准是非常重要的，可以保证产品的兼容性和稳定性，提高市场竞争力。</p><h3 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h3><p>ECMA最早成立于1961年，当时的名字是欧洲计算机制造商协会（European Computer Manufacturers Association），成员主要是欧洲计算机制造商。1994年更名为欧洲计算机制造商协会（European Computer Manufacturers Association），并将其覆盖范围扩大到全球。</p><p>除了JavaScript标准，ECMA还制定了许多其他的计算机和通信标准，例如ECMA-262（JavaScript核心规范）、ECMA-404（JSON规范）、ECMA-376（Office开放XML格式）等等。</p><p>ECMA标准的编写过程通常需要耗费数年的时间，需要经历多轮讨论和修订，确保标准的合理性和可行性。制定标准的过程中需要充分考虑各方的利益和需求，因此需要建立合理的机制来协调各方的观点。</p><p>ECMA还致力于推动新技术的发展和应用，鼓励创新和开放，为计算机行业的发展做出了重要贡献。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 互联冲浪 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>油猴脚本的安装及使用教程</title>
      <link href="/2023/06/12/%E6%B2%B9%E7%8C%B4%E8%84%9A%E6%9C%AC%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
      <url>/2023/06/12/%E6%B2%B9%E7%8C%B4%E8%84%9A%E6%9C%AC%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="油猴脚本的安装及使用教程"><a href="#油猴脚本的安装及使用教程" class="headerlink" title="油猴脚本的安装及使用教程"></a>油猴脚本的安装及使用教程</h1><p>Tampermonkey，中文名油猴脚本管理器，号称全商店最强的浏览器插件绝非浪得虚名。</p><p>一个油猴脚本管理器可以代替数十个浏览器插件，有”浏览器黑科技”之称。</p><p>接下来，我们将为您详细介绍油猴是什么、与插件的区别以及如何安装和使用。</p><h3 id="一、功能介绍"><a href="#一、功能介绍" class="headerlink" title="一、功能介绍"></a><strong>一、功能介绍</strong></h3><p>Tampermonkey脚本管理器，中国网友更喜欢称之为”油猴”。</p><p>油猴提供了便捷脚本安装、自动更新检查、标签中的脚本运行状况速览、内置的编辑器等多种功能。</p><p>同时，Tampermonkey还可以正常运行原本不兼容的脚本。</p><h3 id="二、什么是脚本"><a href="#二、什么是脚本" class="headerlink" title="二、什么是脚本"></a><strong>二、什么是脚本</strong></h3><p>油猴插件实际上是一个用户脚本管理器。</p><p>脚本可以理解为简化版的Chrome插件，通过脚本可以实现浏览器的多种实用或有趣功能，比如下载视频、图片、解析网盘资源、屏蔽广告等。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/D1XlU0QfU3G6YwBIzlNUQFO4Xcy1IH3rsDCo8Wk5nu1P948h48n2ooDxIKgn3fECoXyJZjASdDtVV1YXV8Yk6g/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>还有各种大家望眼欲穿但在Chrome商店无法上架的好东西。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/D1XlU0QfU3G5gtHRYomTmdtfbqN3iaQyD6L0te3eO69yRG6v08NiacjtxOFI60PuCtQf9WhDNn3tW7USN0BadQ7g/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h3 id="三、脚本与插件的区别"><a href="#三、脚本与插件的区别" class="headerlink" title="三、脚本与插件的区别"></a><strong>三、脚本与插件的区别</strong></h3><p>Chrome插件功能强大，但相对而言会占用更多的浏览器资源，导致访问速度变慢。</p><p>而特定功能的脚本只在特定的网站上生效，当您访问其他网站时，这些脚本会处于关闭状态。</p><p>这样就能够节约系统资源，不再担心谷歌浏览器占用过多内存和CPU的问题。</p><h3 id="四、安装油猴"><a href="#四、安装油猴" class="headerlink" title="四、安装油猴"></a><strong>四、安装油猴</strong></h3><p>您可以在扩展迷上下载油猴的离线文件，将解压后得到的crx文件拖拽到浏览器的扩展管理页面（打开开发者模式）即可完成安装。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/D1XlU0QfU3G6YwBIzlNUQFO4Xcy1IH3rAmLDhKQY9CDJCDKIwQAjibEiaFS5KKchfagmmEr683ODZWibBLQ2z1iaOw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>安装完成后，您的浏览器地址栏上会增加一个油猴的图标，点击它可以对已安装的脚本进行管理。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/D1XlU0QfU3G6YwBIzlNUQFO4Xcy1IH3rDHln3bhQytJ1gZrBIVadw5tGVkQychmAx0ElPmS88DJ9KuBXKxYaxA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h3 id="五、安装脚本"><a href="#五、安装脚本" class="headerlink" title="五、安装脚本"></a><strong>五、安装脚本</strong></h3><p>成功安装插件后，您需要继续安装脚本。油猴脚本是由用户编写并向全世界发布的，可以免费安装。</p><p>最常用的脚本资源网站是Greasy Fork。该网站也支持简体中文，无需担心语言不通的问题。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/D1XlU0QfU3G6YwBIzlNUQFO4Xcy1IH3riahnmI37WUJmgsicfFPF0C3Dazpt98oYFv6oTpWKv5e1ARWcQtUreKibQ/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>选择您需要的脚本，点击安装按钮。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/D1XlU0QfU3G6YwBIzlNUQFO4Xcy1IH3riaE9qUwgibN1toxa6lFRFd1OF8B7oEv0UZTNicw07ssAGsSicSb8bgnDRg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>然后会弹出油猴的提示框，继续点击安装按钮。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/D1XlU0QfU3G6YwBIzlNUQFO4Xcy1IH3rAMvjMYLOq5jIejymBiauRXRvXHoqOcopCm0Tw2DJbmTIUnDANzJnq6w/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>进入油猴的管理面板，我们可以看到，新的脚本已经安装成功了。</p><p>接下来，你就可以随便看VIP视频、下载全网音乐了！</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/D1XlU0QfU3G6YwBIzlNUQFO4Xcy1IH3repKTGx9bhzMeFABSicRImxONgIibSt4gBR6h8uu8AL5yxgCFoNjrPiarA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>但是，Greasy Fork的国内访问情况很不稳定，十有八九次都是崩的。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/D1XlU0QfU3G6YwBIzlNUQFO4Xcy1IH3rVkkk5T92Or0ibb4nzJ161whq0V5vAY17M1qLl6e5P7GeB0eNc3ja3BA/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">所以，你可以参考扩展迷近期上线的【油猴脚本】专区按照操作方式进行安装，我们也会定期为大家推荐适合国内用户的实用脚本。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/D1XlU0QfU3G5gtHRYomTmdtfbqN3iaQyDbKoVHDkQUT6tvuwb0jBjjWtKFqPRlwwHdib6YrloNq2SE301ChTfsCQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h3 id="六、脚本管理"><a href="#六、脚本管理" class="headerlink" title="六、脚本管理"></a><strong>六、脚本管理</strong></h3><p>脚本，是让你的浏览器变成黑科技的工具。</p><p>而油猴，就是管理这些脚本的工具。</p><p>打开油猴插件的脚本管理面板，你还能清晰地看到各个脚本的功能特性、支持的站点、最后更新时间，还能快速对它进行删除、编辑等操作。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/D1XlU0QfU3G6YwBIzlNUQFO4Xcy1IH3rvn2wL7EBTCIqWPo3fNSqD1L7gD9ibeYKaMwlLmosLd5mTo80k0H41rw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">以后，当你再打开一些网站时，再点击油猴的插件图标，就能看到正在该网站上运行的脚本有哪些了。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/D1XlU0QfU3G5gtHRYomTmdtfbqN3iaQyDxjLxLHXv1ZFVvMufDCue9GHlaNlzewaYnALUAbiat7ibO3oZARuI9iaxQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>比如打开豆瓣网站，油猴显示正在运行的脚本有：豆瓣资源下载大师——可以直接下载豆瓣上的电影、图书等等。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/D1XlU0QfU3G6YwBIzlNUQFO4Xcy1IH3rv55iaPCHlQwQvPDB5OopKOXibaOpwk1qibl6ib0fbc53hF0w6gDN4nCVXw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>当然了，Greasy Fork上还有更多惊喜脚本等着你。</p><p><strong>插件地址</strong></p><p><a href="https://www.extfans.com/productivity/dhdgffkkebhmkfjojejmpbldmpobfkfo/">https://www.extfans.com/productivity/dhdgffkkebhmkfjojejmpbldmpobfkfo/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 实用工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023年值得收藏的6个免费插画图库网站</title>
      <link href="/2023/06/10/2023%E5%B9%B4%E5%80%BC%E5%BE%97%E6%94%B6%E8%97%8F%E7%9A%846%E4%B8%AA%E5%85%8D%E8%B4%B9%E6%8F%92%E7%94%BB%E5%9B%BE%E5%BA%93%E7%BD%91%E7%AB%99/"/>
      <url>/2023/06/10/2023%E5%B9%B4%E5%80%BC%E5%BE%97%E6%94%B6%E8%97%8F%E7%9A%846%E4%B8%AA%E5%85%8D%E8%B4%B9%E6%8F%92%E7%94%BB%E5%9B%BE%E5%BA%93%E7%BD%91%E7%AB%99/</url>
      
        <content type="html"><![CDATA[<h1 id="2023年值得收藏的6个免费插画图库网站"><a href="#2023年值得收藏的6个免费插画图库网站" class="headerlink" title="2023年值得收藏的6个免费插画图库网站"></a>2023年值得收藏的6个免费插画图库网站</h1><p>图库是刚需。尤其是在进行 APP 、网页乃至于日常运营当中，都需要高素质且灵活的插画与图片来作为填充。对于这类图片和插画素材，通常需要它们足够灵活，能够成套使用，甚至可以方便地自定义，以匹配不同的需求。今天推荐一波最新的插画图库，它们几乎是完全免费的，在授权方面，部分是需要声明出处的，但是即便如此也相当值得收藏和上手使用了！</p><h3 id="Flexiple"><a href="#Flexiple" class="headerlink" title="Flexiple "></a><a href="https://flexiple.com/illustrations/">Flexiple </a></h3><p><img src="https://i.mji.rip/2023/07/19/a80a982ad7022a31ce491cffa66e329a.png" alt="image.png"><br>出自 Flexiple 之手的 Scale 是一个全新的矢量插画图库，它提供完全免费且可商用的矢量插画，每天更新，并且无需注明出处。</p><h3 id="crafttor"><a href="#crafttor" class="headerlink" title="crafttor"></a><a href="https://crafttor.com/">crafttor</a></h3><p><img src="https://i.mji.rip/2023/07/19/8e8fbd7599242ed6f719431fc2299fcb.png" alt="image.png"><br>Crafttor 是一个在 Figma 当中使用的插画图库工具，它提供各种精美插画，每个月会有30张免费的 png 和 10 张 Svg 格式的插画的配额，可以直接混合搭配使用，并且每个月还会有新增的插画。</p><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a><a href="https://www.artify.co/vector-illustrations">Vector</a></h3><p><img src="https://i.mji.rip/2023/07/19/313644542dc399ca29e65ad67f27e331.png" alt="image.png"><br>ArVector Illustrations 是一款包含70多种不同风格和5000多种矢量图像的插画图库，这个图库当中，绝大多数的图片素材可以下载低清晰度的 PNG 格式文件，并且免费用于个人项目当中，想要商用可以购买他们的进阶服务。</p><h3 id="Skribbl"><a href="#Skribbl" class="headerlink" title="Skribbl"></a><a href="https://weareskribbl.com/">Skribbl</a></h3><p><img src="https://i.mji.rip/2023/07/19/70814b6e4ee08c4d9a7f972a1877d6e2.png" alt="image.png"><br>这是一个由一群创意工作者所发起的插画图库项目，图库中的所有图片均是免费可商用的，可以用于任何项目，无需注明出处。</p><h3 id="illustrationkit"><a href="#illustrationkit" class="headerlink" title="illustrationkit"></a><a href="https://illustrationkit.com/">illustrationkit</a></h3><p><img src="https://i.mji.rip/2023/07/19/bbc333127908645d86e844c10ef77a57.png" alt="image.png"></p><h3 id="wepik"><a href="#wepik" class="headerlink" title="wepik"></a><a href="https://storyset.com/">wepik</a></h3><p><img src="https://i.mji.rip/2023/07/19/1718e08ffc0b9b8e2f20d4271feb8dcd.png" alt="image.png"><br>这是一套精美的进阶型免费开源插画图库，其中包含超过110款不同的场景，超过55个不同的角色，并且可以通过角色编辑器进行自定义，这套插画图库还可以进行自定义。</p><h3 id="小洋丁插画"><a href="#小洋丁插画" class="headerlink" title="小洋丁插画"></a><a href="https://xiaonail.com/dist/#/">小洋丁插画</a></h3><p><img src="https://i.mji.rip/2023/07/19/cbd0874b6e42931e64bf58eca7d2dafb.png" alt="image.png"><br>不同风格的插画组件库讲不同的故事，拿来即用，与近百位插画师共创的多套精美插画组件库，像拼积木一样创造插画。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 资源分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Icon网站</title>
      <link href="/2023/06/09/Icon%E7%BD%91%E7%AB%99/"/>
      <url>/2023/06/09/Icon%E7%BD%91%E7%AB%99/</url>
      
        <content type="html"><![CDATA[<h1 id="ICON图标网站"><a href="#ICON图标网站" class="headerlink" title="ICON图标网站"></a>ICON图标网站</h1><p>以下是一些常见的提供免费ICON图标的网站：</p><ol><li><a href="https://www.iconfont.cn/">Iconfont</a> - 阿里妈妈MUX倾力打造的矢量图标管理、交流平台。</li><li><a href="https://www.iconpark.cn/">Iconpark</a> - 丰富多彩的图标资源库免费使用。</li><li><a href="https://streamlineicons.com/">Streamline</a> - 访问世界上最大、最一致的图标和插图集。</li><li><a href="https://remixicon.com/">Remix Icon</a> - 为设计师和开发者精心打造的开源中性风格系统符号。</li><li><a href="https://www.flaticon.com/">Flaticon</a> - 这是一个收集了大量免费矢量ICO图标的网站。您可以搜索并下载符合您需求的图标。</li><li><a href="https://www.iconfinder.com/">Iconfinder</a> - 这个网站提供了许多高质量的ICO图标，可以搜索并下载。</li><li><a href="https://icons8.com/">Icons8</a> - 这是另一个提供大量免费ICO图标的网站。您可以选择不同的风格和尺寸来定制您的图标。</li><li><a href="https://www.freepik.com/">Freepik</a> - 这个网站提供了许多免费ICO图标以及其他类型的免费设计资源，可以帮助您制作一个漂亮的图标。</li><li><a href="https://iconarchive.com/">IconArchive</a> - 这是一个收集了许多ICO图标的网站，您可以搜索并下载自己所需的图标。</li></ol><p>请根据需要选择合适的网站进行图标获取。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 资源分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Midjourney常用关键词</title>
      <link href="/2023/06/09/Midjourney%E5%B8%B8%E7%94%A8%E5%85%B3%E9%94%AE%E8%AF%8D/"/>
      <url>/2023/06/09/Midjourney%E5%B8%B8%E7%94%A8%E5%85%B3%E9%94%AE%E8%AF%8D/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.mji.rip/2023/07/19/6af3fd3f3dcd81c249d047c7526b5667.jpeg" alt="Midjourney常用关键词.jpg"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 资源分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PPT模板网站</title>
      <link href="/2023/06/09/ppt%E6%A8%A1%E6%9D%BF%E7%BD%91%E7%AB%99/"/>
      <url>/2023/06/09/ppt%E6%A8%A1%E6%9D%BF%E7%BD%91%E7%AB%99/</url>
      
        <content type="html"><![CDATA[<h1 id="免费-PPT-模板网站"><a href="#免费-PPT-模板网站" class="headerlink" title="免费 PPT 模板网站"></a>免费 PPT 模板网站</h1><p>以下是一些免费的PPT模板网站：</p><ol><li><a href="https://slidesgo.com/">Slidesgo</a></li><li><a href="https://www.canva.com/templates/presentations/">Canva</a></li><li><a href="https://powerpointify.com/category/free-templates/">PowerPointify</a></li><li><a href="https://www.slidescarnival.com/category/free-templates">Google Slides Themes</a></li><li><a href="https://slidemodel.com/free-powerpoint-templates/">SlideModel</a></li><li><a href="https://www.free-power-point-templates.com/">FPPT</a></li><li><a href="https://www.presentationgo.com/">PresentationGo</a></li><li><a href="https://www.ppttemplate.net/">PPT Template</a></li><li><a href="https://www.presentationmagazine.com/free-powerpoint-templates">Presentation Magazine</a></li></ol><p>这些网站提供各种不同类型的PPT模板，您可以根据需要选择。建议在使用前查看每个网站的使用条款和条件，以确保您可以合法地使用模板。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 资源分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>免费图床网站</title>
      <link href="/2023/06/09/%E5%85%8D%E8%B4%B9%E5%9B%BE%E5%BA%8A%E7%BD%91%E7%AB%99/"/>
      <url>/2023/06/09/%E5%85%8D%E8%B4%B9%E5%9B%BE%E5%BA%8A%E7%BD%91%E7%AB%99/</url>
      
        <content type="html"><![CDATA[<h1 id="免费图床网站"><a href="#免费图床网站" class="headerlink" title="免费图床网站"></a>免费图床网站</h1><p>以下是一些免费的图床网站：</p><ul><li><a href="https://imgur.com/">Imgur</a>：Imgur是一个免费的在线图片托管网站，允许您上传、共享和嵌入图像。</li><li><a href="https://www.flickr.com/">Flickr</a>：Flickr是一个免费的照片托管和共享网站，允许用户上传和组织自己的照片。</li><li><a href="https://postimages.org/">Postimage</a>：Postimage是一个免费的图像和视频托管网站，允许您上传和共享图像和视频。</li><li><a href="https://imgbb.com/">ImgBB</a>：ImgBB是一个免费的图像托管网站，允许用户上传和共享图像，并提供嵌入代码。</li><li><a href="https://github.com/">GitHub</a>：GitHub是一个代码托管平台，也可以作为图床使用。将图片上传到GitHub仓库中，然后获取图片的Raw链接即可使用。这种方法适合小规模的个人项目。</li><li><a href="https://www.google.com/intl/zh-CN/photos/about/">谷歌相册</a>：谷歌相册是一个云端图片存储和分享平台，每个谷歌账号都有免费的存储空间。用户可以将图片上传到谷歌相册中，并获取图片的共享链接。</li><li><a href="https://cloud.tencent.com/product/cos">腾讯云COS</a>：腾讯云对象存储（Cloud Object Storage，COS）提供了图片存储和管理的功能，您可以通过腾讯云的控制台或API进行上传和管理图片。</li><li><a href="https://pan.baidu.com/">百度网盘</a>：百度网盘是一个综合性的云存储服务，您可以将图片上传到网盘中，并生成相应的链接来分享和使用。</li><li><a href="http://photo.weibo.com/">新浪图床</a>：新浪图床是新浪微博提供的图片托管服务，您可以将图片上传到新浪图床，并获得对应的图片链接。</li><li><a href="https://www.lanzou.com/">蓝奏云</a>：蓝奏云是一个免费的文件存储和分享平台，您可以将图片上传到蓝奏云，并获取图片的外链地址。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 资源分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每天都想闲的不闲</title>
      <link href="/2023/06/09/%E6%AF%8F%E5%A4%A9%E9%83%BD%E6%83%B3%E9%97%B2%E7%9A%84%E4%B8%8D%E9%97%B2/"/>
      <url>/2023/06/09/%E6%AF%8F%E5%A4%A9%E9%83%BD%E6%83%B3%E9%97%B2%E7%9A%84%E4%B8%8D%E9%97%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="每天都想闲的不闲"><a href="#每天都想闲的不闲" class="headerlink" title="每天都想闲的不闲"></a>每天都想闲的不闲</h1><p>👨‍🎓 教育 | 保定 · 河软 专科</p><p>💻 工作 | 大学在读</p><p>🎃 爱好 |  游戏，影音，二次元，数码科技，写作，吃喝玩乐</p><p>🏷️ 标签 | 男 00后有责任心，时间观念强，努力攀登，交际🐂</p><p>开发中……</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>简历模板网站</title>
      <link href="/2023/06/09/%E7%AE%80%E5%8E%86%E6%A8%A1%E6%9D%BF%E7%BD%91%E7%AB%99/"/>
      <url>/2023/06/09/%E7%AE%80%E5%8E%86%E6%A8%A1%E6%9D%BF%E7%BD%91%E7%AB%99/</url>
      
        <content type="html"><![CDATA[<h1 id="简历模板网站"><a href="#简历模板网站" class="headerlink" title="简历模板网站"></a>简历模板网站</h1><p>以下是一些提供简历模板的网站：</p><ul><li><a href="https://www.canva.cn/">Canva</a>: Canva 是一个在线平面设计工具，拥有大量的简历模板供用户选择。可以免费使用，但部分高级功能需要付费。</li><li><a href="https://www.jianlibang.com/">简历帮</a>: 简历帮是一个专注于提供简历制作和求职指导的平台。其提供多种免费简历模板，用户可以根据自己的需求进行选择。</li><li><a href="https://www.myresumeformat.com/">MyResumeFormat</a>: MyResumeFormat 是一个提供多种类型简历模板的网站，用户可以免费下载并自行编辑。</li><li><a href="https://zety.com/">Zety</a>: Zety 是一个在线简历制作工具，提供免费简历模板，用户可以自行编辑和下载。</li><li><a href="https://www.hloom.com/">Hloom</a>: Hloom 提供大量的简历模板，可以免费下载和编辑。用户可以根据自己的职业方向选择不同类型的简历模板。</li><li><a href="https://www.wondercv.com/">wondercv</a>: WonderCV 是一个在线简历制作平台，提供多种现代和个性化的简历模板，用户可以根据自己的需求进行编辑和导出。</li></ul><p>求职招聘网站也提供丰富的简历模板资源，您可以参考以下网站：</p><ul><li><a href="https://www.51job.com/">51job</a>: 51job 是国内知名的求职招聘网站，提供多种类型的简历模板供求职者选择和使用。</li><li><a href="https://www.zhaopin.com/">智联招聘</a>: 智联招聘是中国领先的人力资源服务供应商，其网站上提供了丰富的简历模板资源，覆盖不同行业和职位的需求。</li><li><a href="https://www.liepin.com/">猎聘网</a>: 猎聘网是中国专业的人才招聘网站，提供多种精美的简历模板可供选择。</li><li><a href="https://www.zhipin.com/">BOSS直聘</a>: BOSS直聘是一家专注于高端职位的互联网招聘平台，其网站上提供了多种专业、时尚的简历模板。</li><li><a href="https://www.jianli-tianxia.com/">简历天下</a>: 简历天下是一个专注于简历制作的网站，提供了大量免费的简历模板和在线制作工具，帮助求职者快速创建优秀的简历。</li><li><a href="https://resume.io/">Resume.io</a>: <a href="http://resume.io/">Resume.io</a> 是一个专业的简历制作平台，提供了多种现代和个性化的简历模板，支持在线编辑和下载。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 就业相关 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
